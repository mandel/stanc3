  $ ../../../../../install/default/bin/stanc --O --print-cpp ad-level-failing.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace ad_level_failing_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'ad-level-failing.stan', line 45, column 2 to column 21)",
                                                      " (in 'ad-level-failing.stan', line 46, column 2 to column 22)",
                                                      " (in 'ad-level-failing.stan', line 47, column 2 to column 19)",
                                                      " (in 'ad-level-failing.stan', line 48, column 2 to column 22)",
                                                      " (in 'ad-level-failing.stan', line 52, column 2 to column 26)",
                                                      " (in 'ad-level-failing.stan', line 54, column 4 to column 52)",
                                                      " (in 'ad-level-failing.stan', line 55, column 4 to column 67)",
                                                      " (in 'ad-level-failing.stan', line 53, column 2 to line 56, column 3)",
                                                      " (in 'ad-level-failing.stan', line 60, column 2 to column 24)",
                                                      " (in 'ad-level-failing.stan', line 61, column 2 to column 23)",
                                                      " (in 'ad-level-failing.stan', line 62, column 2 to column 21)",
                                                      " (in 'ad-level-failing.stan', line 63, column 2 to column 23)",
                                                      " (in 'ad-level-failing.stan', line 65, column 2 to column 41)",
                                                      " (in 'ad-level-failing.stan', line 67, column 4 to column 49)",
                                                      " (in 'ad-level-failing.stan', line 66, column 2 to line 67, column 49)",
                                                      " (in 'ad-level-failing.stan', line 69, column 2 to column 53)",
                                                      " (in 'ad-level-failing.stan', line 29, column 2 to column 19)",
                                                      " (in 'ad-level-failing.stan', line 30, column 9 to column 12)",
                                                      " (in 'ad-level-failing.stan', line 30, column 2 to column 14)",
                                                      " (in 'ad-level-failing.stan', line 31, column 2 to column 13)",
                                                      " (in 'ad-level-failing.stan', line 32, column 15 to column 18)",
                                                      " (in 'ad-level-failing.stan', line 32, column 2 to column 20)",
                                                      " (in 'ad-level-failing.stan', line 33, column 13 to column 16)",
                                                      " (in 'ad-level-failing.stan', line 33, column 2 to column 18)",
                                                      " (in 'ad-level-failing.stan', line 37, column 2 to column 14)",
                                                      " (in 'ad-level-failing.stan', line 38, column 2 to column 32)",
                                                      " (in 'ad-level-failing.stan', line 40, column 2 to column 14)",
                                                      " (in 'ad-level-failing.stan', line 41, column 2 to column 13)",
                                                      " (in 'ad-level-failing.stan', line 52, column 18 to column 21)",
                                                      " (in 'ad-level-failing.stan', line 17, column 4 to column 17)",
                                                      " (in 'ad-level-failing.stan', line 19, column 4 to column 59)",
                                                      " (in 'ad-level-failing.stan', line 20, column 4 to column 75)",
                                                      " (in 'ad-level-failing.stan', line 21, column 4 to column 30)",
                                                      " (in 'ad-level-failing.stan', line 22, column 4 to column 48)",
                                                      " (in 'ad-level-failing.stan', line 24, column 4 to column 16)",
                                                      " (in 'ad-level-failing.stan', line 15, column 31 to line 25, column 3)"};


template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<stan::promote_args_t<T0__, T1__, T2__,
T3__>>
simple_SIR(const T0__& t, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    std::vector<local_scalar_t__> dydt;
    dydt = std::vector<local_scalar_t__>(4, DUMMY_VAR__);
    
    current_statement__ = 31;
    assign(dydt, cons_list(index_uni(1), nil_index_list()),
      (((-theta[(1 - 1)] * y[(4 - 1)]) / (y[(4 - 1)] + theta[(2 - 1)])) *
        y[(1 - 1)]), "assigning variable dydt");
    current_statement__ = 32;
    assign(dydt, cons_list(index_uni(2), nil_index_list()),
      ((((theta[(1 - 1)] * y[(4 - 1)]) / (y[(4 - 1)] + theta[(2 - 1)])) *
         y[(1 - 1)]) - (theta[(3 - 1)] * y[(2 - 1)])),
      "assigning variable dydt");
    current_statement__ = 33;
    assign(dydt, cons_list(index_uni(3), nil_index_list()),
      (theta[(3 - 1)] * y[(2 - 1)]), "assigning variable dydt");
    current_statement__ = 34;
    assign(dydt, cons_list(index_uni(4), nil_index_list()),
      ((theta[(4 - 1)] * y[(2 - 1)]) - (theta[(5 - 1)] * y[(4 - 1)])),
      "assigning variable dydt");
    current_statement__ = 35;
    return dydt;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct simple_SIR_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<stan::promote_args_t<T0__, T1__, T2__,
T3__>>
operator()(const T0__& t, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__)  const 
{
return simple_SIR(t, y, theta, x_r, x_i, pstream__);
}
};

class ad_level_failing_model final : public model_base_crtp<ad_level_failing_model> {

 private:
  int N_t;
  std::vector<double> t;
  std::vector<double> y0;
  std::vector<int> stoi_hat;
  std::vector<double> B_hat;
  double t0;
  double kappa;
  std::vector<double> x_r;
  std::vector<int> x_i;
 
 public:
  ~ad_level_failing_model() { }
  
  inline std::string model_name() const final { return "ad_level_failing_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  ad_level_failing_model(stan::io::var_context& context__,
                         unsigned int random_seed__ = 0,
                         std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "ad_level_failing_model_namespace::ad_level_failing_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 17;
      context__.validate_dims("data initialization","N_t","int",
          context__.to_vec());
      N_t = std::numeric_limits<int>::min();
      
      current_statement__ = 17;
      N_t = context__.vals_i("N_t")[(1 - 1)];
      current_statement__ = 17;
      current_statement__ = 17;
      check_greater_or_equal(function__, "N_t", N_t, 0);
      current_statement__ = 18;
      validate_non_negative_index("t", "N_t", N_t);
      current_statement__ = 19;
      context__.validate_dims("data initialization","t","double",
          context__.to_vec(N_t));
      t = std::vector<double>(N_t, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 19;
      assign(t, nil_index_list(), context__.vals_r("t"),
        "assigning variable t");
      current_statement__ = 20;
      context__.validate_dims("data initialization","y0","double",
          context__.to_vec(4));
      y0 = std::vector<double>(4, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 20;
      assign(y0, nil_index_list(), context__.vals_r("y0"),
        "assigning variable y0");
      current_statement__ = 21;
      validate_non_negative_index("stoi_hat", "N_t", N_t);
      current_statement__ = 22;
      context__.validate_dims("data initialization","stoi_hat","int",
          context__.to_vec(N_t));
      stoi_hat = std::vector<int>(N_t, std::numeric_limits<int>::min());
      
      current_statement__ = 22;
      assign(stoi_hat, nil_index_list(), context__.vals_i("stoi_hat"),
        "assigning variable stoi_hat");
      current_statement__ = 23;
      validate_non_negative_index("B_hat", "N_t", N_t);
      current_statement__ = 24;
      context__.validate_dims("data initialization","B_hat","double",
          context__.to_vec(N_t));
      B_hat = std::vector<double>(N_t, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 24;
      assign(B_hat, nil_index_list(), context__.vals_r("B_hat"),
        "assigning variable B_hat");
      current_statement__ = 25;
      t0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 25;
      t0 = 0;
      current_statement__ = 26;
      kappa = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 26;
      kappa = 1000000;
      current_statement__ = 27;
      x_r = std::vector<double>(0, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 28;
      x_i = std::vector<int>(0, std::numeric_limits<int>::min());
      
      current_statement__ = 26;
      current_statement__ = 26;
      check_greater_or_equal(function__, "kappa", kappa, 0);
      current_statement__ = 29;
      validate_non_negative_index("y", "N_t", N_t);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "ad_level_failing_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ beta;
      beta = DUMMY_VAR__;
      
      current_statement__ = 1;
      beta = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        beta = stan::math::lb_constrain(beta, 0, lp__);
      } else {
        current_statement__ = 1;
        beta = stan::math::lb_constrain(beta, 0);
      }
      local_scalar_t__ gamma;
      gamma = DUMMY_VAR__;
      
      current_statement__ = 2;
      gamma = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        gamma = stan::math::lb_constrain(gamma, 0, lp__);
      } else {
        current_statement__ = 2;
        gamma = stan::math::lb_constrain(gamma, 0);
      }
      local_scalar_t__ xi;
      xi = DUMMY_VAR__;
      
      current_statement__ = 3;
      xi = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        xi = stan::math::lb_constrain(xi, 0, lp__);
      } else {
        current_statement__ = 3;
        xi = stan::math::lb_constrain(xi, 0);
      }
      local_scalar_t__ delta;
      delta = DUMMY_VAR__;
      
      current_statement__ = 4;
      delta = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        delta = stan::math::lb_constrain(delta, 0, lp__);
      } else {
        current_statement__ = 4;
        delta = stan::math::lb_constrain(delta, 0);
      }
      std::vector<std::vector<local_scalar_t__>> y;
      y = std::vector<std::vector<local_scalar_t__>>(N_t, std::vector<local_scalar_t__>(4, DUMMY_VAR__));
      
      {
        std::vector<local_scalar_t__> theta;
        theta = std::vector<local_scalar_t__>(5, DUMMY_VAR__);
        
        current_statement__ = 6;
        assign(theta, nil_index_list(), std::vector<local_scalar_t__>{beta,
          kappa, gamma, xi, delta}, "assigning variable theta");
        current_statement__ = 7;
        assign(y, nil_index_list(),
          integrate_ode_rk45(simple_SIR_functor__(), y0, t0, t, theta, x_r,
            x_i, pstream__), "assigning variable y");
      }
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N_t; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= 4; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      {
        current_statement__ = 9;
        lp_accum__.add(cauchy_lpdf<propto__>(beta, 0, 2.5));
        current_statement__ = 10;
        lp_accum__.add(cauchy_lpdf<propto__>(gamma, 0, 1));
        current_statement__ = 11;
        lp_accum__.add(cauchy_lpdf<propto__>(xi, 0, 25));
        current_statement__ = 12;
        lp_accum__.add(cauchy_lpdf<propto__>(delta, 0, 1));
        current_statement__ = 13;
        lp_accum__.add(
          poisson_lpmf<propto__>(stoi_hat[(1 - 1)],
            (y0[(1 - 1)] - y[(1 - 1)][(1 - 1)])));
        current_statement__ = 15;
        for (int n = 2; n <= N_t; ++n) {
          current_statement__ = 14;
          lp_accum__.add(
            poisson_lpmf<propto__>(stoi_hat[(n - 1)],
              (y[((n - 1) - 1)][(1 - 1)] - y[(n - 1)][(1 - 1)])));}
        current_statement__ = 16;
        lp_accum__.add(
          lognormal_lpdf<propto__>(B_hat,
            stan::math::log(col(to_matrix(y), 4)), 0.15));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "ad_level_failing_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double beta;
      beta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      beta = in__.scalar();
      current_statement__ = 1;
      beta = stan::math::lb_constrain(beta, 0);
      double gamma;
      gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      gamma = in__.scalar();
      current_statement__ = 2;
      gamma = stan::math::lb_constrain(gamma, 0);
      double xi;
      xi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      xi = in__.scalar();
      current_statement__ = 3;
      xi = stan::math::lb_constrain(xi, 0);
      double delta;
      delta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      delta = in__.scalar();
      current_statement__ = 4;
      delta = stan::math::lb_constrain(delta, 0);
      std::vector<std::vector<double>> y;
      y = std::vector<std::vector<double>>(N_t, std::vector<double>(4, std::numeric_limits<double>::quiet_NaN()));
      
      vars__.emplace_back(beta);
      vars__.emplace_back(gamma);
      vars__.emplace_back(xi);
      vars__.emplace_back(delta);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      {
        std::vector<double> theta;
        theta = std::vector<double>(5, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 6;
        assign(theta, nil_index_list(), std::vector<double>{beta, kappa,
          gamma, xi, delta}, "assigning variable theta");
        current_statement__ = 7;
        assign(y, nil_index_list(),
          integrate_ode_rk45(simple_SIR_functor__(), y0, t0, t, theta, x_r,
            x_i, pstream__), "assigning variable y");
      }
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= N_t; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= 4; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N_t; ++sym2__) {
            vars__.emplace_back(y[(sym2__ - 1)][(sym1__ - 1)]);}}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double beta;
      beta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      beta = context__.vals_r("beta")[(1 - 1)];
      double beta_free__;
      beta_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      beta_free__ = stan::math::lb_free(beta, 0);
      double gamma;
      gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      gamma = context__.vals_r("gamma")[(1 - 1)];
      double gamma_free__;
      gamma_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      gamma_free__ = stan::math::lb_free(gamma, 0);
      double xi;
      xi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      xi = context__.vals_r("xi")[(1 - 1)];
      double xi_free__;
      xi_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      xi_free__ = stan::math::lb_free(xi, 0);
      double delta;
      delta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      delta = context__.vals_r("delta")[(1 - 1)];
      double delta_free__;
      delta_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      delta_free__ = stan::math::lb_free(delta, 0);
      vars__.emplace_back(beta_free__);
      vars__.emplace_back(gamma_free__);
      vars__.emplace_back(xi_free__);
      vars__.emplace_back(delta_free__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("beta");
    names__.emplace_back("gamma");
    names__.emplace_back("xi");
    names__.emplace_back("delta");
    names__.emplace_back("y");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N_t),
                                             static_cast<size_t>(4)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta");
    param_names__.emplace_back(std::string() + "gamma");
    param_names__.emplace_back(std::string() + "xi");
    param_names__.emplace_back(std::string() + "delta");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N_t; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta");
    param_names__.emplace_back(std::string() + "gamma");
    param_names__.emplace_back(std::string() + "xi");
    param_names__.emplace_back(std::string() + "delta");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N_t; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"xi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" << N_t << ",\"element_type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"xi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" << N_t << ",\"element_type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = ad_level_failing_model_namespace::ad_level_failing_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return ad_level_failing_model_namespace::profiles__;
}

#endif




Warning: in 'ad-level-failing.stan', line 55, column 8 to column 66: integrate_ode_rk45 is deprecated and will be removed in the future. Use ode_rk45 instead. 
The new interface is slightly different, see: 
https://mc-stan.org/users/documentation/case-studies/convert_odes.html
  $ ../../../../../install/default/bin/stanc --O --print-cpp copy_fail.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace copy_fail_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'copy_fail.stan', line 71, column 2 to column 31)",
                                                      " (in 'copy_fail.stan', line 72, column 2 to column 40)",
                                                      " (in 'copy_fail.stan', line 76, column 2 to column 51)",
                                                      " (in 'copy_fail.stan', line 77, column 2 to column 49)",
                                                      " (in 'copy_fail.stan', line 78, column 2 to column 49)",
                                                      " (in 'copy_fail.stan', line 83, column 6 to column 20)",
                                                      " (in 'copy_fail.stan', line 84, column 6 to column 18)",
                                                      " (in 'copy_fail.stan', line 82, column 32 to line 85, column 5)",
                                                      " (in 'copy_fail.stan', line 82, column 4 to line 85, column 5)",
                                                      " (in 'copy_fail.stan', line 87, column 6 to column 32)",
                                                      " (in 'copy_fail.stan', line 88, column 6 to column 23)",
                                                      " (in 'copy_fail.stan', line 86, column 38 to line 89, column 5)",
                                                      " (in 'copy_fail.stan', line 86, column 4 to line 89, column 5)",
                                                      " (in 'copy_fail.stan', line 81, column 20 to line 90, column 3)",
                                                      " (in 'copy_fail.stan', line 81, column 2 to line 90, column 3)",
                                                      " (in 'copy_fail.stan', line 92, column 2 to column 51)",
                                                      " (in 'copy_fail.stan', line 105, column 8 to column 37)",
                                                      " (in 'copy_fail.stan', line 106, column 8 to column 41)",
                                                      " (in 'copy_fail.stan', line 104, column 40 to line 107, column 7)",
                                                      " (in 'copy_fail.stan', line 104, column 6 to line 107, column 7)",
                                                      " (in 'copy_fail.stan', line 108, column 6 to column 37)",
                                                      " (in 'copy_fail.stan', line 103, column 22 to line 109, column 5)",
                                                      " (in 'copy_fail.stan', line 103, column 4 to line 109, column 5)",
                                                      " (in 'copy_fail.stan', line 102, column 20 to line 110, column 3)",
                                                      " (in 'copy_fail.stan', line 102, column 2 to line 110, column 3)",
                                                      " (in 'copy_fail.stan', line 50, column 2 to column 20)",
                                                      " (in 'copy_fail.stan', line 51, column 2 to column 27)",
                                                      " (in 'copy_fail.stan', line 52, column 25 to column 29)",
                                                      " (in 'copy_fail.stan', line 52, column 31 to column 42)",
                                                      " (in 'copy_fail.stan', line 52, column 2 to column 44)",
                                                      " (in 'copy_fail.stan', line 53, column 2 to column 23)",
                                                      " (in 'copy_fail.stan', line 54, column 31 to column 35)",
                                                      " (in 'copy_fail.stan', line 54, column 37 to column 52)",
                                                      " (in 'copy_fail.stan', line 54, column 2 to column 54)",
                                                      " (in 'copy_fail.stan', line 58, column 2 to column 38)",
                                                      " (in 'copy_fail.stan', line 60, column 39 to column 43)",
                                                      " (in 'copy_fail.stan', line 60, column 2 to column 45)",
                                                      " (in 'copy_fail.stan', line 61, column 38 to column 42)",
                                                      " (in 'copy_fail.stan', line 61, column 2 to column 44)",
                                                      " (in 'copy_fail.stan', line 65, column 4 to column 35)",
                                                      " (in 'copy_fail.stan', line 64, column 2 to line 65, column 35)",
                                                      " (in 'copy_fail.stan', line 67, column 4 to column 33)",
                                                      " (in 'copy_fail.stan', line 66, column 2 to line 67, column 33)",
                                                      " (in 'copy_fail.stan', line 72, column 26 to column 33)",
                                                      " (in 'copy_fail.stan', line 76, column 26 to column 30)",
                                                      " (in 'copy_fail.stan', line 76, column 32 to column 45)",
                                                      " (in 'copy_fail.stan', line 77, column 26 to column 30)",
                                                      " (in 'copy_fail.stan', line 77, column 32 to column 45)",
                                                      " (in 'copy_fail.stan', line 78, column 26 to column 30)",
                                                      " (in 'copy_fail.stan', line 78, column 32 to column 43)",
                                                      " (in 'copy_fail.stan', line 8, column 8 to column 17)",
                                                      " (in 'copy_fail.stan', line 7, column 6 to line 8, column 17)",
                                                      " (in 'copy_fail.stan', line 6, column 4 to line 8, column 17)",
                                                      " (in 'copy_fail.stan', line 9, column 4 to column 13)",
                                                      " (in 'copy_fail.stan', line 5, column 31 to line 10, column 3)",
                                                      " (in 'copy_fail.stan', line 15, column 6 to column 32)",
                                                      " (in 'copy_fail.stan', line 19, column 8 to column 17)",
                                                      " (in 'copy_fail.stan', line 18, column 6 to line 19, column 17)",
                                                      " (in 'copy_fail.stan', line 13, column 37 to line 20, column 5)",
                                                      " (in 'copy_fail.stan', line 13, column 4 to line 20, column 5)",
                                                      " (in 'copy_fail.stan', line 21, column 4 to column 13)",
                                                      " (in 'copy_fail.stan', line 12, column 30 to line 22, column 3)",
                                                      " (in 'copy_fail.stan', line 26, column 11 to column 15)",
                                                      " (in 'copy_fail.stan', line 26, column 17 to column 28)",
                                                      " (in 'copy_fail.stan', line 26, column 4 to column 34)",
                                                      " (in 'copy_fail.stan', line 29, column 6 to column 32)",
                                                      " (in 'copy_fail.stan', line 32, column 8 to column 37)",
                                                      " (in 'copy_fail.stan', line 33, column 8 to column 32)",
                                                      " (in 'copy_fail.stan', line 41, column 8 to line 42, column 83)",
                                                      " (in 'copy_fail.stan', line 30, column 37 to line 43, column 7)",
                                                      " (in 'copy_fail.stan', line 30, column 6 to line 43, column 7)",
                                                      " (in 'copy_fail.stan', line 28, column 22 to line 44, column 5)",
                                                      " (in 'copy_fail.stan', line 28, column 4 to line 44, column 5)",
                                                      " (in 'copy_fail.stan', line 45, column 4 to column 15)",
                                                      " (in 'copy_fail.stan', line 25, column 47 to line 46, column 3)"};


int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 53;
    for (int k = 1; k <= size(y_i); ++k) {
      current_statement__ = 52;
      if (y_i[(k - 1)]) {
        current_statement__ = 51;
        return k;
      } }
    current_statement__ = 54;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 60;
    for (int k_rev = 0; k_rev <= (size(y_i) - 1); ++k_rev) {
      int k;
      k = std::numeric_limits<int>::min();
      
      current_statement__ = 56;
      k = (size(y_i) - k_rev);
      current_statement__ = 58;
      if (y_i[(k - 1)]) {
        current_statement__ = 57;
        return k;
      } }
    current_statement__ = 61;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 63;
    validate_non_negative_index("chi", "nind", nind);
    current_statement__ = 64;
    validate_non_negative_index("chi", "n_occasions", n_occasions);
    Eigen::Matrix<local_scalar_t__, -1, -1> chi;
    chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
    stan::math::fill(chi, DUMMY_VAR__);
    
    current_statement__ = 73;
    for (int i = 1; i <= nind; ++i) {
      current_statement__ = 66;
      assign(chi,
        cons_list(index_uni(i),
          cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
        "assigning variable chi");
      current_statement__ = 71;
      for (int t = 1; t <= (n_occasions - 1); ++t) {
        int t_curr;
        t_curr = std::numeric_limits<int>::min();
        
        current_statement__ = 67;
        t_curr = (n_occasions - t);
        int t_next;
        t_next = std::numeric_limits<int>::min();
        
        current_statement__ = 68;
        t_next = (t_curr + 1);
        current_statement__ = 69;
        assign(chi,
          cons_list(index_uni(i),
            cons_list(index_uni(t_curr), nil_index_list())),
          ((1 -
             rvalue(phi,
               cons_list(index_uni(i),
                 cons_list(index_uni(t_curr), nil_index_list())), "phi")) +
            ((rvalue(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t_curr), nil_index_list())), "phi") *
               (1 -
                 rvalue(p,
                   cons_list(index_uni(i),
                     cons_list(index_uni((t_next - 1)), nil_index_list())),
                   "p"))) *
              rvalue(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t_next), nil_index_list())), "chi"))),
          "assigning variable chi");}}
    current_statement__ = 74;
    return chi;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct prob_uncaptured_functor__ {
template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
operator()(const int& nind, const int& n_occasions, const T2__& p,
           const T3__& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}
};

class copy_fail_model final : public model_base_crtp<copy_fail_model> {

 private:
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int max_age;
  std::vector<std::vector<int>> x;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last;
 
 public:
  ~copy_fail_model() { }
  
  inline std::string model_name() const final { return "copy_fail_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  copy_fail_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "copy_fail_model_namespace::copy_fail_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 26;
      context__.validate_dims("data initialization","nind","int",
          context__.to_vec());
      nind = std::numeric_limits<int>::min();
      
      current_statement__ = 26;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 26;
      current_statement__ = 26;
      check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 27;
      context__.validate_dims("data initialization","n_occasions","int",
          context__.to_vec());
      n_occasions = std::numeric_limits<int>::min();
      
      current_statement__ = 27;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 27;
      current_statement__ = 27;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 2);
      current_statement__ = 28;
      validate_non_negative_index("y", "nind", nind);
      current_statement__ = 29;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 30;
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(nind, n_occasions));
      y = std::vector<std::vector<int>>(nind, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 30;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 30;
        pos__ = 1;
        current_statement__ = 30;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 30;
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            current_statement__ = 30;
            assign(y,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y_flat__[(pos__ - 1)], "assigning variable y");
            current_statement__ = 30;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 30;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 30;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 30;
          current_statement__ = 30;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 30;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 30;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 30;
          current_statement__ = 30;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 31;
      context__.validate_dims("data initialization","max_age","int",
          context__.to_vec());
      max_age = std::numeric_limits<int>::min();
      
      current_statement__ = 31;
      max_age = context__.vals_i("max_age")[(1 - 1)];
      current_statement__ = 31;
      current_statement__ = 31;
      check_greater_or_equal(function__, "max_age", max_age, 1);
      current_statement__ = 32;
      validate_non_negative_index("x", "nind", nind);
      current_statement__ = 33;
      validate_non_negative_index("x", "n_occasions - 1", (n_occasions - 1));
      current_statement__ = 34;
      context__.validate_dims("data initialization","x","int",
          context__.to_vec(nind, (n_occasions - 1)));
      x = std::vector<std::vector<int>>(nind, std::vector<int>((n_occasions -
                                                                 1), std::numeric_limits<int>::min()));
      
      {
        std::vector<int> x_flat__;
        current_statement__ = 34;
        assign(x_flat__, nil_index_list(), context__.vals_i("x"),
          "assigning variable x_flat__");
        current_statement__ = 34;
        pos__ = 1;
        current_statement__ = 34;
        for (int sym1__ = 1; sym1__ <= (n_occasions - 1); ++sym1__) {
          current_statement__ = 34;
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            current_statement__ = 34;
            assign(x,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_flat__[(pos__ - 1)], "assigning variable x");
            current_statement__ = 34;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 34;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 34;
        for (int sym2__ = 1; sym2__ <= (n_occasions - 1); ++sym2__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                 x[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 34;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 34;
        for (int sym2__ = 1; sym2__ <= (n_occasions - 1); ++sym2__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_less_or_equal(function__, "x[sym1__, sym2__]",
                              x[(sym1__ - 1)][(sym2__ - 1)], max_age);}}
      current_statement__ = 35;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      
      current_statement__ = 35;
      n_occ_minus_1 = (n_occasions - 1);
      current_statement__ = 36;
      validate_non_negative_index("first", "nind", nind);
      current_statement__ = 37;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 38;
      validate_non_negative_index("last", "nind", nind);
      current_statement__ = 39;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 41;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 40;
        assign(first, cons_list(index_uni(i), nil_index_list()),
          first_capture(y[(i - 1)], pstream__), "assigning variable first");}
      current_statement__ = 43;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 42;
        assign(last, cons_list(index_uni(i), nil_index_list()),
          last_capture(y[(i - 1)], pstream__), "assigning variable last");}
      current_statement__ = 37;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 37;
        current_statement__ = 37;
        check_greater_or_equal(function__, "first[sym1__]",
                               first[(sym1__ - 1)], 0);}
      current_statement__ = 37;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 37;
        current_statement__ = 37;
        check_less_or_equal(function__, "first[sym1__]", first[(sym1__ - 1)],
                            n_occasions);}
      current_statement__ = 39;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 39;
        current_statement__ = 39;
        check_greater_or_equal(function__, "last[sym1__]",
                               last[(sym1__ - 1)], 0);}
      current_statement__ = 39;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 39;
        current_statement__ = 39;
        check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                            n_occasions);}
      current_statement__ = 44;
      validate_non_negative_index("beta", "max_age", max_age);
      current_statement__ = 45;
      validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 46;
      validate_non_negative_index("phi", "n_occ_minus_1", n_occ_minus_1);
      current_statement__ = 47;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 48;
      validate_non_negative_index("p", "n_occ_minus_1", n_occ_minus_1);
      current_statement__ = 49;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 50;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += max_age;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "copy_fail_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ mean_p;
      mean_p = DUMMY_VAR__;
      
      current_statement__ = 1;
      mean_p = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1, lp__);
      } else {
        current_statement__ = 1;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(max_age);
      stan::math::fill(beta, DUMMY_VAR__);
      
      current_statement__ = 2;
      beta = in__.vector(max_age);
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
        current_statement__ = 2;
        if (jacobian__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(beta[(sym1__ - 1)], 0, 1, lp__),
            "assigning variable beta");
        } else {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(beta[(sym1__ - 1)], 0, 1),
            "assigning variable beta");
        }}
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(p, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      current_statement__ = 15;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 9;
        for (int t = 1; t <= (first[(i - 1)] - 1); ++t) {
          current_statement__ = 6;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable p");}
        current_statement__ = 13;
        for (int t = first[(i - 1)]; t <= n_occ_minus_1; ++t) {
          current_statement__ = 10;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())),
            beta[(x[(i - 1)][(t - 1)] - 1)], "assigning variable phi");
          current_statement__ = 11;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), mean_p,
            "assigning variable p");}}
      current_statement__ = 16;
      assign(chi, nil_index_list(),
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 3;
          current_statement__ = 3;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "phi"), 0);}}
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 3;
          current_statement__ = 3;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "phi"), 1);}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 4;
          current_statement__ = 4;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "p"), 0);}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 4;
          current_statement__ = 4;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "p"), 1);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(chi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "chi"), 0);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(chi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "chi"), 1);}}
      {
        current_statement__ = 25;
        for (int i = 1; i <= nind; ++i) {
          current_statement__ = 23;
          if (logical_gt(first[(i - 1)], 0)) {
            current_statement__ = 20;
            for (int t = (first[(i - 1)] + 1); t <= last[(i - 1)]; ++t) {
              current_statement__ = 17;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni((t - 1)), nil_index_list())),
                    "phi")));
              current_statement__ = 18;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(y[(i - 1)][(t - 1)],
                  rvalue(p,
                    cons_list(index_uni(i),
                      cons_list(index_uni((t - 1)), nil_index_list())), "p")));
            }
            current_statement__ = 21;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(last[(i - 1)]), nil_index_list())),
                  "chi")));
          } }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "copy_fail_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double mean_p;
      mean_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_p = in__.scalar();
      current_statement__ = 1;
      mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(max_age);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      beta = in__.vector(max_age);
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
        current_statement__ = 2;
        assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(beta[(sym1__ - 1)], 0, 1),
          "assigning variable beta");}
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(p, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      vars__.emplace_back(mean_p);
      for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
        vars__.emplace_back(beta[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 15;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 9;
        for (int t = 1; t <= (first[(i - 1)] - 1); ++t) {
          current_statement__ = 6;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable p");}
        current_statement__ = 13;
        for (int t = first[(i - 1)]; t <= n_occ_minus_1; ++t) {
          current_statement__ = 10;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())),
            beta[(x[(i - 1)][(t - 1)] - 1)], "assigning variable phi");
          current_statement__ = 11;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), mean_p,
            "assigning variable p");}}
      current_statement__ = 16;
      assign(chi, nil_index_list(),
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 3;
          current_statement__ = 3;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "phi"), 0);}}
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 3;
          current_statement__ = 3;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "phi"), 1);}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 4;
          current_statement__ = 4;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "p"), 0);}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 4;
          current_statement__ = 4;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "p"), 1);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(chi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "chi"), 0);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(chi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "chi"), 1);}}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            vars__.emplace_back(
              rvalue(phi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "phi"));}}
        for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            vars__.emplace_back(
              rvalue(p,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "p"));}}
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            vars__.emplace_back(
              rvalue(chi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "chi"));}}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double mean_p;
      mean_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      double mean_p_free__;
      mean_p_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_p_free__ = stan::math::lub_free(mean_p, 0, 1);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(max_age);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 2;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            beta_flat__[(pos__ - 1)], "assigning variable beta");
          current_statement__ = 2;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> beta_free__;
      beta_free__ = Eigen::Matrix<double, -1, 1>(max_age);
      stan::math::fill(beta_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
        current_statement__ = 2;
        assign(beta_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(beta[(sym1__ - 1)], 0, 1),
          "assigning variable beta_free__");}
      vars__.emplace_back(mean_p_free__);
      for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
        vars__.emplace_back(beta_free__[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("mean_p");
    names__.emplace_back("beta");
    names__.emplace_back("phi");
    names__.emplace_back("p");
    names__.emplace_back("chi");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(max_age)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind),
                                             static_cast<size_t>(n_occ_minus_1)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind),
                                             static_cast<size_t>(n_occ_minus_1)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind),
                                             static_cast<size_t>(n_occasions)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << max_age << "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << max_age << "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = copy_fail_model_namespace::copy_fail_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return copy_fail_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp dce-fail.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace dce_fail_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'dce-fail.stan', line 18, column 2 to column 22)",
                                                      " (in 'dce-fail.stan', line 19, column 2 to column 26)",
                                                      " (in 'dce-fail.stan', line 20, column 2 to column 26)",
                                                      " (in 'dce-fail.stan', line 21, column 2 to column 28)",
                                                      " (in 'dce-fail.stan', line 22, column 2 to column 29)",
                                                      " (in 'dce-fail.stan', line 23, column 2 to column 30)",
                                                      " (in 'dce-fail.stan', line 25, column 2 to column 11)",
                                                      " (in 'dce-fail.stan', line 26, column 2 to column 16)",
                                                      " (in 'dce-fail.stan', line 27, column 2 to column 15)",
                                                      " (in 'dce-fail.stan', line 28, column 2 to column 22)",
                                                      " (in 'dce-fail.stan', line 30, column 2 to column 16)",
                                                      " (in 'dce-fail.stan', line 32, column 2 to column 22)",
                                                      " (in 'dce-fail.stan', line 33, column 2 to column 22)",
                                                      " (in 'dce-fail.stan', line 34, column 2 to column 28)",
                                                      " (in 'dce-fail.stan', line 35, column 2 to column 32)",
                                                      " (in 'dce-fail.stan', line 37, column 2 to column 24)",
                                                      " (in 'dce-fail.stan', line 40, column 9 to column 10)",
                                                      " (in 'dce-fail.stan', line 40, column 2 to column 14)",
                                                      " (in 'dce-fail.stan', line 41, column 9 to column 16)",
                                                      " (in 'dce-fail.stan', line 41, column 2 to column 30)",
                                                      " (in 'dce-fail.stan', line 43, column 2 to column 23)",
                                                      " (in 'dce-fail.stan', line 44, column 2 to column 28)",
                                                      " (in 'dce-fail.stan', line 45, column 2 to column 27)",
                                                      " (in 'dce-fail.stan', line 46, column 2 to column 34)",
                                                      " (in 'dce-fail.stan', line 48, column 2 to column 31)",
                                                      " (in 'dce-fail.stan', line 49, column 2 to column 31)",
                                                      " (in 'dce-fail.stan', line 50, column 2 to column 37)",
                                                      " (in 'dce-fail.stan', line 54, column 6 to column 48)",
                                                      " (in 'dce-fail.stan', line 53, column 4 to line 54, column 48)",
                                                      " (in 'dce-fail.stan', line 52, column 21 to line 55, column 3)",
                                                      " (in 'dce-fail.stan', line 52, column 2 to line 55, column 3)",
                                                      " (in 'dce-fail.stan', line 57, column 2 to column 28)",
                                                      " (in 'dce-fail.stan', line 60, column 4 to column 64)",
                                                      " (in 'dce-fail.stan', line 59, column 2 to line 60, column 64)",
                                                      " (in 'dce-fail.stan', line 62, column 2 to column 43)",
                                                      " (in 'dce-fail.stan', line 65, column 4 to line 68, column 25)",
                                                      " (in 'dce-fail.stan', line 64, column 2 to line 68, column 25)",
                                                      " (in 'dce-fail.stan', line 70, column 2 to column 19)",
                                                      " (in 'dce-fail.stan', line 2, column 2 to column 17)",
                                                      " (in 'dce-fail.stan', line 3, column 2 to column 21)",
                                                      " (in 'dce-fail.stan', line 4, column 2 to column 21)",
                                                      " (in 'dce-fail.stan', line 5, column 2 to column 24)",
                                                      " (in 'dce-fail.stan', line 6, column 2 to column 23)",
                                                      " (in 'dce-fail.stan', line 8, column 31 to column 32)",
                                                      " (in 'dce-fail.stan', line 8, column 2 to column 34)",
                                                      " (in 'dce-fail.stan', line 9, column 30 to column 31)",
                                                      " (in 'dce-fail.stan', line 9, column 2 to column 33)",
                                                      " (in 'dce-fail.stan', line 10, column 32 to column 33)",
                                                      " (in 'dce-fail.stan', line 10, column 2 to column 35)",
                                                      " (in 'dce-fail.stan', line 11, column 32 to column 33)",
                                                      " (in 'dce-fail.stan', line 11, column 2 to column 35)",
                                                      " (in 'dce-fail.stan', line 12, column 37 to column 44)",
                                                      " (in 'dce-fail.stan', line 12, column 2 to column 46)",
                                                      " (in 'dce-fail.stan', line 13, column 36 to column 37)",
                                                      " (in 'dce-fail.stan', line 13, column 2 to column 39)",
                                                      " (in 'dce-fail.stan', line 14, column 26 to column 27)",
                                                      " (in 'dce-fail.stan', line 14, column 2 to column 29)",
                                                      " (in 'dce-fail.stan', line 15, column 9 to column 16)",
                                                      " (in 'dce-fail.stan', line 15, column 2 to column 25)",
                                                      " (in 'dce-fail.stan', line 32, column 9 to column 14)",
                                                      " (in 'dce-fail.stan', line 33, column 9 to column 14)",
                                                      " (in 'dce-fail.stan', line 34, column 9 to column 17)",
                                                      " (in 'dce-fail.stan', line 35, column 9 to column 14)",
                                                      " (in 'dce-fail.stan', line 35, column 15 to column 20)",
                                                      " (in 'dce-fail.stan', line 37, column 9 to column 16)"};



class dce_fail_model final : public model_base_crtp<dce_fail_model> {

 private:
  int N;
  int n_age;
  int n_edu;
  int n_region;
  int n_state;
  std::vector<int> female;
  std::vector<int> black;
  std::vector<int> age;
  std::vector<int> edu;
  std::vector<int> region;
  std::vector<int> state;
  std::vector<int> y;
  Eigen::Matrix<double, -1, 1> v_prev;
 
 public:
  ~dce_fail_model() { }
  
  inline std::string model_name() const final { return "dce_fail_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  dce_fail_model(stan::io::var_context& context__,
                 unsigned int random_seed__ = 0,
                 std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "dce_fail_model_namespace::dce_fail_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 39;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 39;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 39;
      current_statement__ = 39;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 40;
      context__.validate_dims("data initialization","n_age","int",
          context__.to_vec());
      n_age = std::numeric_limits<int>::min();
      
      current_statement__ = 40;
      n_age = context__.vals_i("n_age")[(1 - 1)];
      current_statement__ = 40;
      current_statement__ = 40;
      check_greater_or_equal(function__, "n_age", n_age, 0);
      current_statement__ = 41;
      context__.validate_dims("data initialization","n_edu","int",
          context__.to_vec());
      n_edu = std::numeric_limits<int>::min();
      
      current_statement__ = 41;
      n_edu = context__.vals_i("n_edu")[(1 - 1)];
      current_statement__ = 41;
      current_statement__ = 41;
      check_greater_or_equal(function__, "n_edu", n_edu, 0);
      current_statement__ = 42;
      context__.validate_dims("data initialization","n_region","int",
          context__.to_vec());
      n_region = std::numeric_limits<int>::min();
      
      current_statement__ = 42;
      n_region = context__.vals_i("n_region")[(1 - 1)];
      current_statement__ = 42;
      current_statement__ = 42;
      check_greater_or_equal(function__, "n_region", n_region, 0);
      current_statement__ = 43;
      context__.validate_dims("data initialization","n_state","int",
          context__.to_vec());
      n_state = std::numeric_limits<int>::min();
      
      current_statement__ = 43;
      n_state = context__.vals_i("n_state")[(1 - 1)];
      current_statement__ = 43;
      current_statement__ = 43;
      check_greater_or_equal(function__, "n_state", n_state, 0);
      current_statement__ = 44;
      validate_non_negative_index("female", "N", N);
      current_statement__ = 45;
      context__.validate_dims("data initialization","female","int",
          context__.to_vec(N));
      female = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 45;
      assign(female, nil_index_list(), context__.vals_i("female"),
        "assigning variable female");
      current_statement__ = 45;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 45;
        current_statement__ = 45;
        check_greater_or_equal(function__, "female[sym1__]",
                               female[(sym1__ - 1)], 0);}
      current_statement__ = 45;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 45;
        current_statement__ = 45;
        check_less_or_equal(function__, "female[sym1__]",
                            female[(sym1__ - 1)], 1);}
      current_statement__ = 46;
      validate_non_negative_index("black", "N", N);
      current_statement__ = 47;
      context__.validate_dims("data initialization","black","int",
          context__.to_vec(N));
      black = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 47;
      assign(black, nil_index_list(), context__.vals_i("black"),
        "assigning variable black");
      current_statement__ = 47;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 47;
        current_statement__ = 47;
        check_greater_or_equal(function__, "black[sym1__]",
                               black[(sym1__ - 1)], 0);}
      current_statement__ = 47;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 47;
        current_statement__ = 47;
        check_less_or_equal(function__, "black[sym1__]", black[(sym1__ - 1)],
                            1);}
      current_statement__ = 48;
      validate_non_negative_index("age", "N", N);
      current_statement__ = 49;
      context__.validate_dims("data initialization","age","int",
          context__.to_vec(N));
      age = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 49;
      assign(age, nil_index_list(), context__.vals_i("age"),
        "assigning variable age");
      current_statement__ = 49;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 49;
        current_statement__ = 49;
        check_greater_or_equal(function__, "age[sym1__]", age[(sym1__ - 1)],
                               0);}
      current_statement__ = 49;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 49;
        current_statement__ = 49;
        check_less_or_equal(function__, "age[sym1__]", age[(sym1__ - 1)],
                            n_age);}
      current_statement__ = 50;
      validate_non_negative_index("edu", "N", N);
      current_statement__ = 51;
      context__.validate_dims("data initialization","edu","int",
          context__.to_vec(N));
      edu = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 51;
      assign(edu, nil_index_list(), context__.vals_i("edu"),
        "assigning variable edu");
      current_statement__ = 51;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 51;
        current_statement__ = 51;
        check_greater_or_equal(function__, "edu[sym1__]", edu[(sym1__ - 1)],
                               0);}
      current_statement__ = 51;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 51;
        current_statement__ = 51;
        check_less_or_equal(function__, "edu[sym1__]", edu[(sym1__ - 1)],
                            n_edu);}
      current_statement__ = 52;
      validate_non_negative_index("region", "n_state", n_state);
      current_statement__ = 53;
      context__.validate_dims("data initialization","region","int",
          context__.to_vec(n_state));
      region = std::vector<int>(n_state, std::numeric_limits<int>::min());
      
      current_statement__ = 53;
      assign(region, nil_index_list(), context__.vals_i("region"),
        "assigning variable region");
      current_statement__ = 53;
      for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
        current_statement__ = 53;
        current_statement__ = 53;
        check_greater_or_equal(function__, "region[sym1__]",
                               region[(sym1__ - 1)], 0);}
      current_statement__ = 53;
      for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
        current_statement__ = 53;
        current_statement__ = 53;
        check_less_or_equal(function__, "region[sym1__]",
                            region[(sym1__ - 1)], n_state);}
      current_statement__ = 54;
      validate_non_negative_index("state", "N", N);
      current_statement__ = 55;
      context__.validate_dims("data initialization","state","int",
          context__.to_vec(N));
      state = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 55;
      assign(state, nil_index_list(), context__.vals_i("state"),
        "assigning variable state");
      current_statement__ = 55;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 55;
        current_statement__ = 55;
        check_greater_or_equal(function__, "state[sym1__]",
                               state[(sym1__ - 1)], 0);}
      current_statement__ = 55;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 55;
        current_statement__ = 55;
        check_less_or_equal(function__, "state[sym1__]", state[(sym1__ - 1)],
                            n_state);}
      current_statement__ = 56;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 57;
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(N));
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 57;
      assign(y, nil_index_list(), context__.vals_i("y"),
        "assigning variable y");
      current_statement__ = 57;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 57;
        current_statement__ = 57;
        check_greater_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 0);}
      current_statement__ = 57;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 57;
        current_statement__ = 57;
        check_less_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 1);}
      current_statement__ = 58;
      validate_non_negative_index("v_prev", "n_state", n_state);
      current_statement__ = 59;
      context__.validate_dims("data initialization","v_prev","double",
          context__.to_vec(n_state));
      v_prev = Eigen::Matrix<double, -1, 1>(n_state);
      stan::math::fill(v_prev, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> v_prev_flat__;
        current_statement__ = 59;
        assign(v_prev_flat__, nil_index_list(), context__.vals_r("v_prev"),
          "assigning variable v_prev_flat__");
        current_statement__ = 59;
        pos__ = 1;
        current_statement__ = 59;
        for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
          current_statement__ = 59;
          assign(v_prev, cons_list(index_uni(sym1__), nil_index_list()),
            v_prev_flat__[(pos__ - 1)], "assigning variable v_prev");
          current_statement__ = 59;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 60;
      validate_non_negative_index("b_age", "n_age", n_age);
      current_statement__ = 61;
      validate_non_negative_index("b_edu", "n_edu", n_edu);
      current_statement__ = 62;
      validate_non_negative_index("b_region", "n_region", n_region);
      current_statement__ = 63;
      validate_non_negative_index("b_age_edu", "n_age", n_age);
      current_statement__ = 64;
      validate_non_negative_index("b_age_edu", "n_edu", n_edu);
      current_statement__ = 65;
      validate_non_negative_index("b_hat", "n_state", n_state);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += n_age;
      num_params_r__ += n_edu;
      num_params_r__ += n_region;
      num_params_r__ += n_age * n_edu;
      num_params_r__ += n_state;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "dce_fail_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ sigma;
      sigma = DUMMY_VAR__;
      
      current_statement__ = 1;
      sigma = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        sigma = stan::math::lb_constrain(sigma, 0, lp__);
      } else {
        current_statement__ = 1;
        sigma = stan::math::lb_constrain(sigma, 0);
      }
      local_scalar_t__ sigma_age;
      sigma_age = DUMMY_VAR__;
      
      current_statement__ = 2;
      sigma_age = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        sigma_age = stan::math::lb_constrain(sigma_age, 0, lp__);
      } else {
        current_statement__ = 2;
        sigma_age = stan::math::lb_constrain(sigma_age, 0);
      }
      local_scalar_t__ sigma_edu;
      sigma_edu = DUMMY_VAR__;
      
      current_statement__ = 3;
      sigma_edu = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        sigma_edu = stan::math::lb_constrain(sigma_edu, 0, lp__);
      } else {
        current_statement__ = 3;
        sigma_edu = stan::math::lb_constrain(sigma_edu, 0);
      }
      local_scalar_t__ sigma_state;
      sigma_state = DUMMY_VAR__;
      
      current_statement__ = 4;
      sigma_state = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        sigma_state = stan::math::lb_constrain(sigma_state, 0, lp__);
      } else {
        current_statement__ = 4;
        sigma_state = stan::math::lb_constrain(sigma_state, 0);
      }
      local_scalar_t__ sigma_region;
      sigma_region = DUMMY_VAR__;
      
      current_statement__ = 5;
      sigma_region = in__.scalar();
      current_statement__ = 5;
      if (jacobian__) {
        current_statement__ = 5;
        sigma_region = stan::math::lb_constrain(sigma_region, 0, lp__);
      } else {
        current_statement__ = 5;
        sigma_region = stan::math::lb_constrain(sigma_region, 0);
      }
      local_scalar_t__ sigma_age_edu;
      sigma_age_edu = DUMMY_VAR__;
      
      current_statement__ = 6;
      sigma_age_edu = in__.scalar();
      current_statement__ = 6;
      if (jacobian__) {
        current_statement__ = 6;
        sigma_age_edu = stan::math::lb_constrain(sigma_age_edu, 0, lp__);
      } else {
        current_statement__ = 6;
        sigma_age_edu = stan::math::lb_constrain(sigma_age_edu, 0);
      }
      local_scalar_t__ b_0;
      b_0 = DUMMY_VAR__;
      
      current_statement__ = 7;
      b_0 = in__.scalar();
      local_scalar_t__ b_female;
      b_female = DUMMY_VAR__;
      
      current_statement__ = 8;
      b_female = in__.scalar();
      local_scalar_t__ b_black;
      b_black = DUMMY_VAR__;
      
      current_statement__ = 9;
      b_black = in__.scalar();
      local_scalar_t__ b_female_black;
      b_female_black = DUMMY_VAR__;
      
      current_statement__ = 10;
      b_female_black = in__.scalar();
      local_scalar_t__ b_v_prev;
      b_v_prev = DUMMY_VAR__;
      
      current_statement__ = 11;
      b_v_prev = in__.scalar();
      Eigen::Matrix<local_scalar_t__, -1, 1> b_age;
      b_age = Eigen::Matrix<local_scalar_t__, -1, 1>(n_age);
      stan::math::fill(b_age, DUMMY_VAR__);
      
      current_statement__ = 12;
      b_age = in__.vector(n_age);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_edu;
      b_edu = Eigen::Matrix<local_scalar_t__, -1, 1>(n_edu);
      stan::math::fill(b_edu, DUMMY_VAR__);
      
      current_statement__ = 13;
      b_edu = in__.vector(n_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_region;
      b_region = Eigen::Matrix<local_scalar_t__, -1, 1>(n_region);
      stan::math::fill(b_region, DUMMY_VAR__);
      
      current_statement__ = 14;
      b_region = in__.vector(n_region);
      Eigen::Matrix<local_scalar_t__, -1, -1> b_age_edu;
      b_age_edu = Eigen::Matrix<local_scalar_t__, -1, -1>(n_age, n_edu);
      stan::math::fill(b_age_edu, DUMMY_VAR__);
      
      current_statement__ = 15;
      b_age_edu = in__.matrix(n_age, n_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_hat;
      b_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(n_state);
      stan::math::fill(b_hat, DUMMY_VAR__);
      
      current_statement__ = 16;
      b_hat = in__.vector(n_state);
      {
        current_statement__ = 17;
        validate_non_negative_index("p", "N", N);
        Eigen::Matrix<local_scalar_t__, -1, 1> p;
        p = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
        stan::math::fill(p, DUMMY_VAR__);
        
        current_statement__ = 19;
        validate_non_negative_index("b_state_hat", "n_state", n_state);
        Eigen::Matrix<local_scalar_t__, -1, 1> b_state_hat;
        b_state_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(n_state);
        stan::math::fill(b_state_hat, DUMMY_VAR__);
        
        current_statement__ = 21;
        lp_accum__.add(normal_lpdf<propto__>(b_0, 0, 100));
        current_statement__ = 22;
        lp_accum__.add(normal_lpdf<propto__>(b_female, 0, 100));
        current_statement__ = 23;
        lp_accum__.add(normal_lpdf<propto__>(b_black, 0, 100));
        current_statement__ = 24;
        lp_accum__.add(normal_lpdf<propto__>(b_female_black, 0, 100));
        current_statement__ = 25;
        lp_accum__.add(normal_lpdf<propto__>(b_age, 0, sigma_age));
        current_statement__ = 26;
        lp_accum__.add(normal_lpdf<propto__>(b_edu, 0, sigma_edu));
        current_statement__ = 27;
        lp_accum__.add(normal_lpdf<propto__>(b_region, 0, sigma_region));
        current_statement__ = 31;
        for (int j = 1; j <= n_age; ++j) {
          current_statement__ = 29;
          for (int i = 1; i <= n_edu; ++i) {
            current_statement__ = 28;
            lp_accum__.add(
              normal_lpdf<propto__>(
                rvalue(b_age_edu,
                  cons_list(index_uni(j),
                    cons_list(index_uni(i), nil_index_list())), "b_age_edu"),
                0, sigma_age_edu));}}
        current_statement__ = 32;
        lp_accum__.add(normal_lpdf<propto__>(b_v_prev, 0, 100));
        current_statement__ = 34;
        for (int j = 1; j <= n_state; ++j) {
          current_statement__ = 33;
          assign(b_state_hat, cons_list(index_uni(j), nil_index_list()),
            (b_region[(region[(j - 1)] - 1)] + (b_v_prev * v_prev[(j - 1)])),
            "assigning variable b_state_hat");}
        current_statement__ = 35;
        lp_accum__.add(normal_lpdf<propto__>(b_hat, b_state_hat, sigma_state));
        current_statement__ = 37;
        for (int i = 1; i <= N; ++i) {
          current_statement__ = 36;
          assign(p, cons_list(index_uni(i), nil_index_list()),
            stan::math::fmax(0,
              stan::math::fmin(1,
                inv_logit(
                  (((((((b_0 + (b_female * female[(i - 1)])) +
                         (b_black * black[(i - 1)])) +
                        ((b_female_black * female[(i - 1)]) * black[(i - 1)]))
                       + b_age[(age[(i - 1)] - 1)]) +
                      b_edu[(edu[(i - 1)] - 1)]) +
                     rvalue(b_age_edu,
                       cons_list(index_uni(age[(i - 1)]),
                         cons_list(index_uni(edu[(i - 1)]), nil_index_list())),
                       "b_age_edu")) + b_hat[(state[(i - 1)] - 1)])))),
            "assigning variable p");}
        current_statement__ = 38;
        lp_accum__.add(bernoulli_lpmf<propto__>(y, p));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "dce_fail_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      sigma = in__.scalar();
      current_statement__ = 1;
      sigma = stan::math::lb_constrain(sigma, 0);
      double sigma_age;
      sigma_age = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      sigma_age = in__.scalar();
      current_statement__ = 2;
      sigma_age = stan::math::lb_constrain(sigma_age, 0);
      double sigma_edu;
      sigma_edu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      sigma_edu = in__.scalar();
      current_statement__ = 3;
      sigma_edu = stan::math::lb_constrain(sigma_edu, 0);
      double sigma_state;
      sigma_state = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      sigma_state = in__.scalar();
      current_statement__ = 4;
      sigma_state = stan::math::lb_constrain(sigma_state, 0);
      double sigma_region;
      sigma_region = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      sigma_region = in__.scalar();
      current_statement__ = 5;
      sigma_region = stan::math::lb_constrain(sigma_region, 0);
      double sigma_age_edu;
      sigma_age_edu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      sigma_age_edu = in__.scalar();
      current_statement__ = 6;
      sigma_age_edu = stan::math::lb_constrain(sigma_age_edu, 0);
      double b_0;
      b_0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      b_0 = in__.scalar();
      double b_female;
      b_female = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 8;
      b_female = in__.scalar();
      double b_black;
      b_black = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 9;
      b_black = in__.scalar();
      double b_female_black;
      b_female_black = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 10;
      b_female_black = in__.scalar();
      double b_v_prev;
      b_v_prev = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      b_v_prev = in__.scalar();
      Eigen::Matrix<double, -1, 1> b_age;
      b_age = Eigen::Matrix<double, -1, 1>(n_age);
      stan::math::fill(b_age, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 12;
      b_age = in__.vector(n_age);
      Eigen::Matrix<double, -1, 1> b_edu;
      b_edu = Eigen::Matrix<double, -1, 1>(n_edu);
      stan::math::fill(b_edu, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 13;
      b_edu = in__.vector(n_edu);
      Eigen::Matrix<double, -1, 1> b_region;
      b_region = Eigen::Matrix<double, -1, 1>(n_region);
      stan::math::fill(b_region, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 14;
      b_region = in__.vector(n_region);
      Eigen::Matrix<double, -1, -1> b_age_edu;
      b_age_edu = Eigen::Matrix<double, -1, -1>(n_age, n_edu);
      stan::math::fill(b_age_edu, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 15;
      b_age_edu = in__.matrix(n_age, n_edu);
      Eigen::Matrix<double, -1, 1> b_hat;
      b_hat = Eigen::Matrix<double, -1, 1>(n_state);
      stan::math::fill(b_hat, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 16;
      b_hat = in__.vector(n_state);
      vars__.emplace_back(sigma);
      vars__.emplace_back(sigma_age);
      vars__.emplace_back(sigma_edu);
      vars__.emplace_back(sigma_state);
      vars__.emplace_back(sigma_region);
      vars__.emplace_back(sigma_age_edu);
      vars__.emplace_back(b_0);
      vars__.emplace_back(b_female);
      vars__.emplace_back(b_black);
      vars__.emplace_back(b_female_black);
      vars__.emplace_back(b_v_prev);
      for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
        vars__.emplace_back(b_age[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
        vars__.emplace_back(b_edu[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_region; ++sym1__) {
        vars__.emplace_back(b_region[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_age; ++sym2__) {
          vars__.emplace_back(
            rvalue(b_age_edu,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "b_age_edu"));
        }}
      for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
        vars__.emplace_back(b_hat[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      double sigma_free__;
      sigma_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      sigma_free__ = stan::math::lb_free(sigma, 0);
      double sigma_age;
      sigma_age = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      sigma_age = context__.vals_r("sigma_age")[(1 - 1)];
      double sigma_age_free__;
      sigma_age_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      sigma_age_free__ = stan::math::lb_free(sigma_age, 0);
      double sigma_edu;
      sigma_edu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      sigma_edu = context__.vals_r("sigma_edu")[(1 - 1)];
      double sigma_edu_free__;
      sigma_edu_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      sigma_edu_free__ = stan::math::lb_free(sigma_edu, 0);
      double sigma_state;
      sigma_state = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      sigma_state = context__.vals_r("sigma_state")[(1 - 1)];
      double sigma_state_free__;
      sigma_state_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      sigma_state_free__ = stan::math::lb_free(sigma_state, 0);
      double sigma_region;
      sigma_region = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      sigma_region = context__.vals_r("sigma_region")[(1 - 1)];
      double sigma_region_free__;
      sigma_region_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      sigma_region_free__ = stan::math::lb_free(sigma_region, 0);
      double sigma_age_edu;
      sigma_age_edu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      sigma_age_edu = context__.vals_r("sigma_age_edu")[(1 - 1)];
      double sigma_age_edu_free__;
      sigma_age_edu_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      sigma_age_edu_free__ = stan::math::lb_free(sigma_age_edu, 0);
      double b_0;
      b_0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      b_0 = context__.vals_r("b_0")[(1 - 1)];
      double b_female;
      b_female = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 8;
      b_female = context__.vals_r("b_female")[(1 - 1)];
      double b_black;
      b_black = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 9;
      b_black = context__.vals_r("b_black")[(1 - 1)];
      double b_female_black;
      b_female_black = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 10;
      b_female_black = context__.vals_r("b_female_black")[(1 - 1)];
      double b_v_prev;
      b_v_prev = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      b_v_prev = context__.vals_r("b_v_prev")[(1 - 1)];
      Eigen::Matrix<double, -1, 1> b_age;
      b_age = Eigen::Matrix<double, -1, 1>(n_age);
      stan::math::fill(b_age, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> b_age_flat__;
        current_statement__ = 12;
        assign(b_age_flat__, nil_index_list(), context__.vals_r("b_age"),
          "assigning variable b_age_flat__");
        current_statement__ = 12;
        pos__ = 1;
        current_statement__ = 12;
        for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
          current_statement__ = 12;
          assign(b_age, cons_list(index_uni(sym1__), nil_index_list()),
            b_age_flat__[(pos__ - 1)], "assigning variable b_age");
          current_statement__ = 12;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> b_edu;
      b_edu = Eigen::Matrix<double, -1, 1>(n_edu);
      stan::math::fill(b_edu, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> b_edu_flat__;
        current_statement__ = 13;
        assign(b_edu_flat__, nil_index_list(), context__.vals_r("b_edu"),
          "assigning variable b_edu_flat__");
        current_statement__ = 13;
        pos__ = 1;
        current_statement__ = 13;
        for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
          current_statement__ = 13;
          assign(b_edu, cons_list(index_uni(sym1__), nil_index_list()),
            b_edu_flat__[(pos__ - 1)], "assigning variable b_edu");
          current_statement__ = 13;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> b_region;
      b_region = Eigen::Matrix<double, -1, 1>(n_region);
      stan::math::fill(b_region, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> b_region_flat__;
        current_statement__ = 14;
        assign(b_region_flat__, nil_index_list(),
          context__.vals_r("b_region"), "assigning variable b_region_flat__");
        current_statement__ = 14;
        pos__ = 1;
        current_statement__ = 14;
        for (int sym1__ = 1; sym1__ <= n_region; ++sym1__) {
          current_statement__ = 14;
          assign(b_region, cons_list(index_uni(sym1__), nil_index_list()),
            b_region_flat__[(pos__ - 1)], "assigning variable b_region");
          current_statement__ = 14;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, -1> b_age_edu;
      b_age_edu = Eigen::Matrix<double, -1, -1>(n_age, n_edu);
      stan::math::fill(b_age_edu, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> b_age_edu_flat__;
        current_statement__ = 15;
        assign(b_age_edu_flat__, nil_index_list(),
          context__.vals_r("b_age_edu"),
          "assigning variable b_age_edu_flat__");
        current_statement__ = 15;
        pos__ = 1;
        current_statement__ = 15;
        for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
          current_statement__ = 15;
          for (int sym2__ = 1; sym2__ <= n_age; ++sym2__) {
            current_statement__ = 15;
            assign(b_age_edu,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              b_age_edu_flat__[(pos__ - 1)], "assigning variable b_age_edu");
            current_statement__ = 15;
            pos__ = (pos__ + 1);}}
      }
      Eigen::Matrix<double, -1, 1> b_hat;
      b_hat = Eigen::Matrix<double, -1, 1>(n_state);
      stan::math::fill(b_hat, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> b_hat_flat__;
        current_statement__ = 16;
        assign(b_hat_flat__, nil_index_list(), context__.vals_r("b_hat"),
          "assigning variable b_hat_flat__");
        current_statement__ = 16;
        pos__ = 1;
        current_statement__ = 16;
        for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
          current_statement__ = 16;
          assign(b_hat, cons_list(index_uni(sym1__), nil_index_list()),
            b_hat_flat__[(pos__ - 1)], "assigning variable b_hat");
          current_statement__ = 16;
          pos__ = (pos__ + 1);}
      }
      vars__.emplace_back(sigma_free__);
      vars__.emplace_back(sigma_age_free__);
      vars__.emplace_back(sigma_edu_free__);
      vars__.emplace_back(sigma_state_free__);
      vars__.emplace_back(sigma_region_free__);
      vars__.emplace_back(sigma_age_edu_free__);
      vars__.emplace_back(b_0);
      vars__.emplace_back(b_female);
      vars__.emplace_back(b_black);
      vars__.emplace_back(b_female_black);
      vars__.emplace_back(b_v_prev);
      for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
        vars__.emplace_back(b_age[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
        vars__.emplace_back(b_edu[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_region; ++sym1__) {
        vars__.emplace_back(b_region[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_age; ++sym2__) {
          vars__.emplace_back(
            rvalue(b_age_edu,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "b_age_edu"));
        }}
      for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
        vars__.emplace_back(b_hat[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("sigma");
    names__.emplace_back("sigma_age");
    names__.emplace_back("sigma_edu");
    names__.emplace_back("sigma_state");
    names__.emplace_back("sigma_region");
    names__.emplace_back("sigma_age_edu");
    names__.emplace_back("b_0");
    names__.emplace_back("b_female");
    names__.emplace_back("b_black");
    names__.emplace_back("b_female_black");
    names__.emplace_back("b_v_prev");
    names__.emplace_back("b_age");
    names__.emplace_back("b_edu");
    names__.emplace_back("b_region");
    names__.emplace_back("b_age_edu");
    names__.emplace_back("b_hat");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_age)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_edu)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_region)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_age),
                                             static_cast<size_t>(n_edu)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_state)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "sigma");
    param_names__.emplace_back(std::string() + "sigma_age");
    param_names__.emplace_back(std::string() + "sigma_edu");
    param_names__.emplace_back(std::string() + "sigma_state");
    param_names__.emplace_back(std::string() + "sigma_region");
    param_names__.emplace_back(std::string() + "sigma_age_edu");
    param_names__.emplace_back(std::string() + "b_0");
    param_names__.emplace_back(std::string() + "b_female");
    param_names__.emplace_back(std::string() + "b_black");
    param_names__.emplace_back(std::string() + "b_female_black");
    param_names__.emplace_back(std::string() + "b_v_prev");
    for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_age" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_edu" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_region; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_region" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= n_age; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "b_age_edu" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_hat" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "sigma");
    param_names__.emplace_back(std::string() + "sigma_age");
    param_names__.emplace_back(std::string() + "sigma_edu");
    param_names__.emplace_back(std::string() + "sigma_state");
    param_names__.emplace_back(std::string() + "sigma_region");
    param_names__.emplace_back(std::string() + "sigma_age_edu");
    param_names__.emplace_back(std::string() + "b_0");
    param_names__.emplace_back(std::string() + "b_female");
    param_names__.emplace_back(std::string() + "b_black");
    param_names__.emplace_back(std::string() + "b_female_black");
    param_names__.emplace_back(std::string() + "b_v_prev");
    for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_age" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_edu" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_region; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_region" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= n_age; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "b_age_edu" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_hat" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_state\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_region\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_v_prev\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_age\",\"type\":{\"name\":\"vector\",\"length\":" << n_age << "},\"block\":\"parameters\"},{\"name\":\"b_edu\",\"type\":{\"name\":\"vector\",\"length\":" << n_edu << "},\"block\":\"parameters\"},{\"name\":\"b_region\",\"type\":{\"name\":\"vector\",\"length\":" << n_region << "},\"block\":\"parameters\"},{\"name\":\"b_age_edu\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_age << ",\"cols\":" << n_edu << "},\"block\":\"parameters\"},{\"name\":\"b_hat\",\"type\":{\"name\":\"vector\",\"length\":" << n_state << "},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_state\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_region\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_v_prev\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_age\",\"type\":{\"name\":\"vector\",\"length\":" << n_age << "},\"block\":\"parameters\"},{\"name\":\"b_edu\",\"type\":{\"name\":\"vector\",\"length\":" << n_edu << "},\"block\":\"parameters\"},{\"name\":\"b_region\",\"type\":{\"name\":\"vector\",\"length\":" << n_region << "},\"block\":\"parameters\"},{\"name\":\"b_age_edu\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_age << ",\"cols\":" << n_edu << "},\"block\":\"parameters\"},{\"name\":\"b_hat\",\"type\":{\"name\":\"vector\",\"length\":" << n_state << "},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = dce_fail_model_namespace::dce_fail_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return dce_fail_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-experiment.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_experiment_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-experiment.stan', line 2, column 2 to column 8)",
                                                      " (in 'expr-prop-experiment.stan', line 5, column 2 to column 9)",
                                                      " (in 'expr-prop-experiment.stan', line 6, column 2 to column 9)",
                                                      " (in 'expr-prop-experiment.stan', line 7, column 2 to column 9)",
                                                      " (in 'expr-prop-experiment.stan', line 8, column 2 to column 28)",
                                                      " (in 'expr-prop-experiment.stan', line 9, column 2 to column 12)",
                                                      " (in 'expr-prop-experiment.stan', line 10, column 2 to column 23)",
                                                      " (in 'expr-prop-experiment.stan', line 11, column 2 to column 23)",
                                                      " (in 'expr-prop-experiment.stan', line 12, column 2 to column 23)"};



class expr_prop_experiment_model final : public model_base_crtp<expr_prop_experiment_model> {

 private:
  int j;
  double z;
  double x;
  double y;
  double i;
 
 public:
  ~expr_prop_experiment_model() { }
  
  inline std::string model_name() const final { return "expr_prop_experiment_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_experiment_model(stan::io::var_context& context__,
                             unsigned int random_seed__ = 0,
                             std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_experiment_model_namespace::expr_prop_experiment_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 1;
      context__.validate_dims("data initialization","j","int",
          context__.to_vec());
      j = std::numeric_limits<int>::min();
      
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      current_statement__ = 2;
      z = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      x = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      y = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      i = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      i = normal_rng(5, 1, base_rng__);
      current_statement__ = 6;
      z = (i * j);
      current_statement__ = 7;
      x = normal_rng(z, 1, base_rng__);
      current_statement__ = 8;
      i = normal_rng(5, 1, base_rng__);
      current_statement__ = 9;
      y = normal_rng(z, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_experiment_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_experiment_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}

using stan_model = expr_prop_experiment_model_namespace::expr_prop_experiment_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_experiment_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-experiment2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_experiment2_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-experiment2.stan', line 2, column 2 to column 8)",
                                                      " (in 'expr-prop-experiment2.stan', line 5, column 2 to column 13)",
                                                      " (in 'expr-prop-experiment2.stan', line 6, column 2 to column 9)",
                                                      " (in 'expr-prop-experiment2.stan', line 8, column 4 to column 32)",
                                                      " (in 'expr-prop-experiment2.stan', line 9, column 4 to column 14)",
                                                      " (in 'expr-prop-experiment2.stan', line 10, column 4 to column 25)",
                                                      " (in 'expr-prop-experiment2.stan', line 7, column 2 to line 11, column 3)",
                                                      " (in 'expr-prop-experiment2.stan', line 12, column 2 to column 23)"};



class expr_prop_experiment2_model final : public model_base_crtp<expr_prop_experiment2_model> {

 private:
  int j;
  double z;
  double y;
 
 public:
  ~expr_prop_experiment2_model() { }
  
  inline std::string model_name() const final { return "expr_prop_experiment2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_experiment2_model(stan::io::var_context& context__,
                              unsigned int random_seed__ = 0,
                              std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_experiment2_model_namespace::expr_prop_experiment2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 1;
      context__.validate_dims("data initialization","j","int",
          context__.to_vec());
      j = std::numeric_limits<int>::min();
      
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      current_statement__ = 2;
      z = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      z = 1;
      current_statement__ = 3;
      y = std::numeric_limits<double>::quiet_NaN();
      
      {
        double x;
        x = std::numeric_limits<double>::quiet_NaN();
        
        current_statement__ = 4;
        x = normal_rng(123, 1, base_rng__);
        current_statement__ = 5;
        z = (x * 2);
        current_statement__ = 6;
        y = normal_rng(z, 1, base_rng__);
      }
      current_statement__ = 8;
      y = normal_rng(z, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_experiment2_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_experiment2_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}

using stan_model = expr_prop_experiment2_model_namespace::expr_prop_experiment2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_experiment2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail.stan', line 7, column 2 to column 16)",
                                                      " (in 'expr-prop-fail.stan', line 8, column 2 to column 25)",
                                                      " (in 'expr-prop-fail.stan', line 9, column 2 to column 31)",
                                                      " (in 'expr-prop-fail.stan', line 13, column 1 to column 22)",
                                                      " (in 'expr-prop-fail.stan', line 14, column 1 to column 19)",
                                                      " (in 'expr-prop-fail.stan', line 15, column 1 to column 20)",
                                                      " (in 'expr-prop-fail.stan', line 17, column 3 to line 19, column 58)",
                                                      " (in 'expr-prop-fail.stan', line 16, column 1 to line 19, column 58)",
                                                      " (in 'expr-prop-fail.stan', line 2, column 1 to column 18)",
                                                      " (in 'expr-prop-fail.stan', line 3, column 8 to column 9)",
                                                      " (in 'expr-prop-fail.stan', line 3, column 1 to column 13)"};



class expr_prop_fail_model final : public model_base_crtp<expr_prop_fail_model> {

 private:
  int N;
  Eigen::Matrix<double, -1, 1> y;
 
 public:
  ~expr_prop_fail_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail_model_namespace::expr_prop_fail_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 9;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 9;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 9;
      current_statement__ = 9;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 10;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 11;
      context__.validate_dims("data initialization","y","double",
          context__.to_vec(N));
      y = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(y, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> y_flat__;
        current_statement__ = 11;
        assign(y_flat__, nil_index_list(), context__.vals_r("y"),
          "assigning variable y_flat__");
        current_statement__ = 11;
        pos__ = 1;
        current_statement__ = 11;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 11;
          assign(y, cons_list(index_uni(sym1__), nil_index_list()),
            y_flat__[(pos__ - 1)], "assigning variable y");
          current_statement__ = 11;
          pos__ = (pos__ + 1);}
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 2;
      num_params_r__ += 2;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> mu;
      mu = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(mu, DUMMY_VAR__);
      
      current_statement__ = 1;
      mu = in__.vector(2);
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        assign(mu, nil_index_list(), stan::math::ordered_constrain(mu, lp__),
          "assigning variable mu");
      } else {
        current_statement__ = 1;
        assign(mu, nil_index_list(), stan::math::ordered_constrain(mu),
          "assigning variable mu");
      }
      std::vector<local_scalar_t__> sigma;
      sigma = std::vector<local_scalar_t__>(2, DUMMY_VAR__);
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 2;
        assign(sigma, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable sigma");}
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 2;
        if (jacobian__) {
          current_statement__ = 2;
          assign(sigma, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(sigma[(sym1__ - 1)], 0, lp__),
            "assigning variable sigma");
        } else {
          current_statement__ = 2;
          assign(sigma, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(sigma[(sym1__ - 1)], 0),
            "assigning variable sigma");
        }}
      local_scalar_t__ theta;
      theta = DUMMY_VAR__;
      
      current_statement__ = 3;
      theta = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        theta = stan::math::lub_constrain(theta, 0, 1, lp__);
      } else {
        current_statement__ = 3;
        theta = stan::math::lub_constrain(theta, 0, 1);
      }
      {
        current_statement__ = 4;
        lp_accum__.add(normal_lpdf<propto__>(sigma, 0, 2));
        current_statement__ = 5;
        lp_accum__.add(normal_lpdf<propto__>(mu, 0, 2));
        current_statement__ = 6;
        lp_accum__.add(beta_lpdf<propto__>(theta, 5, 5));
        current_statement__ = 8;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 7;
          lp_accum__.add(
            log_mix(theta,
              normal_lpdf<false>(y[(n - 1)], mu[(1 - 1)], sigma[(1 - 1)]),
              normal_lpdf<false>(y[(n - 1)], mu[(2 - 1)], sigma[(2 - 1)])));}
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      Eigen::Matrix<double, -1, 1> mu;
      mu = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(mu, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      mu = in__.vector(2);
      current_statement__ = 1;
      assign(mu, nil_index_list(), stan::math::ordered_constrain(mu),
        "assigning variable mu");
      std::vector<double> sigma;
      sigma = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 2;
        assign(sigma, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable sigma");}
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 2;
        assign(sigma, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(sigma[(sym1__ - 1)], 0),
          "assigning variable sigma");}
      double theta;
      theta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      theta = in__.scalar();
      current_statement__ = 3;
      theta = stan::math::lub_constrain(theta, 0, 1);
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.emplace_back(mu[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.emplace_back(sigma[(sym1__ - 1)]);}
      vars__.emplace_back(theta);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      Eigen::Matrix<double, -1, 1> mu;
      mu = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(mu, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> mu_flat__;
        current_statement__ = 1;
        assign(mu_flat__, nil_index_list(), context__.vals_r("mu"),
          "assigning variable mu_flat__");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 1;
          assign(mu, cons_list(index_uni(sym1__), nil_index_list()),
            mu_flat__[(pos__ - 1)], "assigning variable mu");
          current_statement__ = 1;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> mu_free__;
      mu_free__ = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(mu_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      assign(mu_free__, nil_index_list(), stan::math::ordered_free(mu),
        "assigning variable mu_free__");
      std::vector<double> sigma;
      sigma = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      assign(sigma, nil_index_list(), context__.vals_r("sigma"),
        "assigning variable sigma");
      std::vector<double> sigma_free__;
      sigma_free__ = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 2;
        assign(sigma_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(sigma[(sym1__ - 1)], 0),
          "assigning variable sigma_free__");}
      double theta;
      theta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      theta = context__.vals_r("theta")[(1 - 1)];
      double theta_free__;
      theta_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      theta_free__ = stan::math::lub_free(theta, 0, 1);
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.emplace_back(mu_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.emplace_back(sigma_free__[(sym1__ - 1)]);}
      vars__.emplace_back(theta_free__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("mu");
    names__.emplace_back("sigma");
    names__.emplace_back("theta");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(2)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(2)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "mu" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "theta");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "mu" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "theta");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" << 2 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" << 2 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = expr_prop_fail_model_namespace::expr_prop_fail_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail2_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail2.stan', line 7, column 2 to column 10)",
                                                      " (in 'expr-prop-fail2.stan', line 8, column 2 to column 16)",
                                                      " (in 'expr-prop-fail2.stan', line 9, column 2 to column 20)",
                                                      " (in 'expr-prop-fail2.stan', line 12, column 2 to column 26)",
                                                      " (in 'expr-prop-fail2.stan', line 13, column 2 to column 26)",
                                                      " (in 'expr-prop-fail2.stan', line 2, column 2 to column 17)",
                                                      " (in 'expr-prop-fail2.stan', line 3, column 9 to column 10)",
                                                      " (in 'expr-prop-fail2.stan', line 3, column 2 to column 12)",
                                                      " (in 'expr-prop-fail2.stan', line 4, column 22 to column 23)",
                                                      " (in 'expr-prop-fail2.stan', line 4, column 2 to column 25)",
                                                      " (in 'expr-prop-fail2.stan', line 8, column 13 to column 14)"};



class expr_prop_fail2_model final : public model_base_crtp<expr_prop_fail2_model> {

 private:
  int J;
  std::vector<double> y;
  std::vector<double> sigma;
 
 public:
  ~expr_prop_fail2_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail2_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail2_model_namespace::expr_prop_fail2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 6;
      context__.validate_dims("data initialization","J","int",
          context__.to_vec());
      J = std::numeric_limits<int>::min();
      
      current_statement__ = 6;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 6;
      current_statement__ = 6;
      check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 7;
      validate_non_negative_index("y", "J", J);
      current_statement__ = 8;
      context__.validate_dims("data initialization","y","double",
          context__.to_vec(J));
      y = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      assign(y, nil_index_list(), context__.vals_r("y"),
        "assigning variable y");
      current_statement__ = 9;
      validate_non_negative_index("sigma", "J", J);
      current_statement__ = 10;
      context__.validate_dims("data initialization","sigma","double",
          context__.to_vec(J));
      sigma = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 10;
      assign(sigma, nil_index_list(), context__.vals_r("sigma"),
        "assigning variable sigma");
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        current_statement__ = 10;
        current_statement__ = 10;
        check_greater_or_equal(function__, "sigma[sym1__]",
                               sigma[(sym1__ - 1)], 0);}
      current_statement__ = 11;
      validate_non_negative_index("theta", "J", J);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += J;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail2_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ mu;
      mu = DUMMY_VAR__;
      
      current_statement__ = 1;
      mu = in__.scalar();
      std::vector<local_scalar_t__> theta;
      theta = std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        current_statement__ = 2;
        assign(theta, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable theta");}
      local_scalar_t__ tau;
      tau = DUMMY_VAR__;
      
      current_statement__ = 3;
      tau = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        tau = stan::math::lb_constrain(tau, 0, lp__);
      } else {
        current_statement__ = 3;
        tau = stan::math::lb_constrain(tau, 0);
      }
      {
        current_statement__ = 4;
        lp_accum__.add(normal_lpdf<propto__>(theta, mu, tau));
        current_statement__ = 5;
        lp_accum__.add(normal_lpdf<propto__>(y, theta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail2_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double mu;
      mu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mu = in__.scalar();
      std::vector<double> theta;
      theta = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        current_statement__ = 2;
        assign(theta, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable theta");}
      double tau;
      tau = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      tau = in__.scalar();
      current_statement__ = 3;
      tau = stan::math::lb_constrain(tau, 0);
      vars__.emplace_back(mu);
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        vars__.emplace_back(theta[(sym1__ - 1)]);}
      vars__.emplace_back(tau);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double mu;
      mu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mu = context__.vals_r("mu")[(1 - 1)];
      std::vector<double> theta;
      theta = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      assign(theta, nil_index_list(), context__.vals_r("theta"),
        "assigning variable theta");
      double tau;
      tau = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      tau = context__.vals_r("tau")[(1 - 1)];
      double tau_free__;
      tau_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      tau_free__ = stan::math::lb_free(tau, 0);
      vars__.emplace_back(mu);
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        vars__.emplace_back(theta[(sym1__ - 1)]);}
      vars__.emplace_back(tau_free__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("mu");
    names__.emplace_back("theta");
    names__.emplace_back("tau");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(J)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "tau");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "tau");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << J << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << J << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = expr_prop_fail2_model_namespace::expr_prop_fail2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail3.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail3_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail3.stan', line 19, column 2 to column 18)",
                                                      " (in 'expr-prop-fail3.stan', line 20, column 2 to column 18)",
                                                      " (in 'expr-prop-fail3.stan', line 21, column 2 to column 22)",
                                                      " (in 'expr-prop-fail3.stan', line 22, column 2 to column 20)",
                                                      " (in 'expr-prop-fail3.stan', line 23, column 2 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 24, column 2 to column 17)",
                                                      " (in 'expr-prop-fail3.stan', line 25, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 26, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 27, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 28, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 29, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 32, column 2 to column 18)",
                                                      " (in 'expr-prop-fail3.stan', line 35, column 4 to line 38, column 66)",
                                                      " (in 'expr-prop-fail3.stan', line 34, column 2 to line 38, column 66)",
                                                      " (in 'expr-prop-fail3.stan', line 41, column 2 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 42, column 2 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 43, column 2 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 44, column 2 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 45, column 2 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 46, column 2 to column 24)",
                                                      " (in 'expr-prop-fail3.stan', line 47, column 2 to column 29)",
                                                      " (in 'expr-prop-fail3.stan', line 2, column 2 to column 17)",
                                                      " (in 'expr-prop-fail3.stan', line 3, column 2 to column 21)",
                                                      " (in 'expr-prop-fail3.stan', line 4, column 2 to column 25)",
                                                      " (in 'expr-prop-fail3.stan', line 5, column 2 to column 21)",
                                                      " (in 'expr-prop-fail3.stan', line 6, column 2 to column 29)",
                                                      " (in 'expr-prop-fail3.stan', line 7, column 2 to column 23)",
                                                      " (in 'expr-prop-fail3.stan', line 8, column 31 to column 32)",
                                                      " (in 'expr-prop-fail3.stan', line 8, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 9, column 39 to column 40)",
                                                      " (in 'expr-prop-fail3.stan', line 9, column 2 to column 42)",
                                                      " (in 'expr-prop-fail3.stan', line 10, column 26 to column 27)",
                                                      " (in 'expr-prop-fail3.stan', line 10, column 2 to column 35)",
                                                      " (in 'expr-prop-fail3.stan', line 11, column 31 to column 32)",
                                                      " (in 'expr-prop-fail3.stan', line 11, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 12, column 26 to column 27)",
                                                      " (in 'expr-prop-fail3.stan', line 12, column 2 to column 36)",
                                                      " (in 'expr-prop-fail3.stan', line 13, column 47 to column 48)",
                                                      " (in 'expr-prop-fail3.stan', line 13, column 2 to column 50)",
                                                      " (in 'expr-prop-fail3.stan', line 14, column 35 to column 36)",
                                                      " (in 'expr-prop-fail3.stan', line 14, column 2 to column 38)",
                                                      " (in 'expr-prop-fail3.stan', line 15, column 9 to column 10)",
                                                      " (in 'expr-prop-fail3.stan', line 15, column 2 to column 24)",
                                                      " (in 'expr-prop-fail3.stan', line 16, column 25 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 16, column 2 to column 28)",
                                                      " (in 'expr-prop-fail3.stan', line 19, column 9 to column 14)",
                                                      " (in 'expr-prop-fail3.stan', line 20, column 9 to column 14)",
                                                      " (in 'expr-prop-fail3.stan', line 21, column 9 to column 18)",
                                                      " (in 'expr-prop-fail3.stan', line 22, column 9 to column 16)",
                                                      " (in 'expr-prop-fail3.stan', line 23, column 9 to column 22)",
                                                      " (in 'expr-prop-fail3.stan', line 32, column 9 to column 10)"};



class expr_prop_fail3_model final : public model_base_crtp<expr_prop_fail3_model> {

 private:
  int N;
  int n_age;
  int n_age_edu;
  int n_edu;
  int n_region_full;
  int n_state;
  std::vector<int> age;
  std::vector<int> age_edu;
  Eigen::Matrix<double, -1, 1> black;
  std::vector<int> edu;
  Eigen::Matrix<double, -1, 1> female;
  std::vector<int> region_full;
  std::vector<int> state;
  Eigen::Matrix<double, -1, 1> v_prev_full;
  std::vector<int> y;
 
 public:
  ~expr_prop_fail3_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail3_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail3_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail3_model_namespace::expr_prop_fail3_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 22;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 22;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 22;
      current_statement__ = 22;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 23;
      context__.validate_dims("data initialization","n_age","int",
          context__.to_vec());
      n_age = std::numeric_limits<int>::min();
      
      current_statement__ = 23;
      n_age = context__.vals_i("n_age")[(1 - 1)];
      current_statement__ = 23;
      current_statement__ = 23;
      check_greater_or_equal(function__, "n_age", n_age, 0);
      current_statement__ = 24;
      context__.validate_dims("data initialization","n_age_edu","int",
          context__.to_vec());
      n_age_edu = std::numeric_limits<int>::min();
      
      current_statement__ = 24;
      n_age_edu = context__.vals_i("n_age_edu")[(1 - 1)];
      current_statement__ = 24;
      current_statement__ = 24;
      check_greater_or_equal(function__, "n_age_edu", n_age_edu, 0);
      current_statement__ = 25;
      context__.validate_dims("data initialization","n_edu","int",
          context__.to_vec());
      n_edu = std::numeric_limits<int>::min();
      
      current_statement__ = 25;
      n_edu = context__.vals_i("n_edu")[(1 - 1)];
      current_statement__ = 25;
      current_statement__ = 25;
      check_greater_or_equal(function__, "n_edu", n_edu, 0);
      current_statement__ = 26;
      context__.validate_dims("data initialization","n_region_full","int",
          context__.to_vec());
      n_region_full = std::numeric_limits<int>::min();
      
      current_statement__ = 26;
      n_region_full = context__.vals_i("n_region_full")[(1 - 1)];
      current_statement__ = 26;
      current_statement__ = 26;
      check_greater_or_equal(function__, "n_region_full", n_region_full, 0);
      current_statement__ = 27;
      context__.validate_dims("data initialization","n_state","int",
          context__.to_vec());
      n_state = std::numeric_limits<int>::min();
      
      current_statement__ = 27;
      n_state = context__.vals_i("n_state")[(1 - 1)];
      current_statement__ = 27;
      current_statement__ = 27;
      check_greater_or_equal(function__, "n_state", n_state, 0);
      current_statement__ = 28;
      validate_non_negative_index("age", "N", N);
      current_statement__ = 29;
      context__.validate_dims("data initialization","age","int",
          context__.to_vec(N));
      age = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 29;
      assign(age, nil_index_list(), context__.vals_i("age"),
        "assigning variable age");
      current_statement__ = 29;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 29;
        current_statement__ = 29;
        check_greater_or_equal(function__, "age[sym1__]", age[(sym1__ - 1)],
                               0);}
      current_statement__ = 29;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 29;
        current_statement__ = 29;
        check_less_or_equal(function__, "age[sym1__]", age[(sym1__ - 1)],
                            n_age);}
      current_statement__ = 30;
      validate_non_negative_index("age_edu", "N", N);
      current_statement__ = 31;
      context__.validate_dims("data initialization","age_edu","int",
          context__.to_vec(N));
      age_edu = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 31;
      assign(age_edu, nil_index_list(), context__.vals_i("age_edu"),
        "assigning variable age_edu");
      current_statement__ = 31;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 31;
        current_statement__ = 31;
        check_greater_or_equal(function__, "age_edu[sym1__]",
                               age_edu[(sym1__ - 1)], 0);}
      current_statement__ = 31;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 31;
        current_statement__ = 31;
        check_less_or_equal(function__, "age_edu[sym1__]",
                            age_edu[(sym1__ - 1)], n_age_edu);}
      current_statement__ = 32;
      validate_non_negative_index("black", "N", N);
      current_statement__ = 33;
      context__.validate_dims("data initialization","black","double",
          context__.to_vec(N));
      black = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(black, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> black_flat__;
        current_statement__ = 33;
        assign(black_flat__, nil_index_list(), context__.vals_r("black"),
          "assigning variable black_flat__");
        current_statement__ = 33;
        pos__ = 1;
        current_statement__ = 33;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 33;
          assign(black, cons_list(index_uni(sym1__), nil_index_list()),
            black_flat__[(pos__ - 1)], "assigning variable black");
          current_statement__ = 33;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 33;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 33;
        current_statement__ = 33;
        check_greater_or_equal(function__, "black[sym1__]",
                               black[(sym1__ - 1)], 0);}
      current_statement__ = 33;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 33;
        current_statement__ = 33;
        check_less_or_equal(function__, "black[sym1__]", black[(sym1__ - 1)],
                            1);}
      current_statement__ = 34;
      validate_non_negative_index("edu", "N", N);
      current_statement__ = 35;
      context__.validate_dims("data initialization","edu","int",
          context__.to_vec(N));
      edu = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 35;
      assign(edu, nil_index_list(), context__.vals_i("edu"),
        "assigning variable edu");
      current_statement__ = 35;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 35;
        current_statement__ = 35;
        check_greater_or_equal(function__, "edu[sym1__]", edu[(sym1__ - 1)],
                               0);}
      current_statement__ = 35;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 35;
        current_statement__ = 35;
        check_less_or_equal(function__, "edu[sym1__]", edu[(sym1__ - 1)],
                            n_edu);}
      current_statement__ = 36;
      validate_non_negative_index("female", "N", N);
      current_statement__ = 37;
      context__.validate_dims("data initialization","female","double",
          context__.to_vec(N));
      female = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(female, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> female_flat__;
        current_statement__ = 37;
        assign(female_flat__, nil_index_list(), context__.vals_r("female"),
          "assigning variable female_flat__");
        current_statement__ = 37;
        pos__ = 1;
        current_statement__ = 37;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 37;
          assign(female, cons_list(index_uni(sym1__), nil_index_list()),
            female_flat__[(pos__ - 1)], "assigning variable female");
          current_statement__ = 37;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 37;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 37;
        current_statement__ = 37;
        check_greater_or_equal(function__, "female[sym1__]",
                               female[(sym1__ - 1)], 0);}
      current_statement__ = 37;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 37;
        current_statement__ = 37;
        check_less_or_equal(function__, "female[sym1__]",
                            female[(sym1__ - 1)], 1);}
      current_statement__ = 38;
      validate_non_negative_index("region_full", "N", N);
      current_statement__ = 39;
      context__.validate_dims("data initialization","region_full","int",
          context__.to_vec(N));
      region_full = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 39;
      assign(region_full, nil_index_list(), context__.vals_i("region_full"),
        "assigning variable region_full");
      current_statement__ = 39;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 39;
        current_statement__ = 39;
        check_greater_or_equal(function__, "region_full[sym1__]",
                               region_full[(sym1__ - 1)], 0);}
      current_statement__ = 39;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 39;
        current_statement__ = 39;
        check_less_or_equal(function__, "region_full[sym1__]",
                            region_full[(sym1__ - 1)], n_region_full);}
      current_statement__ = 40;
      validate_non_negative_index("state", "N", N);
      current_statement__ = 41;
      context__.validate_dims("data initialization","state","int",
          context__.to_vec(N));
      state = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 41;
      assign(state, nil_index_list(), context__.vals_i("state"),
        "assigning variable state");
      current_statement__ = 41;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 41;
        current_statement__ = 41;
        check_greater_or_equal(function__, "state[sym1__]",
                               state[(sym1__ - 1)], 0);}
      current_statement__ = 41;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 41;
        current_statement__ = 41;
        check_less_or_equal(function__, "state[sym1__]", state[(sym1__ - 1)],
                            n_state);}
      current_statement__ = 42;
      validate_non_negative_index("v_prev_full", "N", N);
      current_statement__ = 43;
      context__.validate_dims("data initialization","v_prev_full","double",
          context__.to_vec(N));
      v_prev_full = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(v_prev_full, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> v_prev_full_flat__;
        current_statement__ = 43;
        assign(v_prev_full_flat__, nil_index_list(),
          context__.vals_r("v_prev_full"),
          "assigning variable v_prev_full_flat__");
        current_statement__ = 43;
        pos__ = 1;
        current_statement__ = 43;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 43;
          assign(v_prev_full, cons_list(index_uni(sym1__), nil_index_list()),
            v_prev_full_flat__[(pos__ - 1)], "assigning variable v_prev_full");
          current_statement__ = 43;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 44;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 45;
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(N));
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 45;
      assign(y, nil_index_list(), context__.vals_i("y"),
        "assigning variable y");
      current_statement__ = 45;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 45;
        current_statement__ = 45;
        check_greater_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 0);}
      current_statement__ = 45;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 45;
        current_statement__ = 45;
        check_less_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 1);}
      current_statement__ = 46;
      validate_non_negative_index("a", "n_age", n_age);
      current_statement__ = 47;
      validate_non_negative_index("b", "n_edu", n_edu);
      current_statement__ = 48;
      validate_non_negative_index("c", "n_age_edu", n_age_edu);
      current_statement__ = 49;
      validate_non_negative_index("d", "n_state", n_state);
      current_statement__ = 50;
      validate_non_negative_index("e", "n_region_full", n_region_full);
      current_statement__ = 51;
      validate_non_negative_index("y_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += n_age;
      num_params_r__ += n_edu;
      num_params_r__ += n_age_edu;
      num_params_r__ += n_state;
      num_params_r__ += n_region_full;
      num_params_r__ += 5;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail3_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> a;
      a = Eigen::Matrix<local_scalar_t__, -1, 1>(n_age);
      stan::math::fill(a, DUMMY_VAR__);
      
      current_statement__ = 1;
      a = in__.vector(n_age);
      Eigen::Matrix<local_scalar_t__, -1, 1> b;
      b = Eigen::Matrix<local_scalar_t__, -1, 1>(n_edu);
      stan::math::fill(b, DUMMY_VAR__);
      
      current_statement__ = 2;
      b = in__.vector(n_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> c;
      c = Eigen::Matrix<local_scalar_t__, -1, 1>(n_age_edu);
      stan::math::fill(c, DUMMY_VAR__);
      
      current_statement__ = 3;
      c = in__.vector(n_age_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> d;
      d = Eigen::Matrix<local_scalar_t__, -1, 1>(n_state);
      stan::math::fill(d, DUMMY_VAR__);
      
      current_statement__ = 4;
      d = in__.vector(n_state);
      Eigen::Matrix<local_scalar_t__, -1, 1> e;
      e = Eigen::Matrix<local_scalar_t__, -1, 1>(n_region_full);
      stan::math::fill(e, DUMMY_VAR__);
      
      current_statement__ = 5;
      e = in__.vector(n_region_full);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(5);
      stan::math::fill(beta, DUMMY_VAR__);
      
      current_statement__ = 6;
      beta = in__.vector(5);
      local_scalar_t__ sigma_a;
      sigma_a = DUMMY_VAR__;
      
      current_statement__ = 7;
      sigma_a = in__.scalar();
      current_statement__ = 7;
      if (jacobian__) {
        current_statement__ = 7;
        sigma_a = stan::math::lub_constrain(sigma_a, 0, 100, lp__);
      } else {
        current_statement__ = 7;
        sigma_a = stan::math::lub_constrain(sigma_a, 0, 100);
      }
      local_scalar_t__ sigma_b;
      sigma_b = DUMMY_VAR__;
      
      current_statement__ = 8;
      sigma_b = in__.scalar();
      current_statement__ = 8;
      if (jacobian__) {
        current_statement__ = 8;
        sigma_b = stan::math::lub_constrain(sigma_b, 0, 100, lp__);
      } else {
        current_statement__ = 8;
        sigma_b = stan::math::lub_constrain(sigma_b, 0, 100);
      }
      local_scalar_t__ sigma_c;
      sigma_c = DUMMY_VAR__;
      
      current_statement__ = 9;
      sigma_c = in__.scalar();
      current_statement__ = 9;
      if (jacobian__) {
        current_statement__ = 9;
        sigma_c = stan::math::lub_constrain(sigma_c, 0, 100, lp__);
      } else {
        current_statement__ = 9;
        sigma_c = stan::math::lub_constrain(sigma_c, 0, 100);
      }
      local_scalar_t__ sigma_d;
      sigma_d = DUMMY_VAR__;
      
      current_statement__ = 10;
      sigma_d = in__.scalar();
      current_statement__ = 10;
      if (jacobian__) {
        current_statement__ = 10;
        sigma_d = stan::math::lub_constrain(sigma_d, 0, 100, lp__);
      } else {
        current_statement__ = 10;
        sigma_d = stan::math::lub_constrain(sigma_d, 0, 100);
      }
      local_scalar_t__ sigma_e;
      sigma_e = DUMMY_VAR__;
      
      current_statement__ = 11;
      sigma_e = in__.scalar();
      current_statement__ = 11;
      if (jacobian__) {
        current_statement__ = 11;
        sigma_e = stan::math::lub_constrain(sigma_e, 0, 100, lp__);
      } else {
        current_statement__ = 11;
        sigma_e = stan::math::lub_constrain(sigma_e, 0, 100);
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y_hat, DUMMY_VAR__);
      
      current_statement__ = 14;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 13;
        assign(y_hat, cons_list(index_uni(i), nil_index_list()),
          (((((((((beta[(1 - 1)] + (beta[(2 - 1)] * black[(i - 1)])) +
                   (beta[(3 - 1)] * female[(i - 1)])) +
                  ((beta[(5 - 1)] * female[(i - 1)]) * black[(i - 1)])) +
                 (beta[(4 - 1)] * v_prev_full[(i - 1)])) +
                a[(age[(i - 1)] - 1)]) + b[(edu[(i - 1)] - 1)]) +
              c[(age_edu[(i - 1)] - 1)]) + d[(state[(i - 1)] - 1)]) +
            e[(region_full[(i - 1)] - 1)]), "assigning variable y_hat");}
      {
        current_statement__ = 15;
        lp_accum__.add(normal_lpdf<propto__>(a, 0, sigma_a));
        current_statement__ = 16;
        lp_accum__.add(normal_lpdf<propto__>(b, 0, sigma_b));
        current_statement__ = 17;
        lp_accum__.add(normal_lpdf<propto__>(c, 0, sigma_c));
        current_statement__ = 18;
        lp_accum__.add(normal_lpdf<propto__>(d, 0, sigma_d));
        current_statement__ = 19;
        lp_accum__.add(normal_lpdf<propto__>(e, 0, sigma_e));
        current_statement__ = 20;
        lp_accum__.add(normal_lpdf<propto__>(beta, 0, 100));
        current_statement__ = 21;
        lp_accum__.add(bernoulli_logit_lpmf<propto__>(y, y_hat));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail3_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      Eigen::Matrix<double, -1, 1> a;
      a = Eigen::Matrix<double, -1, 1>(n_age);
      stan::math::fill(a, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      a = in__.vector(n_age);
      Eigen::Matrix<double, -1, 1> b;
      b = Eigen::Matrix<double, -1, 1>(n_edu);
      stan::math::fill(b, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      b = in__.vector(n_edu);
      Eigen::Matrix<double, -1, 1> c;
      c = Eigen::Matrix<double, -1, 1>(n_age_edu);
      stan::math::fill(c, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      c = in__.vector(n_age_edu);
      Eigen::Matrix<double, -1, 1> d;
      d = Eigen::Matrix<double, -1, 1>(n_state);
      stan::math::fill(d, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      d = in__.vector(n_state);
      Eigen::Matrix<double, -1, 1> e;
      e = Eigen::Matrix<double, -1, 1>(n_region_full);
      stan::math::fill(e, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      e = in__.vector(n_region_full);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(5);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      beta = in__.vector(5);
      double sigma_a;
      sigma_a = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      sigma_a = in__.scalar();
      current_statement__ = 7;
      sigma_a = stan::math::lub_constrain(sigma_a, 0, 100);
      double sigma_b;
      sigma_b = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 8;
      sigma_b = in__.scalar();
      current_statement__ = 8;
      sigma_b = stan::math::lub_constrain(sigma_b, 0, 100);
      double sigma_c;
      sigma_c = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 9;
      sigma_c = in__.scalar();
      current_statement__ = 9;
      sigma_c = stan::math::lub_constrain(sigma_c, 0, 100);
      double sigma_d;
      sigma_d = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 10;
      sigma_d = in__.scalar();
      current_statement__ = 10;
      sigma_d = stan::math::lub_constrain(sigma_d, 0, 100);
      double sigma_e;
      sigma_e = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      sigma_e = in__.scalar();
      current_statement__ = 11;
      sigma_e = stan::math::lub_constrain(sigma_e, 0, 100);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y_hat, DUMMY_VAR__);
      
      for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
        vars__.emplace_back(a[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
        vars__.emplace_back(b[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_age_edu; ++sym1__) {
        vars__.emplace_back(c[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
        vars__.emplace_back(d[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_region_full; ++sym1__) {
        vars__.emplace_back(e[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        vars__.emplace_back(beta[(sym1__ - 1)]);}
      vars__.emplace_back(sigma_a);
      vars__.emplace_back(sigma_b);
      vars__.emplace_back(sigma_c);
      vars__.emplace_back(sigma_d);
      vars__.emplace_back(sigma_e);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 14;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 13;
        assign(y_hat, cons_list(index_uni(i), nil_index_list()),
          (((((((((beta[(1 - 1)] + (beta[(2 - 1)] * black[(i - 1)])) +
                   (beta[(3 - 1)] * female[(i - 1)])) +
                  ((beta[(5 - 1)] * female[(i - 1)]) * black[(i - 1)])) +
                 (beta[(4 - 1)] * v_prev_full[(i - 1)])) +
                a[(age[(i - 1)] - 1)]) + b[(edu[(i - 1)] - 1)]) +
              c[(age_edu[(i - 1)] - 1)]) + d[(state[(i - 1)] - 1)]) +
            e[(region_full[(i - 1)] - 1)]), "assigning variable y_hat");}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          vars__.emplace_back(y_hat[(sym1__ - 1)]);}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      Eigen::Matrix<double, -1, 1> a;
      a = Eigen::Matrix<double, -1, 1>(n_age);
      stan::math::fill(a, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> a_flat__;
        current_statement__ = 1;
        assign(a_flat__, nil_index_list(), context__.vals_r("a"),
          "assigning variable a_flat__");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
          current_statement__ = 1;
          assign(a, cons_list(index_uni(sym1__), nil_index_list()),
            a_flat__[(pos__ - 1)], "assigning variable a");
          current_statement__ = 1;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> b;
      b = Eigen::Matrix<double, -1, 1>(n_edu);
      stan::math::fill(b, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> b_flat__;
        current_statement__ = 2;
        assign(b_flat__, nil_index_list(), context__.vals_r("b"),
          "assigning variable b_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
          current_statement__ = 2;
          assign(b, cons_list(index_uni(sym1__), nil_index_list()),
            b_flat__[(pos__ - 1)], "assigning variable b");
          current_statement__ = 2;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> c;
      c = Eigen::Matrix<double, -1, 1>(n_age_edu);
      stan::math::fill(c, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> c_flat__;
        current_statement__ = 3;
        assign(c_flat__, nil_index_list(), context__.vals_r("c"),
          "assigning variable c_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= n_age_edu; ++sym1__) {
          current_statement__ = 3;
          assign(c, cons_list(index_uni(sym1__), nil_index_list()),
            c_flat__[(pos__ - 1)], "assigning variable c");
          current_statement__ = 3;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> d;
      d = Eigen::Matrix<double, -1, 1>(n_state);
      stan::math::fill(d, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> d_flat__;
        current_statement__ = 4;
        assign(d_flat__, nil_index_list(), context__.vals_r("d"),
          "assigning variable d_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
          current_statement__ = 4;
          assign(d, cons_list(index_uni(sym1__), nil_index_list()),
            d_flat__[(pos__ - 1)], "assigning variable d");
          current_statement__ = 4;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> e;
      e = Eigen::Matrix<double, -1, 1>(n_region_full);
      stan::math::fill(e, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> e_flat__;
        current_statement__ = 5;
        assign(e_flat__, nil_index_list(), context__.vals_r("e"),
          "assigning variable e_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= n_region_full; ++sym1__) {
          current_statement__ = 5;
          assign(e, cons_list(index_uni(sym1__), nil_index_list()),
            e_flat__[(pos__ - 1)], "assigning variable e");
          current_statement__ = 5;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(5);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 6;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
          current_statement__ = 6;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            beta_flat__[(pos__ - 1)], "assigning variable beta");
          current_statement__ = 6;
          pos__ = (pos__ + 1);}
      }
      double sigma_a;
      sigma_a = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      sigma_a = context__.vals_r("sigma_a")[(1 - 1)];
      double sigma_a_free__;
      sigma_a_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      sigma_a_free__ = stan::math::lub_free(sigma_a, 0, 100);
      double sigma_b;
      sigma_b = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 8;
      sigma_b = context__.vals_r("sigma_b")[(1 - 1)];
      double sigma_b_free__;
      sigma_b_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 8;
      sigma_b_free__ = stan::math::lub_free(sigma_b, 0, 100);
      double sigma_c;
      sigma_c = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 9;
      sigma_c = context__.vals_r("sigma_c")[(1 - 1)];
      double sigma_c_free__;
      sigma_c_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 9;
      sigma_c_free__ = stan::math::lub_free(sigma_c, 0, 100);
      double sigma_d;
      sigma_d = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 10;
      sigma_d = context__.vals_r("sigma_d")[(1 - 1)];
      double sigma_d_free__;
      sigma_d_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 10;
      sigma_d_free__ = stan::math::lub_free(sigma_d, 0, 100);
      double sigma_e;
      sigma_e = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      sigma_e = context__.vals_r("sigma_e")[(1 - 1)];
      double sigma_e_free__;
      sigma_e_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      sigma_e_free__ = stan::math::lub_free(sigma_e, 0, 100);
      for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
        vars__.emplace_back(a[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
        vars__.emplace_back(b[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_age_edu; ++sym1__) {
        vars__.emplace_back(c[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
        vars__.emplace_back(d[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_region_full; ++sym1__) {
        vars__.emplace_back(e[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
        vars__.emplace_back(beta[(sym1__ - 1)]);}
      vars__.emplace_back(sigma_a_free__);
      vars__.emplace_back(sigma_b_free__);
      vars__.emplace_back(sigma_c_free__);
      vars__.emplace_back(sigma_d_free__);
      vars__.emplace_back(sigma_e_free__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("a");
    names__.emplace_back("b");
    names__.emplace_back("c");
    names__.emplace_back("d");
    names__.emplace_back("e");
    names__.emplace_back("beta");
    names__.emplace_back("sigma_a");
    names__.emplace_back("sigma_b");
    names__.emplace_back("sigma_c");
    names__.emplace_back("sigma_d");
    names__.emplace_back("sigma_e");
    names__.emplace_back("y_hat");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_age)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_edu)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_age_edu)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_state)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(n_region_full)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(5)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "a" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_age_edu; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "c" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "d" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_region_full; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "e" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_b");
    param_names__.emplace_back(std::string() + "sigma_c");
    param_names__.emplace_back(std::string() + "sigma_d");
    param_names__.emplace_back(std::string() + "sigma_e");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= n_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "a" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_edu; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_age_edu; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "c" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_state; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "d" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= n_region_full; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "e" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 5; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_b");
    param_names__.emplace_back(std::string() + "sigma_c");
    param_names__.emplace_back(std::string() + "sigma_d");
    param_names__.emplace_back(std::string() + "sigma_e");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" << n_age << "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << n_edu << "},\"block\":\"parameters\"},{\"name\":\"c\",\"type\":{\"name\":\"vector\",\"length\":" << n_age_edu << "},\"block\":\"parameters\"},{\"name\":\"d\",\"type\":{\"name\":\"vector\",\"length\":" << n_state << "},\"block\":\"parameters\"},{\"name\":\"e\",\"type\":{\"name\":\"vector\",\"length\":" << n_region_full << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << 5 << "},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_b\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_c\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_d\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_e\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" << n_age << "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << n_edu << "},\"block\":\"parameters\"},{\"name\":\"c\",\"type\":{\"name\":\"vector\",\"length\":" << n_age_edu << "},\"block\":\"parameters\"},{\"name\":\"d\",\"type\":{\"name\":\"vector\",\"length\":" << n_state << "},\"block\":\"parameters\"},{\"name\":\"e\",\"type\":{\"name\":\"vector\",\"length\":" << n_region_full << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << 5 << "},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_b\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_c\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_d\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_e\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = expr_prop_fail3_model_namespace::expr_prop_fail3_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail3_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail4.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail4_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail4.stan', line 12, column 2 to column 24)",
                                                      " (in 'expr-prop-fail4.stan', line 13, column 2 to column 28)",
                                                      " (in 'expr-prop-fail4.stan', line 16, column 2 to column 47)",
                                                      " (in 'expr-prop-fail4.stan', line 17, column 2 to column 16)",
                                                      " (in 'expr-prop-fail4.stan', line 18, column 2 to column 31)",
                                                      " (in 'expr-prop-fail4.stan', line 19, column 2 to column 29)",
                                                      " (in 'expr-prop-fail4.stan', line 20, column 2 to column 24)",
                                                      " (in 'expr-prop-fail4.stan', line 27, column 2 to column 13)",
                                                      " (in 'expr-prop-fail4.stan', line 28, column 2 to column 13)",
                                                      " (in 'expr-prop-fail4.stan', line 29, column 2 to column 26)",
                                                      " (in 'expr-prop-fail4.stan', line 30, column 2 to column 28)",
                                                      " (in 'expr-prop-fail4.stan', line 31, column 2 to column 18)",
                                                      " (in 'expr-prop-fail4.stan', line 32, column 2 to column 22)",
                                                      " (in 'expr-prop-fail4.stan', line 34, column 2 to column 14)",
                                                      " (in 'expr-prop-fail4.stan', line 35, column 2 to column 11)",
                                                      " (in 'expr-prop-fail4.stan', line 37, column 2 to column 27)",
                                                      " (in 'expr-prop-fail4.stan', line 38, column 2 to column 27)",
                                                      " (in 'expr-prop-fail4.stan', line 40, column 4 to column 36)",
                                                      " (in 'expr-prop-fail4.stan', line 39, column 17 to line 41, column 3)",
                                                      " (in 'expr-prop-fail4.stan', line 39, column 2 to line 41, column 3)",
                                                      " (in 'expr-prop-fail4.stan', line 42, column 2 to column 38)",
                                                      " (in 'expr-prop-fail4.stan', line 43, column 2 to column 37)",
                                                      " (in 'expr-prop-fail4.stan', line 44, column 2 to column 34)",
                                                      " (in 'expr-prop-fail4.stan', line 47, column 4 to column 28)",
                                                      " (in 'expr-prop-fail4.stan', line 48, column 4 to column 80)",
                                                      " (in 'expr-prop-fail4.stan', line 46, column 17 to line 49, column 3)",
                                                      " (in 'expr-prop-fail4.stan', line 46, column 2 to line 49, column 3)",
                                                      " (in 'expr-prop-fail4.stan', line 23, column 2 to column 53)",
                                                      " (in 'expr-prop-fail4.stan', line 24, column 2 to column 24)",
                                                      " (in 'expr-prop-fail4.stan', line 2, column 2 to column 17)",
                                                      " (in 'expr-prop-fail4.stan', line 3, column 2 to column 23)",
                                                      " (in 'expr-prop-fail4.stan', line 4, column 30 to column 37)",
                                                      " (in 'expr-prop-fail4.stan', line 4, column 2 to column 39)",
                                                      " (in 'expr-prop-fail4.stan', line 5, column 30 to column 37)",
                                                      " (in 'expr-prop-fail4.stan', line 5, column 2 to column 39)",
                                                      " (in 'expr-prop-fail4.stan', line 6, column 18 to column 19)",
                                                      " (in 'expr-prop-fail4.stan', line 6, column 2 to column 23)",
                                                      " (in 'expr-prop-fail4.stan', line 9, column 9 to column 10)",
                                                      " (in 'expr-prop-fail4.stan', line 9, column 2 to column 27)",
                                                      " (in 'expr-prop-fail4.stan', line 13, column 9 to column 14)",
                                                      " (in 'expr-prop-fail4.stan', line 17, column 9 to column 10)",
                                                      " (in 'expr-prop-fail4.stan', line 31, column 9 to column 10)",
                                                      " (in 'expr-prop-fail4.stan', line 32, column 9 to column 10)",
                                                      " (in 'expr-prop-fail4.stan', line 34, column 9 to column 10)",
                                                      " (in 'expr-prop-fail4.stan', line 35, column 8 to column 9)"};



class expr_prop_fail4_model final : public model_base_crtp<expr_prop_fail4_model> {

 private:
  int N;
  int N_edges;
  std::vector<int> node1;
  std::vector<int> node2;
  Eigen::Matrix<double, -1, 1> E;
  Eigen::Matrix<double, -1, 1> log_E;
  int phi_std_raw_1dim__;
 
 public:
  ~expr_prop_fail4_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail4_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail4_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail4_model_namespace::expr_prop_fail4_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 30;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 30;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 30;
      current_statement__ = 30;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 31;
      context__.validate_dims("data initialization","N_edges","int",
          context__.to_vec());
      N_edges = std::numeric_limits<int>::min();
      
      current_statement__ = 31;
      N_edges = context__.vals_i("N_edges")[(1 - 1)];
      current_statement__ = 31;
      current_statement__ = 31;
      check_greater_or_equal(function__, "N_edges", N_edges, 0);
      current_statement__ = 32;
      validate_non_negative_index("node1", "N_edges", N_edges);
      current_statement__ = 33;
      context__.validate_dims("data initialization","node1","int",
          context__.to_vec(N_edges));
      node1 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      
      current_statement__ = 33;
      assign(node1, nil_index_list(), context__.vals_i("node1"),
        "assigning variable node1");
      current_statement__ = 33;
      for (int sym1__ = 1; sym1__ <= N_edges; ++sym1__) {
        current_statement__ = 33;
        current_statement__ = 33;
        check_greater_or_equal(function__, "node1[sym1__]",
                               node1[(sym1__ - 1)], 1);}
      current_statement__ = 33;
      for (int sym1__ = 1; sym1__ <= N_edges; ++sym1__) {
        current_statement__ = 33;
        current_statement__ = 33;
        check_less_or_equal(function__, "node1[sym1__]", node1[(sym1__ - 1)],
                            N);}
      current_statement__ = 34;
      validate_non_negative_index("node2", "N_edges", N_edges);
      current_statement__ = 35;
      context__.validate_dims("data initialization","node2","int",
          context__.to_vec(N_edges));
      node2 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      
      current_statement__ = 35;
      assign(node2, nil_index_list(), context__.vals_i("node2"),
        "assigning variable node2");
      current_statement__ = 35;
      for (int sym1__ = 1; sym1__ <= N_edges; ++sym1__) {
        current_statement__ = 35;
        current_statement__ = 35;
        check_greater_or_equal(function__, "node2[sym1__]",
                               node2[(sym1__ - 1)], 1);}
      current_statement__ = 35;
      for (int sym1__ = 1; sym1__ <= N_edges; ++sym1__) {
        current_statement__ = 35;
        current_statement__ = 35;
        check_less_or_equal(function__, "node2[sym1__]", node2[(sym1__ - 1)],
                            N);}
      current_statement__ = 36;
      validate_non_negative_index("E", "N", N);
      current_statement__ = 37;
      context__.validate_dims("data initialization","E","double",
          context__.to_vec(N));
      E = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(E, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> E_flat__;
        current_statement__ = 37;
        assign(E_flat__, nil_index_list(), context__.vals_r("E"),
          "assigning variable E_flat__");
        current_statement__ = 37;
        pos__ = 1;
        current_statement__ = 37;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 37;
          assign(E, cons_list(index_uni(sym1__), nil_index_list()),
            E_flat__[(pos__ - 1)], "assigning variable E");
          current_statement__ = 37;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 37;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 37;
        current_statement__ = 37;
        check_greater_or_equal(function__, "E[sym1__]", E[(sym1__ - 1)], 0);}
      current_statement__ = 38;
      validate_non_negative_index("log_E", "N", N);
      current_statement__ = 39;
      log_E = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(log_E, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 39;
      assign(log_E, nil_index_list(), stan::math::log(E),
        "assigning variable log_E");
      current_statement__ = 40;
      phi_std_raw_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 40;
      phi_std_raw_1dim__ = (N - 1);
      current_statement__ = 40;
      validate_non_negative_index("phi_std_raw", "N - 1", phi_std_raw_1dim__);
      current_statement__ = 41;
      validate_non_negative_index("phi", "N", N);
      current_statement__ = 42;
      validate_non_negative_index("theta", "N", N);
      current_statement__ = 43;
      validate_non_negative_index("theta_std", "N", N);
      current_statement__ = 44;
      validate_non_negative_index("x", "N", N);
      current_statement__ = 45;
      validate_non_negative_index("y", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += phi_std_raw_1dim__;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail4_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ tau_phi;
      tau_phi = DUMMY_VAR__;
      
      current_statement__ = 1;
      tau_phi = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        tau_phi = stan::math::lb_constrain(tau_phi, 0, lp__);
      } else {
        current_statement__ = 1;
        tau_phi = stan::math::lb_constrain(tau_phi, 0);
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<local_scalar_t__, -1, 1>(phi_std_raw_1dim__);
      stan::math::fill(phi_std_raw, DUMMY_VAR__);
      
      current_statement__ = 2;
      phi_std_raw = in__.vector(phi_std_raw_1dim__);
      local_scalar_t__ sigma_phi;
      sigma_phi = DUMMY_VAR__;
      
      current_statement__ = 3;
      sigma_phi = inv(stan::math::sqrt(tau_phi));
      Eigen::Matrix<local_scalar_t__, -1, 1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(phi, DUMMY_VAR__);
      
      current_statement__ = 5;
      assign(phi, cons_list(index_min_max(1, (N - 1)), nil_index_list()),
        phi_std_raw, "assigning variable phi");
      current_statement__ = 6;
      assign(phi, cons_list(index_uni(N), nil_index_list()),
        -sum(phi_std_raw), "assigning variable phi");
      current_statement__ = 7;
      assign(phi, nil_index_list(),
        multiply(stan::model::deep_copy(phi), sigma_phi),
        "assigning variable phi");
      current_statement__ = 3;
      current_statement__ = 3;
      check_greater_or_equal(function__, "sigma_phi", sigma_phi, 0);
      {
        current_statement__ = 28;
        lp_accum__.add(
          (-0.5 *
            dot_self(
              subtract(
                rvalue(phi, cons_list(index_multi(node1), nil_index_list()),
                  "phi"),
                rvalue(phi, cons_list(index_multi(node2), nil_index_list()),
                  "phi")))));
        current_statement__ = 29;
        lp_accum__.add(gamma_lpdf<propto__>(tau_phi, 1, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail4_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double tau_phi;
      tau_phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      tau_phi = in__.scalar();
      current_statement__ = 1;
      tau_phi = stan::math::lb_constrain(tau_phi, 0);
      Eigen::Matrix<double, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<double, -1, 1>(phi_std_raw_1dim__);
      stan::math::fill(phi_std_raw, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      phi_std_raw = in__.vector(phi_std_raw_1dim__);
      double sigma_phi;
      sigma_phi = std::numeric_limits<double>::quiet_NaN();
      
      Eigen::Matrix<double, -1, 1> phi;
      phi = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(phi, std::numeric_limits<double>::quiet_NaN());
      
      vars__.emplace_back(tau_phi);
      for (int sym1__ = 1; sym1__ <= phi_std_raw_1dim__; ++sym1__) {
        vars__.emplace_back(phi_std_raw[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 3;
      sigma_phi = inv(stan::math::sqrt(tau_phi));
      current_statement__ = 5;
      assign(phi, cons_list(index_min_max(1, (N - 1)), nil_index_list()),
        phi_std_raw, "assigning variable phi");
      current_statement__ = 6;
      assign(phi, cons_list(index_uni(N), nil_index_list()),
        -sum(phi_std_raw), "assigning variable phi");
      current_statement__ = 7;
      assign(phi, nil_index_list(),
        multiply(stan::model::deep_copy(phi), sigma_phi),
        "assigning variable phi");
      current_statement__ = 3;
      current_statement__ = 3;
      check_greater_or_equal(function__, "sigma_phi", sigma_phi, 0);
      if (emit_transformed_parameters__) {
        vars__.emplace_back(sigma_phi);
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          vars__.emplace_back(phi[(sym1__ - 1)]);}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double beta0;
      beta0 = std::numeric_limits<double>::quiet_NaN();
      
      double beta1;
      beta1 = std::numeric_limits<double>::quiet_NaN();
      
      double tau_theta;
      tau_theta = std::numeric_limits<double>::quiet_NaN();
      
      double sigma_theta;
      sigma_theta = std::numeric_limits<double>::quiet_NaN();
      
      Eigen::Matrix<double, -1, 1> theta;
      theta = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(theta, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> theta_std;
      theta_std = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(theta_std, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> x;
      x = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(x, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<int> y;
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 16;
      beta0 = normal_rng(0, 1, base_rng__);
      current_statement__ = 17;
      beta1 = normal_rng(0, 1, base_rng__);
      current_statement__ = 20;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 18;
        assign(theta_std, cons_list(index_uni(i), nil_index_list()),
          normal_rng(0, 1, base_rng__), "assigning variable theta_std");}
      current_statement__ = 21;
      tau_theta = gamma_rng(3.2761, 1.81, base_rng__);
      current_statement__ = 22;
      sigma_theta = inv(stan::math::sqrt(tau_theta));
      current_statement__ = 23;
      assign(theta, nil_index_list(), multiply(theta_std, sigma_theta),
        "assigning variable theta");
      current_statement__ = 27;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 24;
        assign(x, cons_list(index_uni(i), nil_index_list()),
          normal_rng(0, 1, base_rng__), "assigning variable x");
        current_statement__ = 25;
        assign(y, cons_list(index_uni(i), nil_index_list()),
          poisson_log_rng(
            ((((log_E[(i - 1)] + beta0) + (beta1 * x[(i - 1)])) +
               phi[(i - 1)]) + theta[(i - 1)]), base_rng__),
          "assigning variable y");}
      current_statement__ = 10;
      current_statement__ = 10;
      check_greater_or_equal(function__, "tau_theta", tau_theta, 0);
      current_statement__ = 11;
      current_statement__ = 11;
      check_greater_or_equal(function__, "sigma_theta", sigma_theta, 0);
      vars__.emplace_back(beta0);
      vars__.emplace_back(beta1);
      vars__.emplace_back(tau_theta);
      vars__.emplace_back(sigma_theta);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(theta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(theta_std[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(x[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(y[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double tau_phi;
      tau_phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      tau_phi = context__.vals_r("tau_phi")[(1 - 1)];
      double tau_phi_free__;
      tau_phi_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      tau_phi_free__ = stan::math::lb_free(tau_phi, 0);
      Eigen::Matrix<double, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<double, -1, 1>(phi_std_raw_1dim__);
      stan::math::fill(phi_std_raw, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> phi_std_raw_flat__;
        current_statement__ = 2;
        assign(phi_std_raw_flat__, nil_index_list(),
          context__.vals_r("phi_std_raw"),
          "assigning variable phi_std_raw_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= phi_std_raw_1dim__; ++sym1__) {
          current_statement__ = 2;
          assign(phi_std_raw, cons_list(index_uni(sym1__), nil_index_list()),
            phi_std_raw_flat__[(pos__ - 1)], "assigning variable phi_std_raw");
          current_statement__ = 2;
          pos__ = (pos__ + 1);}
      }
      vars__.emplace_back(tau_phi_free__);
      for (int sym1__ = 1; sym1__ <= phi_std_raw_1dim__; ++sym1__) {
        vars__.emplace_back(phi_std_raw[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("tau_phi");
    names__.emplace_back("phi_std_raw");
    names__.emplace_back("sigma_phi");
    names__.emplace_back("phi");
    names__.emplace_back("beta0");
    names__.emplace_back("beta1");
    names__.emplace_back("tau_theta");
    names__.emplace_back("sigma_theta");
    names__.emplace_back("theta");
    names__.emplace_back("theta_std");
    names__.emplace_back("x");
    names__.emplace_back("y");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(phi_std_raw_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym1__ = 1; sym1__ <= phi_std_raw_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "beta0");
      param_names__.emplace_back(std::string() + "beta1");
      param_names__.emplace_back(std::string() + "tau_theta");
      param_names__.emplace_back(std::string() + "sigma_theta");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "theta_std" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym1__ = 1; sym1__ <= phi_std_raw_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "beta0");
      param_names__.emplace_back(std::string() + "beta1");
      param_names__.emplace_back(std::string() + "tau_theta");
      param_names__.emplace_back(std::string() + "sigma_theta");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "theta_std" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" << phi_std_raw_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"sigma_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" << phi_std_raw_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"sigma_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = expr_prop_fail4_model_namespace::expr_prop_fail4_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail4_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail5.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail5_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail5.stan', line 71, column 2 to column 33)",
                                                      " (in 'expr-prop-fail5.stan', line 72, column 2 to column 31)",
                                                      " (in 'expr-prop-fail5.stan', line 73, column 2 to column 23)",
                                                      " (in 'expr-prop-fail5.stan', line 74, column 2 to column 30)",
                                                      " (in 'expr-prop-fail5.stan', line 80, column 2 to column 51)",
                                                      " (in 'expr-prop-fail5.stan', line 81, column 2 to column 49)",
                                                      " (in 'expr-prop-fail5.stan', line 82, column 2 to column 49)",
                                                      " (in 'expr-prop-fail5.stan', line 83, column 2 to column 10)",
                                                      " (in 'expr-prop-fail5.stan', line 86, column 2 to column 23)",
                                                      " (in 'expr-prop-fail5.stan', line 89, column 6 to column 20)",
                                                      " (in 'expr-prop-fail5.stan', line 90, column 6 to column 18)",
                                                      " (in 'expr-prop-fail5.stan', line 88, column 32 to line 91, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 88, column 4 to line 91, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 93, column 6 to column 45)",
                                                      " (in 'expr-prop-fail5.stan', line 94, column 6 to column 23)",
                                                      " (in 'expr-prop-fail5.stan', line 92, column 38 to line 95, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 92, column 4 to line 95, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 87, column 20 to line 96, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 87, column 2 to line 96, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 98, column 2 to column 51)",
                                                      " (in 'expr-prop-fail5.stan', line 124, column 2 to column 23)",
                                                      " (in 'expr-prop-fail5.stan', line 126, column 2 to column 25)",
                                                      " (in 'expr-prop-fail5.stan', line 109, column 2 to column 29)",
                                                      " (in 'expr-prop-fail5.stan', line 115, column 8 to column 37)",
                                                      " (in 'expr-prop-fail5.stan', line 116, column 8 to column 41)",
                                                      " (in 'expr-prop-fail5.stan', line 114, column 40 to line 117, column 7)",
                                                      " (in 'expr-prop-fail5.stan', line 114, column 6 to line 117, column 7)",
                                                      " (in 'expr-prop-fail5.stan', line 118, column 6 to column 37)",
                                                      " (in 'expr-prop-fail5.stan', line 113, column 22 to line 119, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 113, column 4 to line 119, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 112, column 20 to line 120, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 112, column 2 to line 120, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 52, column 2 to column 20)",
                                                      " (in 'expr-prop-fail5.stan', line 53, column 2 to column 27)",
                                                      " (in 'expr-prop-fail5.stan', line 54, column 25 to column 29)",
                                                      " (in 'expr-prop-fail5.stan', line 54, column 31 to column 42)",
                                                      " (in 'expr-prop-fail5.stan', line 54, column 2 to column 44)",
                                                      " (in 'expr-prop-fail5.stan', line 58, column 2 to column 38)",
                                                      " (in 'expr-prop-fail5.stan', line 60, column 39 to column 43)",
                                                      " (in 'expr-prop-fail5.stan', line 60, column 2 to column 45)",
                                                      " (in 'expr-prop-fail5.stan', line 61, column 38 to column 42)",
                                                      " (in 'expr-prop-fail5.stan', line 61, column 2 to column 44)",
                                                      " (in 'expr-prop-fail5.stan', line 65, column 4 to column 35)",
                                                      " (in 'expr-prop-fail5.stan', line 64, column 2 to line 65, column 35)",
                                                      " (in 'expr-prop-fail5.stan', line 67, column 4 to column 33)",
                                                      " (in 'expr-prop-fail5.stan', line 66, column 2 to line 67, column 33)",
                                                      " (in 'expr-prop-fail5.stan', line 73, column 9 to column 13)",
                                                      " (in 'expr-prop-fail5.stan', line 80, column 26 to column 30)",
                                                      " (in 'expr-prop-fail5.stan', line 80, column 32 to column 45)",
                                                      " (in 'expr-prop-fail5.stan', line 81, column 26 to column 30)",
                                                      " (in 'expr-prop-fail5.stan', line 81, column 32 to column 45)",
                                                      " (in 'expr-prop-fail5.stan', line 82, column 26 to column 30)",
                                                      " (in 'expr-prop-fail5.stan', line 82, column 32 to column 43)",
                                                      " (in 'expr-prop-fail5.stan', line 8, column 8 to column 17)",
                                                      " (in 'expr-prop-fail5.stan', line 7, column 6 to line 8, column 17)",
                                                      " (in 'expr-prop-fail5.stan', line 6, column 4 to line 8, column 17)",
                                                      " (in 'expr-prop-fail5.stan', line 9, column 4 to column 13)",
                                                      " (in 'expr-prop-fail5.stan', line 5, column 31 to line 10, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 15, column 6 to column 32)",
                                                      " (in 'expr-prop-fail5.stan', line 19, column 8 to column 17)",
                                                      " (in 'expr-prop-fail5.stan', line 18, column 6 to line 19, column 17)",
                                                      " (in 'expr-prop-fail5.stan', line 13, column 37 to line 20, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 13, column 4 to line 20, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 21, column 4 to column 13)",
                                                      " (in 'expr-prop-fail5.stan', line 12, column 30 to line 22, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 26, column 11 to column 15)",
                                                      " (in 'expr-prop-fail5.stan', line 26, column 17 to column 28)",
                                                      " (in 'expr-prop-fail5.stan', line 26, column 4 to column 34)",
                                                      " (in 'expr-prop-fail5.stan', line 29, column 6 to column 32)",
                                                      " (in 'expr-prop-fail5.stan', line 32, column 8 to column 37)",
                                                      " (in 'expr-prop-fail5.stan', line 33, column 8 to column 32)",
                                                      " (in 'expr-prop-fail5.stan', line 41, column 8 to column 33)",
                                                      " (in 'expr-prop-fail5.stan', line 42, column 8 to column 28)",
                                                      " (in 'expr-prop-fail5.stan', line 43, column 8 to line 44, column 83)",
                                                      " (in 'expr-prop-fail5.stan', line 30, column 37 to line 45, column 7)",
                                                      " (in 'expr-prop-fail5.stan', line 30, column 6 to line 45, column 7)",
                                                      " (in 'expr-prop-fail5.stan', line 28, column 22 to line 46, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 28, column 4 to line 46, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 47, column 4 to column 15)",
                                                      " (in 'expr-prop-fail5.stan', line 25, column 47 to line 48, column 3)"};


int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 56;
    for (int k = 1; k <= size(y_i); ++k) {
      current_statement__ = 55;
      if (y_i[(k - 1)]) {
        current_statement__ = 54;
        return k;
      } }
    current_statement__ = 57;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 63;
    for (int k_rev = 0; k_rev <= (size(y_i) - 1); ++k_rev) {
      int k;
      k = std::numeric_limits<int>::min();
      
      current_statement__ = 59;
      k = (size(y_i) - k_rev);
      current_statement__ = 61;
      if (y_i[(k - 1)]) {
        current_statement__ = 60;
        return k;
      } }
    current_statement__ = 64;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 66;
    validate_non_negative_index("chi", "nind", nind);
    current_statement__ = 67;
    validate_non_negative_index("chi", "n_occasions", n_occasions);
    Eigen::Matrix<local_scalar_t__, -1, -1> chi;
    chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
    stan::math::fill(chi, DUMMY_VAR__);
    
    current_statement__ = 78;
    for (int i = 1; i <= nind; ++i) {
      current_statement__ = 69;
      assign(chi,
        cons_list(index_uni(i),
          cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
        "assigning variable chi");
      current_statement__ = 76;
      for (int t = 1; t <= (n_occasions - 1); ++t) {
        int t_curr;
        t_curr = std::numeric_limits<int>::min();
        
        current_statement__ = 70;
        t_curr = (n_occasions - t);
        int t_next;
        t_next = std::numeric_limits<int>::min();
        
        current_statement__ = 71;
        t_next = (t_curr + 1);
        current_statement__ = 72;
        t_curr = (n_occasions - t);
        current_statement__ = 73;
        t_next = (t_curr + 1);
        current_statement__ = 74;
        assign(chi,
          cons_list(index_uni(i),
            cons_list(index_uni(t_curr), nil_index_list())),
          ((1 -
             rvalue(phi,
               cons_list(index_uni(i),
                 cons_list(index_uni(t_curr), nil_index_list())), "phi")) +
            ((rvalue(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t_curr), nil_index_list())), "phi") *
               (1 -
                 rvalue(p,
                   cons_list(index_uni(i),
                     cons_list(index_uni((t_next - 1)), nil_index_list())),
                   "p"))) *
              rvalue(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t_next), nil_index_list())), "chi"))),
          "assigning variable chi");}}
    current_statement__ = 79;
    return chi;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct prob_uncaptured_functor__ {
template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
operator()(const int& nind, const int& n_occasions, const T2__& p,
           const T3__& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}
};

class expr_prop_fail5_model final : public model_base_crtp<expr_prop_fail5_model> {

 private:
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last;
 
 public:
  ~expr_prop_fail5_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail5_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail5_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail5_model_namespace::expr_prop_fail5_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 33;
      context__.validate_dims("data initialization","nind","int",
          context__.to_vec());
      nind = std::numeric_limits<int>::min();
      
      current_statement__ = 33;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 33;
      current_statement__ = 33;
      check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 34;
      context__.validate_dims("data initialization","n_occasions","int",
          context__.to_vec());
      n_occasions = std::numeric_limits<int>::min();
      
      current_statement__ = 34;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 34;
      current_statement__ = 34;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 2);
      current_statement__ = 35;
      validate_non_negative_index("y", "nind", nind);
      current_statement__ = 36;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 37;
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(nind, n_occasions));
      y = std::vector<std::vector<int>>(nind, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 37;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 37;
        pos__ = 1;
        current_statement__ = 37;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 37;
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            current_statement__ = 37;
            assign(y,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y_flat__[(pos__ - 1)], "assigning variable y");
            current_statement__ = 37;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 37;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 37;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 37;
          current_statement__ = 37;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 37;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 37;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 37;
          current_statement__ = 37;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 38;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      
      current_statement__ = 38;
      n_occ_minus_1 = (n_occasions - 1);
      current_statement__ = 39;
      validate_non_negative_index("first", "nind", nind);
      current_statement__ = 40;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 41;
      validate_non_negative_index("last", "nind", nind);
      current_statement__ = 42;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 44;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 43;
        assign(first, cons_list(index_uni(i), nil_index_list()),
          first_capture(y[(i - 1)], pstream__), "assigning variable first");}
      current_statement__ = 46;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 45;
        assign(last, cons_list(index_uni(i), nil_index_list()),
          last_capture(y[(i - 1)], pstream__), "assigning variable last");}
      current_statement__ = 40;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 40;
        current_statement__ = 40;
        check_greater_or_equal(function__, "first[sym1__]",
                               first[(sym1__ - 1)], 0);}
      current_statement__ = 40;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 40;
        current_statement__ = 40;
        check_less_or_equal(function__, "first[sym1__]", first[(sym1__ - 1)],
                            n_occasions);}
      current_statement__ = 42;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 42;
        current_statement__ = 42;
        check_greater_or_equal(function__, "last[sym1__]",
                               last[(sym1__ - 1)], 0);}
      current_statement__ = 42;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 42;
        current_statement__ = 42;
        check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                            n_occasions);}
      current_statement__ = 47;
      validate_non_negative_index("epsilon", "nind", nind);
      current_statement__ = 48;
      validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 49;
      validate_non_negative_index("phi", "n_occ_minus_1", n_occ_minus_1);
      current_statement__ = 50;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 51;
      validate_non_negative_index("p", "n_occ_minus_1", n_occ_minus_1);
      current_statement__ = 52;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 53;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += nind;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail5_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ mean_phi;
      mean_phi = DUMMY_VAR__;
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1, lp__);
      } else {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      }
      local_scalar_t__ mean_p;
      mean_p = DUMMY_VAR__;
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1, lp__);
      } else {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon;
      epsilon = Eigen::Matrix<local_scalar_t__, -1, 1>(nind);
      stan::math::fill(epsilon, DUMMY_VAR__);
      
      current_statement__ = 3;
      epsilon = in__.vector(nind);
      local_scalar_t__ sigma;
      sigma = DUMMY_VAR__;
      
      current_statement__ = 4;
      sigma = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        sigma = stan::math::lub_constrain(sigma, 0, 5, lp__);
      } else {
        current_statement__ = 4;
        sigma = stan::math::lub_constrain(sigma, 0, 5);
      }
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(p, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      local_scalar_t__ mu;
      mu = DUMMY_VAR__;
      
      current_statement__ = 9;
      mu = logit(mean_phi);
      current_statement__ = 19;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 13;
        for (int t = 1; t <= (first[(i - 1)] - 1); ++t) {
          current_statement__ = 10;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 11;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable p");}
        current_statement__ = 17;
        for (int t = first[(i - 1)]; t <= n_occ_minus_1; ++t) {
          current_statement__ = 14;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())),
            inv_logit((mu + epsilon[(i - 1)])), "assigning variable phi");
          current_statement__ = 15;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), mean_p,
            "assigning variable p");}}
      current_statement__ = 20;
      assign(chi, nil_index_list(),
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "phi"), 0);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "phi"), 1);}}
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 6;
          current_statement__ = 6;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "p"), 0);}}
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 6;
          current_statement__ = 6;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "p"), 1);}}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 7;
          current_statement__ = 7;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(chi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "chi"), 0);}}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 7;
          current_statement__ = 7;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(chi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "chi"), 1);}}
      {
        current_statement__ = 23;
        lp_accum__.add(normal_lpdf<propto__>(epsilon, 0, sigma));
        current_statement__ = 32;
        for (int i = 1; i <= nind; ++i) {
          current_statement__ = 30;
          if (logical_gt(first[(i - 1)], 0)) {
            current_statement__ = 27;
            for (int t = (first[(i - 1)] + 1); t <= last[(i - 1)]; ++t) {
              current_statement__ = 24;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni((t - 1)), nil_index_list())),
                    "phi")));
              current_statement__ = 25;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(y[(i - 1)][(t - 1)],
                  rvalue(p,
                    cons_list(index_uni(i),
                      cons_list(index_uni((t - 1)), nil_index_list())), "p")));
            }
            current_statement__ = 28;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(last[(i - 1)]), nil_index_list())),
                  "chi")));
          } }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail5_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double mean_phi;
      mean_phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      double mean_p;
      mean_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      Eigen::Matrix<double, -1, 1> epsilon;
      epsilon = Eigen::Matrix<double, -1, 1>(nind);
      stan::math::fill(epsilon, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      epsilon = in__.vector(nind);
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      sigma = in__.scalar();
      current_statement__ = 4;
      sigma = stan::math::lub_constrain(sigma, 0, 5);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(p, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      double mu;
      mu = std::numeric_limits<double>::quiet_NaN();
      
      vars__.emplace_back(mean_phi);
      vars__.emplace_back(mean_p);
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        vars__.emplace_back(epsilon[(sym1__ - 1)]);}
      vars__.emplace_back(sigma);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 9;
      mu = logit(mean_phi);
      current_statement__ = 19;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 13;
        for (int t = 1; t <= (first[(i - 1)] - 1); ++t) {
          current_statement__ = 10;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 11;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable p");}
        current_statement__ = 17;
        for (int t = first[(i - 1)]; t <= n_occ_minus_1; ++t) {
          current_statement__ = 14;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())),
            inv_logit((mu + epsilon[(i - 1)])), "assigning variable phi");
          current_statement__ = 15;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), mean_p,
            "assigning variable p");}}
      current_statement__ = 20;
      assign(chi, nil_index_list(),
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "phi"), 0);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "phi"), 1);}}
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 6;
          current_statement__ = 6;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "p"), 0);}}
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 6;
          current_statement__ = 6;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "p"), 1);}}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 7;
          current_statement__ = 7;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(chi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "chi"), 0);}}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 7;
          current_statement__ = 7;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(chi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "chi"), 1);}}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            vars__.emplace_back(
              rvalue(phi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "phi"));}}
        for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            vars__.emplace_back(
              rvalue(p,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "p"));}}
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            vars__.emplace_back(
              rvalue(chi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "chi"));}}
        vars__.emplace_back(mu);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double sigma2;
      sigma2 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 22;
      sigma2 = square(sigma);
      current_statement__ = 21;
      current_statement__ = 21;
      check_greater_or_equal(function__, "sigma2", sigma2, 0);
      vars__.emplace_back(sigma2);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double mean_phi;
      mean_phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_phi = context__.vals_r("mean_phi")[(1 - 1)];
      double mean_phi_free__;
      mean_phi_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_phi_free__ = stan::math::lub_free(mean_phi, 0, 1);
      double mean_p;
      mean_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      double mean_p_free__;
      mean_p_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      mean_p_free__ = stan::math::lub_free(mean_p, 0, 1);
      Eigen::Matrix<double, -1, 1> epsilon;
      epsilon = Eigen::Matrix<double, -1, 1>(nind);
      stan::math::fill(epsilon, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> epsilon_flat__;
        current_statement__ = 3;
        assign(epsilon_flat__, nil_index_list(), context__.vals_r("epsilon"),
          "assigning variable epsilon_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          assign(epsilon, cons_list(index_uni(sym1__), nil_index_list()),
            epsilon_flat__[(pos__ - 1)], "assigning variable epsilon");
          current_statement__ = 3;
          pos__ = (pos__ + 1);}
      }
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      double sigma_free__;
      sigma_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      sigma_free__ = stan::math::lub_free(sigma, 0, 5);
      vars__.emplace_back(mean_phi_free__);
      vars__.emplace_back(mean_p_free__);
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        vars__.emplace_back(epsilon[(sym1__ - 1)]);}
      vars__.emplace_back(sigma_free__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("mean_phi");
    names__.emplace_back("mean_p");
    names__.emplace_back("epsilon");
    names__.emplace_back("sigma");
    names__.emplace_back("phi");
    names__.emplace_back("p");
    names__.emplace_back("chi");
    names__.emplace_back("mu");
    names__.emplace_back("sigma2");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind),
                                             static_cast<size_t>(n_occ_minus_1)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind),
                                             static_cast<size_t>(n_occ_minus_1)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind),
                                             static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      param_names__.emplace_back(std::string() + "mu");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      param_names__.emplace_back(std::string() + "mu");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" << nind << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" << nind << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = expr_prop_fail5_model_namespace::expr_prop_fail5_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail5_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail6.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail6_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail6.stan', line 163, column 2 to column 33)",
                                                      " (in 'expr-prop-fail6.stan', line 164, column 2 to column 31)",
                                                      " (in 'expr-prop-fail6.stan', line 165, column 2 to column 28)",
                                                      " (in 'expr-prop-fail6.stan', line 166, column 2 to column 36)",
                                                      " (in 'expr-prop-fail6.stan', line 167, column 2 to column 20)",
                                                      " (in 'expr-prop-fail6.stan', line 168, column 2 to column 30)",
                                                      " (in 'expr-prop-fail6.stan', line 174, column 2 to column 50)",
                                                      " (in 'expr-prop-fail6.stan', line 175, column 2 to column 44)",
                                                      " (in 'expr-prop-fail6.stan', line 176, column 2 to column 25)",
                                                      " (in 'expr-prop-fail6.stan', line 177, column 2 to column 42)",
                                                      " (in 'expr-prop-fail6.stan', line 178, column 2 to column 46)",
                                                      " (in 'expr-prop-fail6.stan', line 181, column 2 to column 49)",
                                                      " (in 'expr-prop-fail6.stan', line 183, column 4 to column 48)",
                                                      " (in 'expr-prop-fail6.stan', line 182, column 2 to line 183, column 48)",
                                                      " (in 'expr-prop-fail6.stan', line 188, column 2 to column 23)",
                                                      " (in 'expr-prop-fail6.stan', line 192, column 4 to column 22)",
                                                      " (in 'expr-prop-fail6.stan', line 194, column 4 to column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 196, column 6 to column 35)",
                                                      " (in 'expr-prop-fail6.stan', line 197, column 6 to column 27)",
                                                      " (in 'expr-prop-fail6.stan', line 195, column 35 to line 198, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 195, column 4 to line 198, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 199, column 4 to column 26)",
                                                      " (in 'expr-prop-fail6.stan', line 191, column 2 to line 200, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 203, column 2 to column 32)",
                                                      " (in 'expr-prop-fail6.stan', line 219, column 2 to column 23)",
                                                      " (in 'expr-prop-fail6.stan', line 220, column 2 to column 22)",
                                                      " (in 'expr-prop-fail6.stan', line 221, column 2 to column 30)",
                                                      " (in 'expr-prop-fail6.stan', line 222, column 2 to column 30)",
                                                      " (in 'expr-prop-fail6.stan', line 223, column 2 to column 41)",
                                                      " (in 'expr-prop-fail6.stan', line 225, column 2 to column 25)",
                                                      " (in 'expr-prop-fail6.stan', line 229, column 4 to column 14)",
                                                      " (in 'expr-prop-fail6.stan', line 238, column 6 to column 41)",
                                                      " (in 'expr-prop-fail6.stan', line 237, column 11 to line 239, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 231, column 6 to column 37)",
                                                      " (in 'expr-prop-fail6.stan', line 233, column 8 to column 34)",
                                                      " (in 'expr-prop-fail6.stan', line 234, column 8 to line 235, column 46)",
                                                      " (in 'expr-prop-fail6.stan', line 232, column 31 to line 236, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 232, column 6 to line 236, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 230, column 28 to line 237, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 230, column 4 to line 239, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 228, column 17 to line 240, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 228, column 2 to line 240, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 244, column 16 to column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 244, column 19 to column 30)",
                                                      " (in 'expr-prop-fail6.stan', line 244, column 4 to column 63)",
                                                      " (in 'expr-prop-fail6.stan', line 245, column 13 to column 14)",
                                                      " (in 'expr-prop-fail6.stan', line 245, column 4 to column 16)",
                                                      " (in 'expr-prop-fail6.stan', line 246, column 15 to column 16)",
                                                      " (in 'expr-prop-fail6.stan', line 246, column 4 to column 18)",
                                                      " (in 'expr-prop-fail6.stan', line 249, column 6 to column 36)",
                                                      " (in 'expr-prop-fail6.stan', line 252, column 8 to column 26)",
                                                      " (in 'expr-prop-fail6.stan', line 251, column 6 to line 252, column 26)",
                                                      " (in 'expr-prop-fail6.stan', line 248, column 19 to line 253, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 248, column 4 to line 253, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 255, column 6 to column 25)",
                                                      " (in 'expr-prop-fail6.stan', line 256, column 6 to column 31)",
                                                      " (in 'expr-prop-fail6.stan', line 254, column 29 to line 257, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 254, column 4 to line 257, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 259, column 6 to column 26)",
                                                      " (in 'expr-prop-fail6.stan', line 260, column 6 to column 32)",
                                                      " (in 'expr-prop-fail6.stan', line 258, column 19 to line 261, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 258, column 4 to line 261, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 262, column 4 to column 25)",
                                                      " (in 'expr-prop-fail6.stan', line 243, column 2 to line 263, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 211, column 2 to column 29)",
                                                      " (in 'expr-prop-fail6.stan', line 212, column 2 to column 21)",
                                                      " (in 'expr-prop-fail6.stan', line 215, column 2 to column 52)",
                                                      " (in 'expr-prop-fail6.stan', line 147, column 2 to column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 148, column 2 to column 27)",
                                                      " (in 'expr-prop-fail6.stan', line 149, column 25 to column 26)",
                                                      " (in 'expr-prop-fail6.stan', line 149, column 28 to column 39)",
                                                      " (in 'expr-prop-fail6.stan', line 149, column 2 to column 41)",
                                                      " (in 'expr-prop-fail6.stan', line 153, column 39 to column 40)",
                                                      " (in 'expr-prop-fail6.stan', line 153, column 2 to column 42)",
                                                      " (in 'expr-prop-fail6.stan', line 154, column 38 to column 39)",
                                                      " (in 'expr-prop-fail6.stan', line 154, column 2 to column 41)",
                                                      " (in 'expr-prop-fail6.stan', line 157, column 4 to column 35)",
                                                      " (in 'expr-prop-fail6.stan', line 156, column 2 to line 157, column 35)",
                                                      " (in 'expr-prop-fail6.stan', line 159, column 4 to column 33)",
                                                      " (in 'expr-prop-fail6.stan', line 158, column 2 to line 159, column 33)",
                                                      " (in 'expr-prop-fail6.stan', line 166, column 18 to column 29)",
                                                      " (in 'expr-prop-fail6.stan', line 167, column 9 to column 10)",
                                                      " (in 'expr-prop-fail6.stan', line 174, column 26 to column 27)",
                                                      " (in 'expr-prop-fail6.stan', line 174, column 29 to column 44)",
                                                      " (in 'expr-prop-fail6.stan', line 175, column 26 to column 27)",
                                                      " (in 'expr-prop-fail6.stan', line 175, column 29 to column 40)",
                                                      " (in 'expr-prop-fail6.stan', line 176, column 10 to column 21)",
                                                      " (in 'expr-prop-fail6.stan', line 177, column 26 to column 37)",
                                                      " (in 'expr-prop-fail6.stan', line 178, column 26 to column 27)",
                                                      " (in 'expr-prop-fail6.stan', line 178, column 29 to column 40)",
                                                      " (in 'expr-prop-fail6.stan', line 221, column 17 to column 28)",
                                                      " (in 'expr-prop-fail6.stan', line 222, column 17 to column 28)",
                                                      " (in 'expr-prop-fail6.stan', line 223, column 25 to column 26)",
                                                      " (in 'expr-prop-fail6.stan', line 223, column 28 to column 39)",
                                                      " (in 'expr-prop-fail6.stan', line 17, column 8 to column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 16, column 6 to line 17, column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 15, column 4 to line 17, column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 18, column 4 to column 13)",
                                                      " (in 'expr-prop-fail6.stan', line 14, column 31 to line 19, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 30, column 6 to column 32)",
                                                      " (in 'expr-prop-fail6.stan', line 33, column 8 to column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 32, column 6 to line 33, column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 29, column 37 to line 34, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 29, column 4 to line 34, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 35, column 4 to column 13)",
                                                      " (in 'expr-prop-fail6.stan', line 28, column 30 to line 36, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 49, column 4 to column 24)",
                                                      " (in 'expr-prop-fail6.stan', line 50, column 4 to column 30)",
                                                      " (in 'expr-prop-fail6.stan', line 51, column 11 to column 16)",
                                                      " (in 'expr-prop-fail6.stan', line 51, column 18 to column 29)",
                                                      " (in 'expr-prop-fail6.stan', line 51, column 4 to column 35)",
                                                      " (in 'expr-prop-fail6.stan', line 54, column 6 to column 32)",
                                                      " (in 'expr-prop-fail6.stan', line 56, column 8 to column 37)",
                                                      " (in 'expr-prop-fail6.stan', line 57, column 8 to column 32)",
                                                      " (in 'expr-prop-fail6.stan', line 59, column 8 to line 60, column 65)",
                                                      " (in 'expr-prop-fail6.stan', line 55, column 37 to line 61, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 55, column 6 to line 61, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 53, column 23 to line 62, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 53, column 4 to line 62, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 63, column 4 to column 15)",
                                                      " (in 'expr-prop-fail6.stan', line 48, column 47 to line 64, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 82, column 4 to column 27)",
                                                      " (in 'expr-prop-fail6.stan', line 83, column 4 to column 33)",
                                                      " (in 'expr-prop-fail6.stan', line 84, column 11 to column 22)",
                                                      " (in 'expr-prop-fail6.stan', line 84, column 4 to column 39)",
                                                      " (in 'expr-prop-fail6.stan', line 87, column 13 to column 24)",
                                                      " (in 'expr-prop-fail6.stan', line 87, column 6 to column 43)",
                                                      " (in 'expr-prop-fail6.stan', line 124, column 15 to column 28)",
                                                      " (in 'expr-prop-fail6.stan', line 124, column 8 to column 33)",
                                                      " (in 'expr-prop-fail6.stan', line 127, column 8 to line 130, column 47)",
                                                      " (in 'expr-prop-fail6.stan', line 133, column 10 to line 137, column 49)",
                                                      " (in 'expr-prop-fail6.stan', line 132, column 8 to line 137, column 49)",
                                                      " (in 'expr-prop-fail6.stan', line 139, column 8 to column 54)",
                                                      " (in 'expr-prop-fail6.stan', line 140, column 8 to column 34)",
                                                      " (in 'expr-prop-fail6.stan', line 123, column 13 to line 141, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 91, column 8 to column 27)",
                                                      " (in 'expr-prop-fail6.stan', line 97, column 17 to column 25)",
                                                      " (in 'expr-prop-fail6.stan', line 97, column 10 to column 30)",
                                                      " (in 'expr-prop-fail6.stan', line 100, column 10 to line 103, column 54)",
                                                      " (in 'expr-prop-fail6.stan', line 106, column 12 to line 110, column 56)",
                                                      " (in 'expr-prop-fail6.stan', line 105, column 10 to line 110, column 56)",
                                                      " (in 'expr-prop-fail6.stan', line 111, column 10 to line 113, column 61)",
                                                      " (in 'expr-prop-fail6.stan', line 114, column 10 to column 36)",
                                                      " (in 'expr-prop-fail6.stan', line 96, column 15 to line 115, column 9)",
                                                      " (in 'expr-prop-fail6.stan', line 95, column 10 to column 41)",
                                                      " (in 'expr-prop-fail6.stan', line 94, column 27 to line 96, column 9)",
                                                      " (in 'expr-prop-fail6.stan', line 94, column 8 to line 115, column 9)",
                                                      " (in 'expr-prop-fail6.stan', line 118, column 10 to column 39)",
                                                      " (in 'expr-prop-fail6.stan', line 119, column 10 to column 39)",
                                                      " (in 'expr-prop-fail6.stan', line 117, column 42 to line 120, column 9)",
                                                      " (in 'expr-prop-fail6.stan', line 117, column 8 to line 120, column 9)",
                                                      " (in 'expr-prop-fail6.stan', line 122, column 8 to column 39)",
                                                      " (in 'expr-prop-fail6.stan', line 89, column 20 to line 123, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 89, column 6 to line 141, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 86, column 23 to line 142, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 86, column 4 to line 142, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 81, column 42 to line 143, column 3)"};


int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 97;
    for (int k = 1; k <= size(y_i); ++k) {
      current_statement__ = 96;
      if (y_i[(k - 1)]) {
        current_statement__ = 95;
        return k;
      } }
    current_statement__ = 98;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 104;
    for (int k_rev = 0; k_rev <= (size(y_i) - 1); ++k_rev) {
      int k;
      k = std::numeric_limits<int>::min();
      
      current_statement__ = 100;
      k = (size(y_i) - k_rev);
      current_statement__ = 102;
      if (y_i[(k - 1)]) {
        current_statement__ = 101;
        return k;
      } }
    current_statement__ = 105;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
stan::value_type_t<T1__>>, -1, -1>
prob_uncaptured(const T0__& p_arg__, const T1__& phi_arg__,
                std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>>;
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int n_ind;
    n_ind = std::numeric_limits<int>::min();
    
    current_statement__ = 107;
    n_ind = rows(p);
    int n_occasions;
    n_occasions = std::numeric_limits<int>::min();
    
    current_statement__ = 108;
    n_occasions = cols(p);
    current_statement__ = 109;
    validate_non_negative_index("chi", "n_ind", n_ind);
    current_statement__ = 110;
    validate_non_negative_index("chi", "n_occasions", n_occasions);
    Eigen::Matrix<local_scalar_t__, -1, -1> chi;
    chi = Eigen::Matrix<local_scalar_t__, -1, -1>(n_ind, n_occasions);
    stan::math::fill(chi, DUMMY_VAR__);
    
    current_statement__ = 119;
    for (int i = 1; i <= n_ind; ++i) {
      current_statement__ = 112;
      assign(chi,
        cons_list(index_uni(i),
          cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
        "assigning variable chi");
      current_statement__ = 117;
      for (int t = 1; t <= (n_occasions - 1); ++t) {
        int t_curr;
        t_curr = std::numeric_limits<int>::min();
        
        current_statement__ = 113;
        t_curr = (n_occasions - t);
        int t_next;
        t_next = std::numeric_limits<int>::min();
        
        current_statement__ = 114;
        t_next = (t_curr + 1);
        current_statement__ = 115;
        assign(chi,
          cons_list(index_uni(i),
            cons_list(index_uni(t_curr), nil_index_list())),
          ((1 -
             rvalue(phi,
               cons_list(index_uni(i),
                 cons_list(index_uni(t_curr), nil_index_list())), "phi")) +
            ((rvalue(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t_curr), nil_index_list())), "phi") *
               (1 -
                 rvalue(p,
                   cons_list(index_uni(i),
                     cons_list(index_uni(t_next), nil_index_list())), "p")))
              *
              rvalue(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t_next), nil_index_list())), "chi"))),
          "assigning variable chi");}}
    current_statement__ = 120;
    return chi;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct prob_uncaptured_functor__ {
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
stan::value_type_t<T1__>>, -1, -1>
operator()(const T0__& p, const T1__& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(p, phi, pstream__);
}
};

template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T7__, typename T_lp__, typename T_lp_accum__>
void
js_super_lp(const std::vector<std::vector<int>>& y,
            const std::vector<int>& first, const std::vector<int>& last,
            const T3__& p_arg__, const T4__& phi_arg__, const T5__& psi,
            const T6__& nu_arg__, const T7__& chi_arg__, T_lp__& lp__,
            T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T3__>,
          stan::value_type_t<T4__>,
          T5__,
          stan::value_type_t<T6__>,
          stan::value_type_t<T7__>>;
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  const auto& nu = to_ref(nu_arg__);
  const auto& chi = to_ref(chi_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int n_ind;
    n_ind = std::numeric_limits<int>::min();
    
    current_statement__ = 122;
    n_ind = dims(y)[(1 - 1)];
    int n_occasions;
    n_occasions = std::numeric_limits<int>::min();
    
    current_statement__ = 123;
    n_occasions = dims(y)[(2 - 1)];
    current_statement__ = 124;
    validate_non_negative_index("qnu", "n_occasions", n_occasions);
    Eigen::Matrix<local_scalar_t__, -1, 1> qnu;
    qnu = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
    stan::math::fill(qnu, DUMMY_VAR__);
    
    current_statement__ = 125;
    assign(qnu, nil_index_list(), subtract(1.0, nu), "assigning variable qnu");
    current_statement__ = 156;
    for (int i = 1; i <= n_ind; ++i) {
      current_statement__ = 126;
      validate_non_negative_index("qp", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> qp;
      qp = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(qp, DUMMY_VAR__);
      
      current_statement__ = 127;
      assign(qp, nil_index_list(),
        subtract(1.0,
          transpose(
            rvalue(p, cons_list(index_uni(i), nil_index_list()), "p"))),
        "assigning variable qp");
      current_statement__ = 154;
      if (first[(i - 1)]) {
        current_statement__ = 136;
        lp_accum__.add(bernoulli_lpmf<propto__>(1, psi));
        current_statement__ = 147;
        if (logical_eq(first[(i - 1)], 1)) {
          current_statement__ = 145;
          lp_accum__.add(
            bernoulli_lpmf<propto__>(1,
              (nu[(1 - 1)] *
                rvalue(p,
                  cons_list(index_uni(i),
                    cons_list(index_uni(1), nil_index_list())), "p"))));
        } else {
          current_statement__ = 137;
          validate_non_negative_index("lp", "first[i]", first[(i - 1)]);
          Eigen::Matrix<local_scalar_t__, -1, 1> lp;
          lp = Eigen::Matrix<local_scalar_t__, -1, 1>(first[(i - 1)]);
          stan::math::fill(lp, DUMMY_VAR__);
          
          current_statement__ = 139;
          assign(lp, cons_list(index_uni(1), nil_index_list()),
            (((bernoulli_lpmf<false>(1, nu[(1 - 1)]) +
                bernoulli_lpmf<false>(1,
                  prod(
                    rvalue(qp,
                      cons_list(index_min_max(1, (first[(i - 1)] - 1)),
                        nil_index_list()), "qp")))) +
               bernoulli_lpmf<false>(1,
                 prod(
                   rvalue(phi,
                     cons_list(index_uni(i),
                       cons_list(index_min_max(1, (first[(i - 1)] - 1)),
                         nil_index_list())), "phi")))) +
              bernoulli_lpmf<false>(1,
                rvalue(p,
                  cons_list(index_uni(i),
                    cons_list(index_uni(first[(i - 1)]), nil_index_list())),
                  "p"))), "assigning variable lp");
          current_statement__ = 141;
          for (int t = 2; t <= (first[(i - 1)] - 1); ++t) {
            current_statement__ = 140;
            assign(lp, cons_list(index_uni(t), nil_index_list()),
              ((((bernoulli_lpmf<false>(1,
                    prod(
                      rvalue(qnu,
                        cons_list(index_min_max(1, (t - 1)),
                          nil_index_list()), "qnu"))) +
                   bernoulli_lpmf<false>(1, nu[(t - 1)])) +
                  bernoulli_lpmf<false>(1,
                    prod(
                      rvalue(qp,
                        cons_list(index_min_max(t, (first[(i - 1)] - 1)),
                          nil_index_list()), "qp")))) +
                 bernoulli_lpmf<false>(1,
                   prod(
                     rvalue(phi,
                       cons_list(index_uni(i),
                         cons_list(index_min_max(t, (first[(i - 1)] - 1)),
                           nil_index_list())), "phi")))) +
                bernoulli_lpmf<false>(1,
                  rvalue(p,
                    cons_list(index_uni(i),
                      cons_list(index_uni(first[(i - 1)]), nil_index_list())),
                    "p"))), "assigning variable lp");}
          current_statement__ = 142;
          assign(lp, cons_list(index_uni(first[(i - 1)]), nil_index_list()),
            ((bernoulli_lpmf<false>(1,
                prod(
                  rvalue(qnu,
                    cons_list(index_min_max(1, (first[(i - 1)] - 1)),
                      nil_index_list()), "qnu"))) +
               bernoulli_lpmf<false>(1, nu[(first[(i - 1)] - 1)])) +
              bernoulli_lpmf<false>(1,
                rvalue(p,
                  cons_list(index_uni(i),
                    cons_list(index_uni(first[(i - 1)]), nil_index_list())),
                  "p"))), "assigning variable lp");
          current_statement__ = 143;
          lp_accum__.add(log_sum_exp(lp));
        }
        current_statement__ = 151;
        for (int t = (first[(i - 1)] + 1); t <= last[(i - 1)]; ++t) {
          current_statement__ = 148;
          lp_accum__.add(
            bernoulli_lpmf<propto__>(1,
              rvalue(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni((t - 1)), nil_index_list())), "phi")));
          current_statement__ = 149;
          lp_accum__.add(
            bernoulli_lpmf<propto__>(y[(i - 1)][(t - 1)],
              rvalue(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), "p")));}
        current_statement__ = 152;
        lp_accum__.add(
          bernoulli_lpmf<propto__>(1,
            rvalue(chi,
              cons_list(index_uni(i),
                cons_list(index_uni(last[(i - 1)]), nil_index_list())),
              "chi")));
      } else {
        current_statement__ = 128;
        validate_non_negative_index("lp", "n_occasions + 1",
                                    (n_occasions + 1));
        Eigen::Matrix<local_scalar_t__, -1, 1> lp;
        lp = Eigen::Matrix<local_scalar_t__, -1, 1>((n_occasions + 1));
        stan::math::fill(lp, DUMMY_VAR__);
        
        current_statement__ = 130;
        assign(lp, cons_list(index_uni(1), nil_index_list()),
          (((bernoulli_lpmf<false>(1, psi) +
              bernoulli_lpmf<false>(1, nu[(1 - 1)])) +
             bernoulli_lpmf<false>(0,
               rvalue(p,
                 cons_list(index_uni(i),
                   cons_list(index_uni(1), nil_index_list())), "p"))) +
            bernoulli_lpmf<false>(1,
              rvalue(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(1), nil_index_list())), "chi"))),
          "assigning variable lp");
        current_statement__ = 132;
        for (int t = 2; t <= n_occasions; ++t) {
          current_statement__ = 131;
          assign(lp, cons_list(index_uni(t), nil_index_list()),
            ((((bernoulli_lpmf<false>(1, psi) +
                 bernoulli_lpmf<false>(1,
                   prod(
                     rvalue(qnu,
                       cons_list(index_min_max(1, (t - 1)), nil_index_list()),
                       "qnu")))) + bernoulli_lpmf<false>(1, nu[(t - 1)])) +
               bernoulli_lpmf<false>(0,
                 rvalue(p,
                   cons_list(index_uni(i),
                     cons_list(index_uni(t), nil_index_list())), "p"))) +
              bernoulli_lpmf<false>(1,
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(t), nil_index_list())), "chi"))),
            "assigning variable lp");}
        current_statement__ = 133;
        assign(lp, cons_list(index_uni((n_occasions + 1)), nil_index_list()),
          bernoulli_lpmf<false>(0, psi), "assigning variable lp");
        current_statement__ = 134;
        lp_accum__.add(log_sum_exp(lp));
      }}
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct js_super_lp_functor__ {
template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T7__, typename T_lp__, typename T_lp_accum__>
void
operator()(const std::vector<std::vector<int>>& y,
           const std::vector<int>& first, const std::vector<int>& last,
           const T3__& p, const T4__& phi, const T5__& psi, const T6__& nu,
           const T7__& chi, T_lp__& lp__, T_lp_accum__& lp_accum__,
           std::ostream* pstream__)  const 
{
return js_super_lp<propto__>(y, first, last, p, phi, psi, nu, chi, lp__,
         lp_accum__, pstream__);
}
};

class expr_prop_fail6_model final : public model_base_crtp<expr_prop_fail6_model> {

 private:
  int M;
  int n_occasions;
  std::vector<std::vector<int>> y;
  std::vector<int> first;
  std::vector<int> last;
  int phi_2dim__;
 
 public:
  ~expr_prop_fail6_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail6_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail6_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail6_model_namespace::expr_prop_fail6_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 68;
      context__.validate_dims("data initialization","M","int",
          context__.to_vec());
      M = std::numeric_limits<int>::min();
      
      current_statement__ = 68;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 68;
      current_statement__ = 68;
      check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 69;
      context__.validate_dims("data initialization","n_occasions","int",
          context__.to_vec());
      n_occasions = std::numeric_limits<int>::min();
      
      current_statement__ = 69;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 69;
      current_statement__ = 69;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 0);
      current_statement__ = 70;
      validate_non_negative_index("y", "M", M);
      current_statement__ = 71;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 72;
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(M, n_occasions));
      y = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 72;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 72;
        pos__ = 1;
        current_statement__ = 72;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 72;
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            current_statement__ = 72;
            assign(y,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y_flat__[(pos__ - 1)], "assigning variable y");
            current_statement__ = 72;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 72;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 72;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 72;
          current_statement__ = 72;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 72;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 72;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 72;
          current_statement__ = 72;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 73;
      validate_non_negative_index("first", "M", M);
      current_statement__ = 74;
      first = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 75;
      validate_non_negative_index("last", "M", M);
      current_statement__ = 76;
      last = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 78;
      for (int i = 1; i <= M; ++i) {
        current_statement__ = 77;
        assign(first, cons_list(index_uni(i), nil_index_list()),
          first_capture(y[(i - 1)], pstream__), "assigning variable first");}
      current_statement__ = 80;
      for (int i = 1; i <= M; ++i) {
        current_statement__ = 79;
        assign(last, cons_list(index_uni(i), nil_index_list()),
          last_capture(y[(i - 1)], pstream__), "assigning variable last");}
      current_statement__ = 74;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 74;
        current_statement__ = 74;
        check_greater_or_equal(function__, "first[sym1__]",
                               first[(sym1__ - 1)], 0);}
      current_statement__ = 74;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 74;
        current_statement__ = 74;
        check_less_or_equal(function__, "first[sym1__]", first[(sym1__ - 1)],
                            n_occasions);}
      current_statement__ = 76;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 76;
        current_statement__ = 76;
        check_greater_or_equal(function__, "last[sym1__]",
                               last[(sym1__ - 1)], 0);}
      current_statement__ = 76;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 76;
        current_statement__ = 76;
        check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                            n_occasions);}
      current_statement__ = 81;
      validate_non_negative_index("beta", "n_occasions", n_occasions);
      current_statement__ = 82;
      validate_non_negative_index("epsilon", "M", M);
      current_statement__ = 83;
      validate_non_negative_index("phi", "M", M);
      current_statement__ = 84;
      phi_2dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 84;
      phi_2dim__ = (n_occasions - 1);
      current_statement__ = 84;
      validate_non_negative_index("phi", "n_occasions - 1", phi_2dim__);
      current_statement__ = 85;
      validate_non_negative_index("p", "M", M);
      current_statement__ = 86;
      validate_non_negative_index("p", "n_occasions", n_occasions);
      current_statement__ = 87;
      validate_non_negative_index("b", "n_occasions", n_occasions);
      current_statement__ = 88;
      validate_non_negative_index("nu", "n_occasions", n_occasions);
      current_statement__ = 89;
      validate_non_negative_index("chi", "M", M);
      current_statement__ = 90;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      current_statement__ = 91;
      validate_non_negative_index("N", "n_occasions", n_occasions);
      current_statement__ = 92;
      validate_non_negative_index("B", "n_occasions", n_occasions);
      current_statement__ = 93;
      validate_non_negative_index("z", "M", M);
      current_statement__ = 94;
      validate_non_negative_index("z", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += n_occasions;
      num_params_r__ += M;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail6_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ mean_phi;
      mean_phi = DUMMY_VAR__;
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1, lp__);
      } else {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      }
      local_scalar_t__ mean_p;
      mean_p = DUMMY_VAR__;
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1, lp__);
      } else {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      }
      local_scalar_t__ psi;
      psi = DUMMY_VAR__;
      
      current_statement__ = 3;
      psi = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        psi = stan::math::lub_constrain(psi, 0, 1, lp__);
      } else {
        current_statement__ = 3;
        psi = stan::math::lub_constrain(psi, 0, 1);
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(beta, DUMMY_VAR__);
      
      current_statement__ = 4;
      beta = in__.vector(n_occasions);
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        current_statement__ = 4;
        if (jacobian__) {
          current_statement__ = 4;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(beta[(sym1__ - 1)], 0, lp__),
            "assigning variable beta");
        } else {
          current_statement__ = 4;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(beta[(sym1__ - 1)], 0),
            "assigning variable beta");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon;
      epsilon = Eigen::Matrix<local_scalar_t__, -1, 1>(M);
      stan::math::fill(epsilon, DUMMY_VAR__);
      
      current_statement__ = 5;
      epsilon = in__.vector(M);
      local_scalar_t__ sigma;
      sigma = DUMMY_VAR__;
      
      current_statement__ = 6;
      sigma = in__.scalar();
      current_statement__ = 6;
      if (jacobian__) {
        current_statement__ = 6;
        sigma = stan::math::lub_constrain(sigma, 0, 5, lp__);
      } else {
        current_statement__ = 6;
        sigma = stan::math::lub_constrain(sigma, 0, 5);
      }
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, phi_2dim__);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      stan::math::fill(p, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> b;
      b = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(b, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> nu;
      nu = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(nu, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      current_statement__ = 12;
      assign(phi, nil_index_list(),
        rep_matrix(mean_phi, M, (n_occasions - 1)), "assigning variable phi");
      current_statement__ = 14;
      for (int t = 1; t <= n_occasions; ++t) {
        current_statement__ = 13;
        assign(p,
          cons_list(index_omni(), cons_list(index_uni(t), nil_index_list())),
          inv_logit(add(logit(mean_p), epsilon)), "assigning variable p");}
      current_statement__ = 15;
      assign(b, nil_index_list(), divide(beta, sum(beta)),
        "assigning variable b");
      {
        local_scalar_t__ cum_b;
        cum_b = DUMMY_VAR__;
        
        current_statement__ = 16;
        cum_b = b[(1 - 1)];
        current_statement__ = 17;
        assign(nu, cons_list(index_uni(1), nil_index_list()), b[(1 - 1)],
          "assigning variable nu");
        current_statement__ = 21;
        for (int t = 2; t <= (n_occasions - 1); ++t) {
          current_statement__ = 18;
          assign(nu, cons_list(index_uni(t), nil_index_list()),
            (b[(t - 1)] / (1.0 - cum_b)), "assigning variable nu");
          current_statement__ = 19;
          cum_b = (cum_b + b[(t - 1)]);}
        current_statement__ = 22;
        assign(nu, cons_list(index_uni(n_occasions), nil_index_list()), 1.0,
          "assigning variable nu");
      }
      current_statement__ = 24;
      assign(chi, nil_index_list(), prob_uncaptured(p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= phi_2dim__; ++sym2__) {
          current_statement__ = 7;
          current_statement__ = 7;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "phi"), 0);}}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= phi_2dim__; ++sym2__) {
          current_statement__ = 7;
          current_statement__ = 7;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "phi"), 1);}}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 8;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 8;
          current_statement__ = 8;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "p"), 0);}}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 8;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 8;
          current_statement__ = 8;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "p"), 1);}}
      current_statement__ = 9;
      current_statement__ = 9;
      check_simplex(function__, "b", b);
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        current_statement__ = 10;
        current_statement__ = 10;
        check_greater_or_equal(function__, "nu[sym1__]", nu[(sym1__ - 1)], 0);
      }
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        current_statement__ = 10;
        current_statement__ = 10;
        check_less_or_equal(function__, "nu[sym1__]", nu[(sym1__ - 1)], 1);}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 11;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 11;
          current_statement__ = 11;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(chi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "chi"), 0);}}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 11;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 11;
          current_statement__ = 11;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(chi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "chi"), 1);}}
      {
        current_statement__ = 65;
        lp_accum__.add(normal_lpdf<propto__>(epsilon, 0, sigma));
        current_statement__ = 66;
        lp_accum__.add(gamma_lpdf<propto__>(beta, 1, 1));
        current_statement__ = 67;
        js_super_lp<false>(y, first, last, p, phi, psi, nu,
          chi, lp__, lp_accum__, pstream__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail6_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double mean_phi;
      mean_phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      double mean_p;
      mean_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      double psi;
      psi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      psi = in__.scalar();
      current_statement__ = 3;
      psi = stan::math::lub_constrain(psi, 0, 1);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(n_occasions);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      beta = in__.vector(n_occasions);
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        current_statement__ = 4;
        assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(beta[(sym1__ - 1)], 0),
          "assigning variable beta");}
      Eigen::Matrix<double, -1, 1> epsilon;
      epsilon = Eigen::Matrix<double, -1, 1>(M);
      stan::math::fill(epsilon, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      epsilon = in__.vector(M);
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      sigma = in__.scalar();
      current_statement__ = 6;
      sigma = stan::math::lub_constrain(sigma, 0, 5);
      Eigen::Matrix<double, -1, -1> phi;
      phi = Eigen::Matrix<double, -1, -1>(M, phi_2dim__);
      stan::math::fill(phi, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(M, n_occasions);
      stan::math::fill(p, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> b;
      b = Eigen::Matrix<double, -1, 1>(n_occasions);
      stan::math::fill(b, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, 1> nu;
      nu = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(nu, DUMMY_VAR__);
      
      Eigen::Matrix<double, -1, -1> chi;
      chi = Eigen::Matrix<double, -1, -1>(M, n_occasions);
      stan::math::fill(chi, std::numeric_limits<double>::quiet_NaN());
      
      vars__.emplace_back(mean_phi);
      vars__.emplace_back(mean_p);
      vars__.emplace_back(psi);
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        vars__.emplace_back(beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        vars__.emplace_back(epsilon[(sym1__ - 1)]);}
      vars__.emplace_back(sigma);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 12;
      assign(phi, nil_index_list(),
        rep_matrix(mean_phi, M, (n_occasions - 1)), "assigning variable phi");
      current_statement__ = 14;
      for (int t = 1; t <= n_occasions; ++t) {
        current_statement__ = 13;
        assign(p,
          cons_list(index_omni(), cons_list(index_uni(t), nil_index_list())),
          inv_logit(add(logit(mean_p), epsilon)), "assigning variable p");}
      current_statement__ = 15;
      assign(b, nil_index_list(), divide(beta, sum(beta)),
        "assigning variable b");
      {
        local_scalar_t__ cum_b;
        cum_b = DUMMY_VAR__;
        
        current_statement__ = 16;
        cum_b = b[(1 - 1)];
        current_statement__ = 17;
        assign(nu, cons_list(index_uni(1), nil_index_list()), b[(1 - 1)],
          "assigning variable nu");
        current_statement__ = 21;
        for (int t = 2; t <= (n_occasions - 1); ++t) {
          current_statement__ = 18;
          assign(nu, cons_list(index_uni(t), nil_index_list()),
            (b[(t - 1)] / (1.0 - cum_b)), "assigning variable nu");
          current_statement__ = 19;
          cum_b = (cum_b + b[(t - 1)]);}
        current_statement__ = 22;
        assign(nu, cons_list(index_uni(n_occasions), nil_index_list()), 1.0,
          "assigning variable nu");
      }
      current_statement__ = 24;
      assign(chi, nil_index_list(), prob_uncaptured(p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= phi_2dim__; ++sym2__) {
          current_statement__ = 7;
          current_statement__ = 7;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "phi"), 0);}}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= phi_2dim__; ++sym2__) {
          current_statement__ = 7;
          current_statement__ = 7;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "phi"), 1);}}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 8;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 8;
          current_statement__ = 8;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "p"), 0);}}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 8;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 8;
          current_statement__ = 8;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "p"), 1);}}
      current_statement__ = 9;
      current_statement__ = 9;
      check_simplex(function__, "b", b);
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        current_statement__ = 10;
        current_statement__ = 10;
        check_greater_or_equal(function__, "nu[sym1__]", nu[(sym1__ - 1)], 0);
      }
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        current_statement__ = 10;
        current_statement__ = 10;
        check_less_or_equal(function__, "nu[sym1__]", nu[(sym1__ - 1)], 1);}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 11;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 11;
          current_statement__ = 11;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(chi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "chi"), 0);}}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 11;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 11;
          current_statement__ = 11;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(chi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "chi"), 1);}}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= phi_2dim__; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            vars__.emplace_back(
              rvalue(phi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "phi"));}}
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            vars__.emplace_back(
              rvalue(p,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "p"));}}
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          vars__.emplace_back(b[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          vars__.emplace_back(nu[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            vars__.emplace_back(
              rvalue(chi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "chi"));}}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double sigma2;
      sigma2 = std::numeric_limits<double>::quiet_NaN();
      
      int Nsuper;
      Nsuper = std::numeric_limits<int>::min();
      
      std::vector<int> N;
      N = std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      
      std::vector<int> B;
      B = std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      
      std::vector<std::vector<int>> z;
      z = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      current_statement__ = 30;
      sigma2 = square(sigma);
      current_statement__ = 42;
      for (int i = 1; i <= M; ++i) {
        int q;
        q = std::numeric_limits<int>::min();
        
        current_statement__ = 31;
        q = 1;
        current_statement__ = 40;
        if (bernoulli_rng(psi, base_rng__)) {
          current_statement__ = 34;
          assign(z,
            cons_list(index_uni(i),
              cons_list(index_uni(1), nil_index_list())),
            bernoulli_rng(nu[(1 - 1)], base_rng__), "assigning variable z");
          current_statement__ = 38;
          for (int t = 2; t <= n_occasions; ++t) {
            current_statement__ = 35;
            q = (q * (1 - z[(i - 1)][((t - 1) - 1)]));
            current_statement__ = 36;
            assign(z,
              cons_list(index_uni(i),
                cons_list(index_uni(t), nil_index_list())),
              bernoulli_rng(
                ((z[(i - 1)][((t - 1) - 1)] *
                   rvalue(phi,
                     cons_list(index_uni(i),
                       cons_list(index_uni((t - 1)), nil_index_list())),
                     "phi")) + (q * nu[(t - 1)])), base_rng__),
              "assigning variable z");}
        } else {
          current_statement__ = 32;
          assign(z,
            cons_list(index_uni(i),
              cons_list(index_omni(), nil_index_list())),
            rep_array(0, n_occasions), "assigning variable z");
        }}
      {
        current_statement__ = 43;
        validate_non_negative_index("recruit", "M", M);
        current_statement__ = 44;
        validate_non_negative_index("recruit", "n_occasions", n_occasions);
        std::vector<std::vector<int>> recruit;
        recruit = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
        
        current_statement__ = 45;
        assign(recruit, nil_index_list(), rep_array(0, M, n_occasions),
          "assigning variable recruit");
        current_statement__ = 46;
        validate_non_negative_index("Nind", "M", M);
        std::vector<int> Nind;
        Nind = std::vector<int>(M, std::numeric_limits<int>::min());
        
        current_statement__ = 48;
        validate_non_negative_index("Nalive", "M", M);
        std::vector<int> Nalive;
        Nalive = std::vector<int>(M, std::numeric_limits<int>::min());
        
        current_statement__ = 54;
        for (int i = 1; i <= M; ++i) {
          int f;
          f = std::numeric_limits<int>::min();
          
          current_statement__ = 50;
          f = first_capture(
                rvalue(z,
                  cons_list(index_uni(i),
                    cons_list(index_omni(), nil_index_list())), "z"), pstream__);
          current_statement__ = 52;
          if (logical_gt(f, 0)) {
            current_statement__ = 51;
            assign(recruit,
              cons_list(index_uni(i),
                cons_list(index_uni(f), nil_index_list())), 1,
              "assigning variable recruit");
          } }
        current_statement__ = 58;
        for (int t = 1; t <= n_occasions; ++t) {
          current_statement__ = 55;
          assign(N, cons_list(index_uni(t), nil_index_list()),
            sum(
              rvalue(z,
                cons_list(index_omni(),
                  cons_list(index_uni(t), nil_index_list())), "z")),
            "assigning variable N");
          current_statement__ = 56;
          assign(B, cons_list(index_uni(t), nil_index_list()),
            sum(
              rvalue(recruit,
                cons_list(index_omni(),
                  cons_list(index_uni(t), nil_index_list())), "recruit")),
            "assigning variable B");}
        current_statement__ = 62;
        for (int i = 1; i <= M; ++i) {
          current_statement__ = 59;
          assign(Nind, cons_list(index_uni(i), nil_index_list()),
            sum(z[(i - 1)]), "assigning variable Nind");
          current_statement__ = 60;
          assign(Nalive, cons_list(index_uni(i), nil_index_list()),
            logical_gt(Nind[(i - 1)], 0), "assigning variable Nalive");}
        current_statement__ = 63;
        Nsuper = sum(Nalive);
      }
      current_statement__ = 25;
      current_statement__ = 25;
      check_greater_or_equal(function__, "sigma2", sigma2, 0);
      current_statement__ = 26;
      current_statement__ = 26;
      check_greater_or_equal(function__, "Nsuper", Nsuper, 0);
      current_statement__ = 27;
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        current_statement__ = 27;
        current_statement__ = 27;
        check_greater_or_equal(function__, "N[sym1__]", N[(sym1__ - 1)], 0);}
      current_statement__ = 28;
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        current_statement__ = 28;
        current_statement__ = 28;
        check_greater_or_equal(function__, "B[sym1__]", B[(sym1__ - 1)], 0);}
      current_statement__ = 29;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 29;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 29;
          current_statement__ = 29;
          check_greater_or_equal(function__, "z[sym1__, sym2__]",
                                 z[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 29;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 29;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 29;
          current_statement__ = 29;
          check_less_or_equal(function__, "z[sym1__, sym2__]",
                              z[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      vars__.emplace_back(sigma2);
      vars__.emplace_back(Nsuper);
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        vars__.emplace_back(N[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        vars__.emplace_back(B[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          vars__.emplace_back(z[(sym2__ - 1)][(sym1__ - 1)]);}}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double mean_phi;
      mean_phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_phi = context__.vals_r("mean_phi")[(1 - 1)];
      double mean_phi_free__;
      mean_phi_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_phi_free__ = stan::math::lub_free(mean_phi, 0, 1);
      double mean_p;
      mean_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      double mean_p_free__;
      mean_p_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      mean_p_free__ = stan::math::lub_free(mean_p, 0, 1);
      double psi;
      psi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      psi = context__.vals_r("psi")[(1 - 1)];
      double psi_free__;
      psi_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      psi_free__ = stan::math::lub_free(psi, 0, 1);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(n_occasions);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 4;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 4;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            beta_flat__[(pos__ - 1)], "assigning variable beta");
          current_statement__ = 4;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> beta_free__;
      beta_free__ = Eigen::Matrix<double, -1, 1>(n_occasions);
      stan::math::fill(beta_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        current_statement__ = 4;
        assign(beta_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(beta[(sym1__ - 1)], 0),
          "assigning variable beta_free__");}
      Eigen::Matrix<double, -1, 1> epsilon;
      epsilon = Eigen::Matrix<double, -1, 1>(M);
      stan::math::fill(epsilon, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> epsilon_flat__;
        current_statement__ = 5;
        assign(epsilon_flat__, nil_index_list(), context__.vals_r("epsilon"),
          "assigning variable epsilon_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          current_statement__ = 5;
          assign(epsilon, cons_list(index_uni(sym1__), nil_index_list()),
            epsilon_flat__[(pos__ - 1)], "assigning variable epsilon");
          current_statement__ = 5;
          pos__ = (pos__ + 1);}
      }
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      double sigma_free__;
      sigma_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      sigma_free__ = stan::math::lub_free(sigma, 0, 5);
      vars__.emplace_back(mean_phi_free__);
      vars__.emplace_back(mean_p_free__);
      vars__.emplace_back(psi_free__);
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        vars__.emplace_back(beta_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        vars__.emplace_back(epsilon[(sym1__ - 1)]);}
      vars__.emplace_back(sigma_free__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("mean_phi");
    names__.emplace_back("mean_p");
    names__.emplace_back("psi");
    names__.emplace_back("beta");
    names__.emplace_back("epsilon");
    names__.emplace_back("sigma");
    names__.emplace_back("phi");
    names__.emplace_back("p");
    names__.emplace_back("b");
    names__.emplace_back("nu");
    names__.emplace_back("chi");
    names__.emplace_back("sigma2");
    names__.emplace_back("Nsuper");
    names__.emplace_back("N");
    names__.emplace_back("B");
    names__.emplace_back("z");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(phi_2dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(n_occasions)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    param_names__.emplace_back(std::string() + "psi");
    for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= phi_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "nu" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "N" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "B" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    param_names__.emplace_back(std::string() + "psi");
    for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= phi_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= (n_occasions - 1); ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "nu" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "N" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "B" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" << M << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << phi_2dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"nu\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" << M << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << phi_2dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << (n_occasions - 1) << "},\"block\":\"transformed_parameters\"},{\"name\":\"nu\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = expr_prop_fail6_model_namespace::expr_prop_fail6_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail6_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail7.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail7_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail7.stan', line 20, column 2 to column 16)",
                                                      " (in 'expr-prop-fail7.stan', line 21, column 2 to column 24)",
                                                      " (in 'expr-prop-fail7.stan', line 40, column 2 to column 24)",
                                                      " (in 'expr-prop-fail7.stan', line 42, column 11 to column 12)",
                                                      " (in 'expr-prop-fail7.stan', line 42, column 4 to column 30)",
                                                      " (in 'expr-prop-fail7.stan', line 44, column 6 to column 51)",
                                                      " (in 'expr-prop-fail7.stan', line 43, column 4 to line 44, column 51)",
                                                      " (in 'expr-prop-fail7.stan', line 45, column 4 to column 45)",
                                                      " (in 'expr-prop-fail7.stan', line 41, column 17 to line 46, column 3)",
                                                      " (in 'expr-prop-fail7.stan', line 41, column 2 to line 46, column 3)",
                                                      " (in 'expr-prop-fail7.stan', line 25, column 2 to column 24)",
                                                      " (in 'expr-prop-fail7.stan', line 28, column 6 to column 39)",
                                                      " (in 'expr-prop-fail7.stan', line 27, column 4 to line 28, column 39)",
                                                      " (in 'expr-prop-fail7.stan', line 26, column 2 to line 28, column 39)",
                                                      " (in 'expr-prop-fail7.stan', line 32, column 11 to column 12)",
                                                      " (in 'expr-prop-fail7.stan', line 32, column 4 to column 30)",
                                                      " (in 'expr-prop-fail7.stan', line 34, column 6 to column 51)",
                                                      " (in 'expr-prop-fail7.stan', line 33, column 4 to line 34, column 51)",
                                                      " (in 'expr-prop-fail7.stan', line 35, column 4 to column 33)",
                                                      " (in 'expr-prop-fail7.stan', line 31, column 17 to line 36, column 3)",
                                                      " (in 'expr-prop-fail7.stan', line 31, column 2 to line 36, column 3)",
                                                      " (in 'expr-prop-fail7.stan', line 12, column 2 to column 17)",
                                                      " (in 'expr-prop-fail7.stan', line 13, column 2 to column 17)",
                                                      " (in 'expr-prop-fail7.stan', line 14, column 2 to column 17)",
                                                      " (in 'expr-prop-fail7.stan', line 15, column 25 to column 26)",
                                                      " (in 'expr-prop-fail7.stan', line 15, column 27 to column 28)",
                                                      " (in 'expr-prop-fail7.stan', line 15, column 2 to column 30)",
                                                      " (in 'expr-prop-fail7.stan', line 16, column 18 to column 19)",
                                                      " (in 'expr-prop-fail7.stan', line 16, column 2 to column 27)",
                                                      " (in 'expr-prop-fail7.stan', line 17, column 26 to column 27)",
                                                      " (in 'expr-prop-fail7.stan', line 17, column 18 to column 19)",
                                                      " (in 'expr-prop-fail7.stan', line 17, column 2 to column 29)",
                                                      " (in 'expr-prop-fail7.stan', line 20, column 10 to column 11)",
                                                      " (in 'expr-prop-fail7.stan', line 21, column 19 to column 20)",
                                                      " (in 'expr-prop-fail7.stan', line 21, column 21 to column 22)",
                                                      " (in 'expr-prop-fail7.stan', line 21, column 10 to column 11)",
                                                      " (in 'expr-prop-fail7.stan', line 40, column 21 to column 22)",
                                                      " (in 'expr-prop-fail7.stan', line 40, column 9 to column 10)"};



class expr_prop_fail7_model final : public model_base_crtp<expr_prop_fail7_model> {

 private:
  int K;
  int I;
  int J;
  std::vector<std::vector<int>> y;
  Eigen::Matrix<double, -1, 1> alpha;
  std::vector<Eigen::Matrix<double, -1, 1>> beta;
 
 public:
  ~expr_prop_fail7_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail7_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail7_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail7_model_namespace::expr_prop_fail7_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 22;
      context__.validate_dims("data initialization","K","int",
          context__.to_vec());
      K = std::numeric_limits<int>::min();
      
      current_statement__ = 22;
      K = context__.vals_i("K")[(1 - 1)];
      current_statement__ = 22;
      current_statement__ = 22;
      check_greater_or_equal(function__, "K", K, 2);
      current_statement__ = 23;
      context__.validate_dims("data initialization","I","int",
          context__.to_vec());
      I = std::numeric_limits<int>::min();
      
      current_statement__ = 23;
      I = context__.vals_i("I")[(1 - 1)];
      current_statement__ = 23;
      current_statement__ = 23;
      check_greater_or_equal(function__, "I", I, 1);
      current_statement__ = 24;
      context__.validate_dims("data initialization","J","int",
          context__.to_vec());
      J = std::numeric_limits<int>::min();
      
      current_statement__ = 24;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 24;
      current_statement__ = 24;
      check_greater_or_equal(function__, "J", J, 1);
      current_statement__ = 25;
      validate_non_negative_index("y", "I", I);
      current_statement__ = 26;
      validate_non_negative_index("y", "J", J);
      current_statement__ = 27;
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(I, J));
      y = std::vector<std::vector<int>>(I, std::vector<int>(J, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 27;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 27;
        pos__ = 1;
        current_statement__ = 27;
        for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
          current_statement__ = 27;
          for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
            current_statement__ = 27;
            assign(y,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y_flat__[(pos__ - 1)], "assigning variable y");
            current_statement__ = 27;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 27;
      for (int sym1__ = 1; sym1__ <= I; ++sym1__) {
        current_statement__ = 27;
        for (int sym2__ = 1; sym2__ <= J; ++sym2__) {
          current_statement__ = 27;
          current_statement__ = 27;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 27;
      for (int sym1__ = 1; sym1__ <= I; ++sym1__) {
        current_statement__ = 27;
        for (int sym2__ = 1; sym2__ <= J; ++sym2__) {
          current_statement__ = 27;
          current_statement__ = 27;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(sym1__ - 1)][(sym2__ - 1)], K);}}
      current_statement__ = 28;
      validate_non_negative_index("alpha", "K", K);
      current_statement__ = 29;
      context__.validate_dims("data initialization","alpha","double",
          context__.to_vec(K));
      alpha = Eigen::Matrix<double, -1, 1>(K);
      stan::math::fill(alpha, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> alpha_flat__;
        current_statement__ = 29;
        assign(alpha_flat__, nil_index_list(), context__.vals_r("alpha"),
          "assigning variable alpha_flat__");
        current_statement__ = 29;
        pos__ = 1;
        current_statement__ = 29;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 29;
          assign(alpha, cons_list(index_uni(sym1__), nil_index_list()),
            alpha_flat__[(pos__ - 1)], "assigning variable alpha");
          current_statement__ = 29;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 29;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        current_statement__ = 29;
        current_statement__ = 29;
        check_greater_or_equal(function__, "alpha[sym1__]",
                               alpha[(sym1__ - 1)], 0);}
      current_statement__ = 30;
      validate_non_negative_index("beta", "K", K);
      current_statement__ = 31;
      validate_non_negative_index("beta", "K", K);
      current_statement__ = 32;
      context__.validate_dims("data initialization","beta","double",
          context__.to_vec(K, K));
      beta = std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(K));
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 32;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 32;
        pos__ = 1;
        current_statement__ = 32;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 32;
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            current_statement__ = 32;
            assign(beta,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              beta_flat__[(pos__ - 1)], "assigning variable beta");
            current_statement__ = 32;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 32;
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        current_statement__ = 32;
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          current_statement__ = 32;
          current_statement__ = 32;
          check_greater_or_equal(function__, "beta[sym1__, sym2__]",
                                 beta[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 33;
      validate_positive_index("pi", "K", K);
      current_statement__ = 34;
      validate_non_negative_index("theta", "J", J);
      current_statement__ = 35;
      validate_non_negative_index("theta", "K", K);
      current_statement__ = 36;
      validate_positive_index("theta", "K", K);
      current_statement__ = 37;
      validate_non_negative_index("log_Pr_z", "I", I);
      current_statement__ = 38;
      validate_non_negative_index("log_Pr_z", "K", K);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += (K - 1);
      num_params_r__ += J * K * (K - 1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail7_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> pi;
      pi = Eigen::Matrix<local_scalar_t__, -1, 1>(K);
      stan::math::fill(pi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> pi_in__;
      pi_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>((K - 1));
      stan::math::fill(pi_in__, DUMMY_VAR__);
      
      current_statement__ = 1;
      pi_in__ = in__.vector((K - 1));
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        assign(pi, nil_index_list(),
          stan::math::simplex_constrain(pi_in__, lp__),
          "assigning variable pi");
      } else {
        current_statement__ = 1;
        assign(pi, nil_index_list(), stan::math::simplex_constrain(pi_in__),
          "assigning variable pi");
      }
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> theta;
      theta = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(J, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(K)));
      stan::math::fill(theta, DUMMY_VAR__);
      
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> theta_in__;
      theta_in__ = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(J, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(
        (K - 1))));
      stan::math::fill(theta_in__, DUMMY_VAR__);
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        current_statement__ = 2;
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          current_statement__ = 2;
          assign(theta_in__,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.vector((K - 1)), "assigning variable theta_in__");}}
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        current_statement__ = 2;
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          current_statement__ = 2;
          if (jacobian__) {
            current_statement__ = 2;
            assign(theta,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__), nil_index_list())),
              stan::math::simplex_constrain(
                theta_in__[(sym1__ - 1)][(sym2__ - 1)], lp__),
              "assigning variable theta");
          } else {
            current_statement__ = 2;
            assign(theta,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__), nil_index_list())),
              stan::math::simplex_constrain(
                theta_in__[(sym1__ - 1)][(sym2__ - 1)]),
              "assigning variable theta");
          }}}
      {
        current_statement__ = 11;
        lp_accum__.add(dirichlet_lpdf<propto__>(pi, alpha));
        current_statement__ = 14;
        for (int j = 1; j <= J; ++j) {
          current_statement__ = 13;
          for (int k = 1; k <= K; ++k) {
            current_statement__ = 12;
            lp_accum__.add(
              dirichlet_lpdf<propto__>(theta[(j - 1)][(k - 1)],
                beta[(k - 1)]));}}
        current_statement__ = 21;
        for (int i = 1; i <= I; ++i) {
          current_statement__ = 15;
          validate_non_negative_index("log_q", "K", K);
          Eigen::Matrix<local_scalar_t__, -1, 1> log_q;
          log_q = Eigen::Matrix<local_scalar_t__, -1, 1>(K);
          stan::math::fill(log_q, DUMMY_VAR__);
          
          current_statement__ = 16;
          assign(log_q, nil_index_list(), stan::math::log(pi),
            "assigning variable log_q");
          current_statement__ = 18;
          for (int j = 1; j <= J; ++j) {
            current_statement__ = 17;
            assign(log_q, nil_index_list(),
              add(stan::model::deep_copy(log_q),
                to_vector(
                  stan::math::log(
                    rvalue(theta,
                      cons_list(index_uni(j),
                        cons_list(index_omni(),
                          cons_list(index_uni(y[(i - 1)][(j - 1)]),
                            nil_index_list()))), "theta")))),
              "assigning variable log_q");}
          current_statement__ = 19;
          lp_accum__.add(log_sum_exp(log_q));}
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail7_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      Eigen::Matrix<double, -1, 1> pi;
      pi = Eigen::Matrix<double, -1, 1>(K);
      stan::math::fill(pi, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> pi_in__;
      pi_in__ = Eigen::Matrix<double, -1, 1>((K - 1));
      stan::math::fill(pi_in__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      pi_in__ = in__.vector((K - 1));
      current_statement__ = 1;
      assign(pi, nil_index_list(), stan::math::simplex_constrain(pi_in__),
        "assigning variable pi");
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> theta;
      theta = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(J, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(K)));
      stan::math::fill(theta, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> theta_in__;
      theta_in__ = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(J, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(
        (K - 1))));
      stan::math::fill(theta_in__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        current_statement__ = 2;
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          current_statement__ = 2;
          assign(theta_in__,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.vector((K - 1)), "assigning variable theta_in__");}}
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        current_statement__ = 2;
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          current_statement__ = 2;
          assign(theta,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            stan::math::simplex_constrain(
              theta_in__[(sym1__ - 1)][(sym2__ - 1)]),
            "assigning variable theta");}}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        vars__.emplace_back(pi[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= J; ++sym3__) {
            vars__.emplace_back(
              theta[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      std::vector<Eigen::Matrix<double, -1, 1>> log_Pr_z;
      log_Pr_z = std::vector<Eigen::Matrix<double, -1, 1>>(I, Eigen::Matrix<double, -1, 1>(K));
      stan::math::fill(log_Pr_z, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 10;
      for (int i = 1; i <= I; ++i) {
        current_statement__ = 4;
        validate_non_negative_index("log_q", "K", K);
        Eigen::Matrix<double, -1, 1> log_q;
        log_q = Eigen::Matrix<double, -1, 1>(K);
        stan::math::fill(log_q, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 5;
        assign(log_q, nil_index_list(), stan::math::log(pi),
          "assigning variable log_q");
        current_statement__ = 7;
        for (int j = 1; j <= J; ++j) {
          current_statement__ = 6;
          assign(log_q, nil_index_list(),
            add(stan::model::deep_copy(log_q),
              to_vector(
                stan::math::log(
                  rvalue(theta,
                    cons_list(index_uni(j),
                      cons_list(index_omni(),
                        cons_list(index_uni(y[(i - 1)][(j - 1)]),
                          nil_index_list()))), "theta")))),
            "assigning variable log_q");}
        current_statement__ = 8;
        assign(log_Pr_z, cons_list(index_uni(i), nil_index_list()),
          subtract(log_q, log_sum_exp(log_q)), "assigning variable log_Pr_z");
      }
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
          vars__.emplace_back(log_Pr_z[(sym2__ - 1)][(sym1__ - 1)]);}}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      Eigen::Matrix<double, -1, 1> pi;
      pi = Eigen::Matrix<double, -1, 1>(K);
      stan::math::fill(pi, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> pi_flat__;
        current_statement__ = 1;
        assign(pi_flat__, nil_index_list(), context__.vals_r("pi"),
          "assigning variable pi_flat__");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 1;
          assign(pi, cons_list(index_uni(sym1__), nil_index_list()),
            pi_flat__[(pos__ - 1)], "assigning variable pi");
          current_statement__ = 1;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> pi_free__;
      pi_free__ = Eigen::Matrix<double, -1, 1>((K - 1));
      stan::math::fill(pi_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      assign(pi_free__, nil_index_list(), stan::math::simplex_free(pi),
        "assigning variable pi_free__");
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> theta;
      theta = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(J, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(K)));
      stan::math::fill(theta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> theta_flat__;
        current_statement__ = 2;
        assign(theta_flat__, nil_index_list(), context__.vals_r("theta"),
          "assigning variable theta_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 2;
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            current_statement__ = 2;
            for (int sym3__ = 1; sym3__ <= J; ++sym3__) {
              current_statement__ = 2;
              assign(theta,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                theta_flat__[(pos__ - 1)], "assigning variable theta");
              current_statement__ = 2;
              pos__ = (pos__ + 1);}}}
      }
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> theta_free__;
      theta_free__ = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(J, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(
        (K - 1))));
      stan::math::fill(theta_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        current_statement__ = 2;
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          current_statement__ = 2;
          assign(theta_free__,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            stan::math::simplex_free(theta[(sym1__ - 1)][(sym2__ - 1)]),
            "assigning variable theta_free__");}}
      for (int sym1__ = 1; sym1__ <= (K - 1); ++sym1__) {
        vars__.emplace_back(pi_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= (K - 1); ++sym3__) {
            vars__.emplace_back(
              theta_free__[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)]);}}}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("pi");
    names__.emplace_back("theta");
    names__.emplace_back("log_Pr_z");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(K)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(J),
                                             static_cast<size_t>(K),
                                             static_cast<size_t>(K)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(I),
                                             static_cast<size_t>(K)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pi" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= J; ++sym3__) {
              {
                param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "log_Pr_z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= (K - 1); ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pi" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= (K - 1); ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= J; ++sym3__) {
              {
                param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "log_Pr_z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"pi\",\"type\":{\"name\":\"vector\",\"length\":" << K << "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << J << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}}},\"block\":\"parameters\"},{\"name\":\"log_Pr_z\",\"type\":{\"name\":\"array\",\"length\":" << I << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"pi\",\"type\":{\"name\":\"vector\",\"length\":" << (K - 1) << "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << J << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << (K - 1) << "}}},\"block\":\"parameters\"},{\"name\":\"log_Pr_z\",\"type\":{\"name\":\"array\",\"length\":" << I << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = expr_prop_fail7_model_namespace::expr_prop_fail7_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail7_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp expr-prop-fail8.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail8_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail8.stan', line 11, column 2 to column 13)",
                                                      " (in 'expr-prop-fail8.stan', line 12, column 2 to column 13)",
                                                      " (in 'expr-prop-fail8.stan', line 14, column 2 to column 26)",
                                                      " (in 'expr-prop-fail8.stan', line 15, column 2 to column 24)",
                                                      " (in 'expr-prop-fail8.stan', line 17, column 2 to column 22)",
                                                      " (in 'expr-prop-fail8.stan', line 18, column 2 to column 24)",
                                                      " (in 'expr-prop-fail8.stan', line 21, column 2 to column 47)",
                                                      " (in 'expr-prop-fail8.stan', line 22, column 2 to column 16)",
                                                      " (in 'expr-prop-fail8.stan', line 23, column 2 to column 25)",
                                                      " (in 'expr-prop-fail8.stan', line 24, column 2 to column 24)",
                                                      " (in 'expr-prop-fail8.stan', line 27, column 2 to column 33)",
                                                      " (in 'expr-prop-fail8.stan', line 2, column 2 to column 17)",
                                                      " (in 'expr-prop-fail8.stan', line 3, column 2 to column 23)",
                                                      " (in 'expr-prop-fail8.stan', line 4, column 30 to column 37)",
                                                      " (in 'expr-prop-fail8.stan', line 4, column 2 to column 39)",
                                                      " (in 'expr-prop-fail8.stan', line 5, column 30 to column 37)",
                                                      " (in 'expr-prop-fail8.stan', line 5, column 2 to column 39)",
                                                      " (in 'expr-prop-fail8.stan', line 7, column 17 to column 18)",
                                                      " (in 'expr-prop-fail8.stan', line 7, column 2 to column 20)",
                                                      " (in 'expr-prop-fail8.stan', line 8, column 9 to column 10)",
                                                      " (in 'expr-prop-fail8.stan', line 8, column 2 to column 14)",
                                                      " (in 'expr-prop-fail8.stan', line 17, column 9 to column 10)",
                                                      " (in 'expr-prop-fail8.stan', line 18, column 9 to column 10)",
                                                      " (in 'expr-prop-fail8.stan', line 22, column 9 to column 10)"};



class expr_prop_fail8_model final : public model_base_crtp<expr_prop_fail8_model> {

 private:
  int N;
  int N_edges;
  std::vector<int> node1;
  std::vector<int> node2;
  std::vector<int> y;
  Eigen::Matrix<double, -1, 1> x;
 
 public:
  ~expr_prop_fail8_model() { }
  
  inline std::string model_name() const final { return "expr_prop_fail8_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  expr_prop_fail8_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail8_model_namespace::expr_prop_fail8_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 12;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 12;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 12;
      current_statement__ = 12;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 13;
      context__.validate_dims("data initialization","N_edges","int",
          context__.to_vec());
      N_edges = std::numeric_limits<int>::min();
      
      current_statement__ = 13;
      N_edges = context__.vals_i("N_edges")[(1 - 1)];
      current_statement__ = 13;
      current_statement__ = 13;
      check_greater_or_equal(function__, "N_edges", N_edges, 0);
      current_statement__ = 14;
      validate_non_negative_index("node1", "N_edges", N_edges);
      current_statement__ = 15;
      context__.validate_dims("data initialization","node1","int",
          context__.to_vec(N_edges));
      node1 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      
      current_statement__ = 15;
      assign(node1, nil_index_list(), context__.vals_i("node1"),
        "assigning variable node1");
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= N_edges; ++sym1__) {
        current_statement__ = 15;
        current_statement__ = 15;
        check_greater_or_equal(function__, "node1[sym1__]",
                               node1[(sym1__ - 1)], 1);}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= N_edges; ++sym1__) {
        current_statement__ = 15;
        current_statement__ = 15;
        check_less_or_equal(function__, "node1[sym1__]", node1[(sym1__ - 1)],
                            N);}
      current_statement__ = 16;
      validate_non_negative_index("node2", "N_edges", N_edges);
      current_statement__ = 17;
      context__.validate_dims("data initialization","node2","int",
          context__.to_vec(N_edges));
      node2 = std::vector<int>(N_edges, std::numeric_limits<int>::min());
      
      current_statement__ = 17;
      assign(node2, nil_index_list(), context__.vals_i("node2"),
        "assigning variable node2");
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= N_edges; ++sym1__) {
        current_statement__ = 17;
        current_statement__ = 17;
        check_greater_or_equal(function__, "node2[sym1__]",
                               node2[(sym1__ - 1)], 1);}
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= N_edges; ++sym1__) {
        current_statement__ = 17;
        current_statement__ = 17;
        check_less_or_equal(function__, "node2[sym1__]", node2[(sym1__ - 1)],
                            N);}
      current_statement__ = 18;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 19;
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(N));
      y = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 19;
      assign(y, nil_index_list(), context__.vals_i("y"),
        "assigning variable y");
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 19;
        current_statement__ = 19;
        check_greater_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 0);}
      current_statement__ = 20;
      validate_non_negative_index("x", "N", N);
      current_statement__ = 21;
      context__.validate_dims("data initialization","x","double",
          context__.to_vec(N));
      x = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(x, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> x_flat__;
        current_statement__ = 21;
        assign(x_flat__, nil_index_list(), context__.vals_r("x"),
          "assigning variable x_flat__");
        current_statement__ = 21;
        pos__ = 1;
        current_statement__ = 21;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 21;
          assign(x, cons_list(index_uni(sym1__), nil_index_list()),
            x_flat__[(pos__ - 1)], "assigning variable x");
          current_statement__ = 21;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 22;
      validate_non_negative_index("theta_std", "N", N);
      current_statement__ = 23;
      validate_non_negative_index("phi_std_raw", "N", N);
      current_statement__ = 24;
      validate_non_negative_index("phi", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += N;
      num_params_r__ += N;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail8_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ beta0;
      beta0 = DUMMY_VAR__;
      
      current_statement__ = 1;
      beta0 = in__.scalar();
      local_scalar_t__ beta1;
      beta1 = DUMMY_VAR__;
      
      current_statement__ = 2;
      beta1 = in__.scalar();
      local_scalar_t__ tau_theta;
      tau_theta = DUMMY_VAR__;
      
      current_statement__ = 3;
      tau_theta = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        tau_theta = stan::math::lb_constrain(tau_theta, 0, lp__);
      } else {
        current_statement__ = 3;
        tau_theta = stan::math::lb_constrain(tau_theta, 0);
      }
      local_scalar_t__ tau_phi;
      tau_phi = DUMMY_VAR__;
      
      current_statement__ = 4;
      tau_phi = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        tau_phi = stan::math::lb_constrain(tau_phi, 0, lp__);
      } else {
        current_statement__ = 4;
        tau_phi = stan::math::lb_constrain(tau_phi, 0);
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> theta_std;
      theta_std = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(theta_std, DUMMY_VAR__);
      
      current_statement__ = 5;
      theta_std = in__.vector(N);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(phi_std_raw, DUMMY_VAR__);
      
      current_statement__ = 6;
      phi_std_raw = in__.vector(N);
      local_scalar_t__ sigma_phi;
      sigma_phi = DUMMY_VAR__;
      
      current_statement__ = 7;
      sigma_phi = inv(stan::math::sqrt(tau_phi));
      Eigen::Matrix<local_scalar_t__, -1, 1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(phi, DUMMY_VAR__);
      
      current_statement__ = 9;
      assign(phi, cons_list(index_min_max(1, N), nil_index_list()),
        phi_std_raw, "assigning variable phi");
      current_statement__ = 10;
      assign(phi, nil_index_list(),
        multiply(stan::model::deep_copy(phi), sigma_phi),
        "assigning variable phi");
      current_statement__ = 7;
      current_statement__ = 7;
      check_greater_or_equal(function__, "sigma_phi", sigma_phi, 0);
      {
        current_statement__ = 11;
        lp_accum__.add(
          dot_self(
            rvalue(phi, cons_list(index_multi(node1), nil_index_list()),
              "phi")));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail8_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double beta0;
      beta0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      beta0 = in__.scalar();
      double beta1;
      beta1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      beta1 = in__.scalar();
      double tau_theta;
      tau_theta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      tau_theta = in__.scalar();
      current_statement__ = 3;
      tau_theta = stan::math::lb_constrain(tau_theta, 0);
      double tau_phi;
      tau_phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      tau_phi = in__.scalar();
      current_statement__ = 4;
      tau_phi = stan::math::lb_constrain(tau_phi, 0);
      Eigen::Matrix<double, -1, 1> theta_std;
      theta_std = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(theta_std, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      theta_std = in__.vector(N);
      Eigen::Matrix<double, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(phi_std_raw, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      phi_std_raw = in__.vector(N);
      double sigma_phi;
      sigma_phi = std::numeric_limits<double>::quiet_NaN();
      
      Eigen::Matrix<double, -1, 1> phi;
      phi = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(phi, std::numeric_limits<double>::quiet_NaN());
      
      vars__.emplace_back(beta0);
      vars__.emplace_back(beta1);
      vars__.emplace_back(tau_theta);
      vars__.emplace_back(tau_phi);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(theta_std[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(phi_std_raw[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 7;
      sigma_phi = inv(stan::math::sqrt(tau_phi));
      current_statement__ = 9;
      assign(phi, cons_list(index_min_max(1, N), nil_index_list()),
        phi_std_raw, "assigning variable phi");
      current_statement__ = 10;
      assign(phi, nil_index_list(),
        multiply(stan::model::deep_copy(phi), sigma_phi),
        "assigning variable phi");
      current_statement__ = 7;
      current_statement__ = 7;
      check_greater_or_equal(function__, "sigma_phi", sigma_phi, 0);
      if (emit_transformed_parameters__) {
        vars__.emplace_back(sigma_phi);
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          vars__.emplace_back(phi[(sym1__ - 1)]);}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double beta0;
      beta0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      beta0 = context__.vals_r("beta0")[(1 - 1)];
      double beta1;
      beta1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      beta1 = context__.vals_r("beta1")[(1 - 1)];
      double tau_theta;
      tau_theta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      tau_theta = context__.vals_r("tau_theta")[(1 - 1)];
      double tau_theta_free__;
      tau_theta_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      tau_theta_free__ = stan::math::lb_free(tau_theta, 0);
      double tau_phi;
      tau_phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      tau_phi = context__.vals_r("tau_phi")[(1 - 1)];
      double tau_phi_free__;
      tau_phi_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      tau_phi_free__ = stan::math::lb_free(tau_phi, 0);
      Eigen::Matrix<double, -1, 1> theta_std;
      theta_std = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(theta_std, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> theta_std_flat__;
        current_statement__ = 5;
        assign(theta_std_flat__, nil_index_list(),
          context__.vals_r("theta_std"),
          "assigning variable theta_std_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 5;
          assign(theta_std, cons_list(index_uni(sym1__), nil_index_list()),
            theta_std_flat__[(pos__ - 1)], "assigning variable theta_std");
          current_statement__ = 5;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(phi_std_raw, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> phi_std_raw_flat__;
        current_statement__ = 6;
        assign(phi_std_raw_flat__, nil_index_list(),
          context__.vals_r("phi_std_raw"),
          "assigning variable phi_std_raw_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 6;
          assign(phi_std_raw, cons_list(index_uni(sym1__), nil_index_list()),
            phi_std_raw_flat__[(pos__ - 1)], "assigning variable phi_std_raw");
          current_statement__ = 6;
          pos__ = (pos__ + 1);}
      }
      vars__.emplace_back(beta0);
      vars__.emplace_back(beta1);
      vars__.emplace_back(tau_theta_free__);
      vars__.emplace_back(tau_phi_free__);
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(theta_std[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        vars__.emplace_back(phi_std_raw[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("beta0");
    names__.emplace_back("beta1");
    names__.emplace_back("tau_theta");
    names__.emplace_back("tau_phi");
    names__.emplace_back("theta_std");
    names__.emplace_back("phi_std_raw");
    names__.emplace_back("sigma_phi");
    names__.emplace_back("phi");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta0");
    param_names__.emplace_back(std::string() + "beta1");
    param_names__.emplace_back(std::string() + "tau_theta");
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta_std" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta0");
    param_names__.emplace_back(std::string() + "beta1");
    param_names__.emplace_back(std::string() + "tau_theta");
    param_names__.emplace_back(std::string() + "tau_phi");
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta_std" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma_phi");
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = expr_prop_fail8_model_namespace::expr_prop_fail8_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return expr_prop_fail8_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp fails-test.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace fails_test_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'fails-test.stan', line 71, column 2 to column 31)",
                                                      " (in 'fails-test.stan', line 72, column 2 to column 40)",
                                                      " (in 'fails-test.stan', line 76, column 2 to column 51)",
                                                      " (in 'fails-test.stan', line 77, column 2 to column 49)",
                                                      " (in 'fails-test.stan', line 78, column 2 to column 49)",
                                                      " (in 'fails-test.stan', line 83, column 6 to column 20)",
                                                      " (in 'fails-test.stan', line 84, column 6 to column 18)",
                                                      " (in 'fails-test.stan', line 82, column 32 to line 85, column 5)",
                                                      " (in 'fails-test.stan', line 82, column 4 to line 85, column 5)",
                                                      " (in 'fails-test.stan', line 87, column 6 to column 32)",
                                                      " (in 'fails-test.stan', line 88, column 6 to column 23)",
                                                      " (in 'fails-test.stan', line 86, column 38 to line 89, column 5)",
                                                      " (in 'fails-test.stan', line 86, column 4 to line 89, column 5)",
                                                      " (in 'fails-test.stan', line 81, column 20 to line 90, column 3)",
                                                      " (in 'fails-test.stan', line 81, column 2 to line 90, column 3)",
                                                      " (in 'fails-test.stan', line 92, column 2 to column 51)",
                                                      " (in 'fails-test.stan', line 105, column 8 to column 37)",
                                                      " (in 'fails-test.stan', line 106, column 8 to column 41)",
                                                      " (in 'fails-test.stan', line 104, column 40 to line 107, column 7)",
                                                      " (in 'fails-test.stan', line 104, column 6 to line 107, column 7)",
                                                      " (in 'fails-test.stan', line 108, column 6 to column 37)",
                                                      " (in 'fails-test.stan', line 103, column 22 to line 109, column 5)",
                                                      " (in 'fails-test.stan', line 103, column 4 to line 109, column 5)",
                                                      " (in 'fails-test.stan', line 102, column 20 to line 110, column 3)",
                                                      " (in 'fails-test.stan', line 102, column 2 to line 110, column 3)",
                                                      " (in 'fails-test.stan', line 50, column 2 to column 20)",
                                                      " (in 'fails-test.stan', line 51, column 2 to column 27)",
                                                      " (in 'fails-test.stan', line 52, column 25 to column 29)",
                                                      " (in 'fails-test.stan', line 52, column 31 to column 42)",
                                                      " (in 'fails-test.stan', line 52, column 2 to column 44)",
                                                      " (in 'fails-test.stan', line 53, column 2 to column 23)",
                                                      " (in 'fails-test.stan', line 54, column 31 to column 35)",
                                                      " (in 'fails-test.stan', line 54, column 37 to column 52)",
                                                      " (in 'fails-test.stan', line 54, column 2 to column 54)",
                                                      " (in 'fails-test.stan', line 58, column 2 to column 38)",
                                                      " (in 'fails-test.stan', line 60, column 39 to column 43)",
                                                      " (in 'fails-test.stan', line 60, column 2 to column 45)",
                                                      " (in 'fails-test.stan', line 61, column 38 to column 42)",
                                                      " (in 'fails-test.stan', line 61, column 2 to column 44)",
                                                      " (in 'fails-test.stan', line 65, column 4 to column 35)",
                                                      " (in 'fails-test.stan', line 64, column 2 to line 65, column 35)",
                                                      " (in 'fails-test.stan', line 67, column 4 to column 33)",
                                                      " (in 'fails-test.stan', line 66, column 2 to line 67, column 33)",
                                                      " (in 'fails-test.stan', line 72, column 26 to column 33)",
                                                      " (in 'fails-test.stan', line 76, column 26 to column 30)",
                                                      " (in 'fails-test.stan', line 76, column 32 to column 45)",
                                                      " (in 'fails-test.stan', line 77, column 26 to column 30)",
                                                      " (in 'fails-test.stan', line 77, column 32 to column 45)",
                                                      " (in 'fails-test.stan', line 78, column 26 to column 30)",
                                                      " (in 'fails-test.stan', line 78, column 32 to column 43)",
                                                      " (in 'fails-test.stan', line 8, column 8 to column 17)",
                                                      " (in 'fails-test.stan', line 7, column 6 to line 8, column 17)",
                                                      " (in 'fails-test.stan', line 6, column 4 to line 8, column 17)",
                                                      " (in 'fails-test.stan', line 9, column 4 to column 13)",
                                                      " (in 'fails-test.stan', line 5, column 31 to line 10, column 3)",
                                                      " (in 'fails-test.stan', line 15, column 6 to column 32)",
                                                      " (in 'fails-test.stan', line 19, column 8 to column 17)",
                                                      " (in 'fails-test.stan', line 18, column 6 to line 19, column 17)",
                                                      " (in 'fails-test.stan', line 13, column 37 to line 20, column 5)",
                                                      " (in 'fails-test.stan', line 13, column 4 to line 20, column 5)",
                                                      " (in 'fails-test.stan', line 21, column 4 to column 13)",
                                                      " (in 'fails-test.stan', line 12, column 30 to line 22, column 3)",
                                                      " (in 'fails-test.stan', line 26, column 11 to column 15)",
                                                      " (in 'fails-test.stan', line 26, column 17 to column 28)",
                                                      " (in 'fails-test.stan', line 26, column 4 to column 34)",
                                                      " (in 'fails-test.stan', line 29, column 6 to column 32)",
                                                      " (in 'fails-test.stan', line 32, column 8 to column 37)",
                                                      " (in 'fails-test.stan', line 33, column 8 to column 32)",
                                                      " (in 'fails-test.stan', line 41, column 8 to line 42, column 83)",
                                                      " (in 'fails-test.stan', line 30, column 37 to line 43, column 7)",
                                                      " (in 'fails-test.stan', line 30, column 6 to line 43, column 7)",
                                                      " (in 'fails-test.stan', line 28, column 22 to line 44, column 5)",
                                                      " (in 'fails-test.stan', line 28, column 4 to line 44, column 5)",
                                                      " (in 'fails-test.stan', line 45, column 4 to column 15)",
                                                      " (in 'fails-test.stan', line 25, column 47 to line 46, column 3)"};


int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 53;
    for (int k = 1; k <= size(y_i); ++k) {
      current_statement__ = 52;
      if (y_i[(k - 1)]) {
        current_statement__ = 51;
        return k;
      } }
    current_statement__ = 54;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 60;
    for (int k_rev = 0; k_rev <= (size(y_i) - 1); ++k_rev) {
      int k;
      k = std::numeric_limits<int>::min();
      
      current_statement__ = 56;
      k = (size(y_i) - k_rev);
      current_statement__ = 58;
      if (y_i[(k - 1)]) {
        current_statement__ = 57;
        return k;
      } }
    current_statement__ = 61;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 63;
    validate_non_negative_index("chi", "nind", nind);
    current_statement__ = 64;
    validate_non_negative_index("chi", "n_occasions", n_occasions);
    Eigen::Matrix<local_scalar_t__, -1, -1> chi;
    chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
    stan::math::fill(chi, DUMMY_VAR__);
    
    current_statement__ = 73;
    for (int i = 1; i <= nind; ++i) {
      current_statement__ = 66;
      assign(chi,
        cons_list(index_uni(i),
          cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
        "assigning variable chi");
      current_statement__ = 71;
      for (int t = 1; t <= (n_occasions - 1); ++t) {
        int t_curr;
        t_curr = std::numeric_limits<int>::min();
        
        current_statement__ = 67;
        t_curr = (n_occasions - t);
        int t_next;
        t_next = std::numeric_limits<int>::min();
        
        current_statement__ = 68;
        t_next = (t_curr + 1);
        current_statement__ = 69;
        assign(chi,
          cons_list(index_uni(i),
            cons_list(index_uni(t_curr), nil_index_list())),
          ((1 -
             rvalue(phi,
               cons_list(index_uni(i),
                 cons_list(index_uni(t_curr), nil_index_list())), "phi")) +
            ((rvalue(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t_curr), nil_index_list())), "phi") *
               (1 -
                 rvalue(p,
                   cons_list(index_uni(i),
                     cons_list(index_uni((t_next - 1)), nil_index_list())),
                   "p"))) *
              rvalue(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t_next), nil_index_list())), "chi"))),
          "assigning variable chi");}}
    current_statement__ = 74;
    return chi;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct prob_uncaptured_functor__ {
template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
operator()(const int& nind, const int& n_occasions, const T2__& p,
           const T3__& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}
};

class fails_test_model final : public model_base_crtp<fails_test_model> {

 private:
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int max_age;
  std::vector<std::vector<int>> x;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last;
 
 public:
  ~fails_test_model() { }
  
  inline std::string model_name() const final { return "fails_test_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  fails_test_model(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "fails_test_model_namespace::fails_test_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 26;
      context__.validate_dims("data initialization","nind","int",
          context__.to_vec());
      nind = std::numeric_limits<int>::min();
      
      current_statement__ = 26;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 26;
      current_statement__ = 26;
      check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 27;
      context__.validate_dims("data initialization","n_occasions","int",
          context__.to_vec());
      n_occasions = std::numeric_limits<int>::min();
      
      current_statement__ = 27;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 27;
      current_statement__ = 27;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 2);
      current_statement__ = 28;
      validate_non_negative_index("y", "nind", nind);
      current_statement__ = 29;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 30;
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(nind, n_occasions));
      y = std::vector<std::vector<int>>(nind, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 30;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 30;
        pos__ = 1;
        current_statement__ = 30;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 30;
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            current_statement__ = 30;
            assign(y,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y_flat__[(pos__ - 1)], "assigning variable y");
            current_statement__ = 30;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 30;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 30;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 30;
          current_statement__ = 30;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 30;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 30;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 30;
          current_statement__ = 30;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 31;
      context__.validate_dims("data initialization","max_age","int",
          context__.to_vec());
      max_age = std::numeric_limits<int>::min();
      
      current_statement__ = 31;
      max_age = context__.vals_i("max_age")[(1 - 1)];
      current_statement__ = 31;
      current_statement__ = 31;
      check_greater_or_equal(function__, "max_age", max_age, 1);
      current_statement__ = 32;
      validate_non_negative_index("x", "nind", nind);
      current_statement__ = 33;
      validate_non_negative_index("x", "n_occasions - 1", (n_occasions - 1));
      current_statement__ = 34;
      context__.validate_dims("data initialization","x","int",
          context__.to_vec(nind, (n_occasions - 1)));
      x = std::vector<std::vector<int>>(nind, std::vector<int>((n_occasions -
                                                                 1), std::numeric_limits<int>::min()));
      
      {
        std::vector<int> x_flat__;
        current_statement__ = 34;
        assign(x_flat__, nil_index_list(), context__.vals_i("x"),
          "assigning variable x_flat__");
        current_statement__ = 34;
        pos__ = 1;
        current_statement__ = 34;
        for (int sym1__ = 1; sym1__ <= (n_occasions - 1); ++sym1__) {
          current_statement__ = 34;
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            current_statement__ = 34;
            assign(x,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_flat__[(pos__ - 1)], "assigning variable x");
            current_statement__ = 34;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 34;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 34;
        for (int sym2__ = 1; sym2__ <= (n_occasions - 1); ++sym2__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                 x[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 34;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 34;
        for (int sym2__ = 1; sym2__ <= (n_occasions - 1); ++sym2__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_less_or_equal(function__, "x[sym1__, sym2__]",
                              x[(sym1__ - 1)][(sym2__ - 1)], max_age);}}
      current_statement__ = 35;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      
      current_statement__ = 35;
      n_occ_minus_1 = (n_occasions - 1);
      current_statement__ = 36;
      validate_non_negative_index("first", "nind", nind);
      current_statement__ = 37;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 38;
      validate_non_negative_index("last", "nind", nind);
      current_statement__ = 39;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 41;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 40;
        assign(first, cons_list(index_uni(i), nil_index_list()),
          first_capture(y[(i - 1)], pstream__), "assigning variable first");}
      current_statement__ = 43;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 42;
        assign(last, cons_list(index_uni(i), nil_index_list()),
          last_capture(y[(i - 1)], pstream__), "assigning variable last");}
      current_statement__ = 37;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 37;
        current_statement__ = 37;
        check_greater_or_equal(function__, "first[sym1__]",
                               first[(sym1__ - 1)], 0);}
      current_statement__ = 37;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 37;
        current_statement__ = 37;
        check_less_or_equal(function__, "first[sym1__]", first[(sym1__ - 1)],
                            n_occasions);}
      current_statement__ = 39;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 39;
        current_statement__ = 39;
        check_greater_or_equal(function__, "last[sym1__]",
                               last[(sym1__ - 1)], 0);}
      current_statement__ = 39;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 39;
        current_statement__ = 39;
        check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                            n_occasions);}
      current_statement__ = 44;
      validate_non_negative_index("beta", "max_age", max_age);
      current_statement__ = 45;
      validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 46;
      validate_non_negative_index("phi", "n_occ_minus_1", n_occ_minus_1);
      current_statement__ = 47;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 48;
      validate_non_negative_index("p", "n_occ_minus_1", n_occ_minus_1);
      current_statement__ = 49;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 50;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += max_age;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "fails_test_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ mean_p;
      mean_p = DUMMY_VAR__;
      
      current_statement__ = 1;
      mean_p = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1, lp__);
      } else {
        current_statement__ = 1;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(max_age);
      stan::math::fill(beta, DUMMY_VAR__);
      
      current_statement__ = 2;
      beta = in__.vector(max_age);
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
        current_statement__ = 2;
        if (jacobian__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(beta[(sym1__ - 1)], 0, 1, lp__),
            "assigning variable beta");
        } else {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(beta[(sym1__ - 1)], 0, 1),
            "assigning variable beta");
        }}
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(p, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      current_statement__ = 15;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 9;
        for (int t = 1; t <= (first[(i - 1)] - 1); ++t) {
          current_statement__ = 6;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable p");}
        current_statement__ = 13;
        for (int t = first[(i - 1)]; t <= n_occ_minus_1; ++t) {
          current_statement__ = 10;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())),
            beta[(x[(i - 1)][(t - 1)] - 1)], "assigning variable phi");
          current_statement__ = 11;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), mean_p,
            "assigning variable p");}}
      current_statement__ = 16;
      assign(chi, nil_index_list(),
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 3;
          current_statement__ = 3;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "phi"), 0);}}
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 3;
          current_statement__ = 3;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "phi"), 1);}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 4;
          current_statement__ = 4;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "p"), 0);}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 4;
          current_statement__ = 4;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "p"), 1);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(chi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "chi"), 0);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(chi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "chi"), 1);}}
      {
        current_statement__ = 25;
        for (int i = 1; i <= nind; ++i) {
          current_statement__ = 23;
          if (logical_gt(first[(i - 1)], 0)) {
            current_statement__ = 20;
            for (int t = (first[(i - 1)] + 1); t <= last[(i - 1)]; ++t) {
              current_statement__ = 17;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni((t - 1)), nil_index_list())),
                    "phi")));
              current_statement__ = 18;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(y[(i - 1)][(t - 1)],
                  rvalue(p,
                    cons_list(index_uni(i),
                      cons_list(index_uni((t - 1)), nil_index_list())), "p")));
            }
            current_statement__ = 21;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(last[(i - 1)]), nil_index_list())),
                  "chi")));
          } }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "fails_test_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double mean_p;
      mean_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_p = in__.scalar();
      current_statement__ = 1;
      mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(max_age);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      beta = in__.vector(max_age);
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
        current_statement__ = 2;
        assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(beta[(sym1__ - 1)], 0, 1),
          "assigning variable beta");}
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(p, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      vars__.emplace_back(mean_p);
      for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
        vars__.emplace_back(beta[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 15;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 9;
        for (int t = 1; t <= (first[(i - 1)] - 1); ++t) {
          current_statement__ = 6;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable p");}
        current_statement__ = 13;
        for (int t = first[(i - 1)]; t <= n_occ_minus_1; ++t) {
          current_statement__ = 10;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())),
            beta[(x[(i - 1)][(t - 1)] - 1)], "assigning variable phi");
          current_statement__ = 11;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), mean_p,
            "assigning variable p");}}
      current_statement__ = 16;
      assign(chi, nil_index_list(),
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 3;
          current_statement__ = 3;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "phi"), 0);}}
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 3;
          current_statement__ = 3;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "phi"), 1);}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 4;
          current_statement__ = 4;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "p"), 0);}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 4;
          current_statement__ = 4;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "p"), 1);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(chi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "chi"), 0);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(chi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "chi"), 1);}}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            vars__.emplace_back(
              rvalue(phi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "phi"));}}
        for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            vars__.emplace_back(
              rvalue(p,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "p"));}}
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            vars__.emplace_back(
              rvalue(chi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "chi"));}}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double mean_p;
      mean_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      double mean_p_free__;
      mean_p_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_p_free__ = stan::math::lub_free(mean_p, 0, 1);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(max_age);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 2;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            beta_flat__[(pos__ - 1)], "assigning variable beta");
          current_statement__ = 2;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> beta_free__;
      beta_free__ = Eigen::Matrix<double, -1, 1>(max_age);
      stan::math::fill(beta_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
        current_statement__ = 2;
        assign(beta_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(beta[(sym1__ - 1)], 0, 1),
          "assigning variable beta_free__");}
      vars__.emplace_back(mean_p_free__);
      for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
        vars__.emplace_back(beta_free__[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("mean_p");
    names__.emplace_back("beta");
    names__.emplace_back("phi");
    names__.emplace_back("p");
    names__.emplace_back("chi");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(max_age)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind),
                                             static_cast<size_t>(n_occ_minus_1)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind),
                                             static_cast<size_t>(n_occ_minus_1)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind),
                                             static_cast<size_t>(n_occasions)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= max_age; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << max_age << "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << max_age << "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = fails_test_model_namespace::fails_test_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return fails_test_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp inlining-fail2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace inlining_fail2_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'inlining-fail2.stan', line 177, column 2 to column 33)",
                                                      " (in 'inlining-fail2.stan', line 178, column 2 to column 31)",
                                                      " (in 'inlining-fail2.stan', line 179, column 2 to column 45)",
                                                      " (in 'inlining-fail2.stan', line 180, column 2 to column 32)",
                                                      " (in 'inlining-fail2.stan', line 181, column 2 to column 30)",
                                                      " (in 'inlining-fail2.stan', line 187, column 2 to column 50)",
                                                      " (in 'inlining-fail2.stan', line 188, column 2 to column 44)",
                                                      " (in 'inlining-fail2.stan', line 189, column 2 to column 46)",
                                                      " (in 'inlining-fail2.stan', line 194, column 6 to column 58)",
                                                      " (in 'inlining-fail2.stan', line 193, column 4 to line 194, column 58)",
                                                      " (in 'inlining-fail2.stan', line 192, column 2 to line 194, column 58)",
                                                      " (in 'inlining-fail2.stan', line 195, column 2 to column 41)",
                                                      " (in 'inlining-fail2.stan', line 198, column 2 to column 32)",
                                                      " (in 'inlining-fail2.stan', line 213, column 2 to column 14)",
                                                      " (in 'inlining-fail2.stan', line 214, column 2 to column 11)",
                                                      " (in 'inlining-fail2.stan', line 215, column 2 to column 24)",
                                                      " (in 'inlining-fail2.stan', line 216, column 2 to column 13)",
                                                      " (in 'inlining-fail2.stan', line 217, column 2 to column 21)",
                                                      " (in 'inlining-fail2.stan', line 218, column 2 to column 21)",
                                                      " (in 'inlining-fail2.stan', line 219, column 2 to column 24)",
                                                      " (in 'inlining-fail2.stan', line 223, column 4 to column 14)",
                                                      " (in 'inlining-fail2.stan', line 224, column 4 to column 13)",
                                                      " (in 'inlining-fail2.stan', line 226, column 4 to column 38)",
                                                      " (in 'inlining-fail2.stan', line 228, column 6 to column 32)",
                                                      " (in 'inlining-fail2.stan', line 229, column 6 to line 230, column 26)",
                                                      " (in 'inlining-fail2.stan', line 231, column 6 to column 35)",
                                                      " (in 'inlining-fail2.stan', line 227, column 29 to line 232, column 5)",
                                                      " (in 'inlining-fail2.stan', line 227, column 4 to line 232, column 5)",
                                                      " (in 'inlining-fail2.stan', line 222, column 17 to line 233, column 3)",
                                                      " (in 'inlining-fail2.stan', line 222, column 2 to line 233, column 3)",
                                                      " (in 'inlining-fail2.stan', line 237, column 11 to column 22)",
                                                      " (in 'inlining-fail2.stan', line 237, column 4 to column 49)",
                                                      " (in 'inlining-fail2.stan', line 238, column 16 to column 17)",
                                                      " (in 'inlining-fail2.stan', line 238, column 19 to column 30)",
                                                      " (in 'inlining-fail2.stan', line 238, column 4 to column 63)",
                                                      " (in 'inlining-fail2.stan', line 239, column 13 to column 14)",
                                                      " (in 'inlining-fail2.stan', line 239, column 4 to column 16)",
                                                      " (in 'inlining-fail2.stan', line 240, column 15 to column 16)",
                                                      " (in 'inlining-fail2.stan', line 240, column 4 to column 18)",
                                                      " (in 'inlining-fail2.stan', line 242, column 4 to column 27)",
                                                      " (in 'inlining-fail2.stan', line 243, column 4 to column 21)",
                                                      " (in 'inlining-fail2.stan', line 244, column 4 to column 20)",
                                                      " (in 'inlining-fail2.stan', line 247, column 6 to column 36)",
                                                      " (in 'inlining-fail2.stan', line 250, column 8 to column 26)",
                                                      " (in 'inlining-fail2.stan', line 249, column 6 to line 250, column 26)",
                                                      " (in 'inlining-fail2.stan', line 246, column 19 to line 251, column 5)",
                                                      " (in 'inlining-fail2.stan', line 246, column 4 to line 251, column 5)",
                                                      " (in 'inlining-fail2.stan', line 253, column 6 to column 25)",
                                                      " (in 'inlining-fail2.stan', line 254, column 6 to column 31)",
                                                      " (in 'inlining-fail2.stan', line 252, column 29 to line 255, column 5)",
                                                      " (in 'inlining-fail2.stan', line 252, column 4 to line 255, column 5)",
                                                      " (in 'inlining-fail2.stan', line 257, column 6 to column 26)",
                                                      " (in 'inlining-fail2.stan', line 258, column 6 to column 31)",
                                                      " (in 'inlining-fail2.stan', line 256, column 19 to line 259, column 5)",
                                                      " (in 'inlining-fail2.stan', line 256, column 4 to line 259, column 5)",
                                                      " (in 'inlining-fail2.stan', line 260, column 4 to column 25)",
                                                      " (in 'inlining-fail2.stan', line 236, column 2 to line 261, column 3)",
                                                      " (in 'inlining-fail2.stan', line 206, column 2 to column 29)",
                                                      " (in 'inlining-fail2.stan', line 209, column 2 to column 53)",
                                                      " (in 'inlining-fail2.stan', line 161, column 2 to column 17)",
                                                      " (in 'inlining-fail2.stan', line 162, column 2 to column 27)",
                                                      " (in 'inlining-fail2.stan', line 163, column 25 to column 26)",
                                                      " (in 'inlining-fail2.stan', line 163, column 28 to column 39)",
                                                      " (in 'inlining-fail2.stan', line 163, column 2 to column 41)",
                                                      " (in 'inlining-fail2.stan', line 167, column 39 to column 40)",
                                                      " (in 'inlining-fail2.stan', line 167, column 2 to column 42)",
                                                      " (in 'inlining-fail2.stan', line 168, column 38 to column 39)",
                                                      " (in 'inlining-fail2.stan', line 168, column 2 to column 41)",
                                                      " (in 'inlining-fail2.stan', line 171, column 4 to column 35)",
                                                      " (in 'inlining-fail2.stan', line 170, column 2 to line 171, column 35)",
                                                      " (in 'inlining-fail2.stan', line 173, column 4 to column 33)",
                                                      " (in 'inlining-fail2.stan', line 172, column 2 to line 173, column 33)",
                                                      " (in 'inlining-fail2.stan', line 179, column 26 to column 37)",
                                                      " (in 'inlining-fail2.stan', line 180, column 9 to column 22)",
                                                      " (in 'inlining-fail2.stan', line 187, column 26 to column 27)",
                                                      " (in 'inlining-fail2.stan', line 187, column 29 to column 44)",
                                                      " (in 'inlining-fail2.stan', line 188, column 26 to column 27)",
                                                      " (in 'inlining-fail2.stan', line 188, column 29 to column 40)",
                                                      " (in 'inlining-fail2.stan', line 189, column 26 to column 27)",
                                                      " (in 'inlining-fail2.stan', line 189, column 29 to column 40)",
                                                      " (in 'inlining-fail2.stan', line 215, column 9 to column 20)",
                                                      " (in 'inlining-fail2.stan', line 217, column 8 to column 19)",
                                                      " (in 'inlining-fail2.stan', line 218, column 8 to column 19)",
                                                      " (in 'inlining-fail2.stan', line 219, column 8 to column 9)",
                                                      " (in 'inlining-fail2.stan', line 219, column 11 to column 22)",
                                                      " (in 'inlining-fail2.stan', line 17, column 8 to column 17)",
                                                      " (in 'inlining-fail2.stan', line 16, column 6 to line 17, column 17)",
                                                      " (in 'inlining-fail2.stan', line 15, column 4 to line 17, column 17)",
                                                      " (in 'inlining-fail2.stan', line 18, column 4 to column 13)",
                                                      " (in 'inlining-fail2.stan', line 14, column 31 to line 19, column 3)",
                                                      " (in 'inlining-fail2.stan', line 30, column 6 to column 32)",
                                                      " (in 'inlining-fail2.stan', line 33, column 8 to column 17)",
                                                      " (in 'inlining-fail2.stan', line 32, column 6 to line 33, column 17)",
                                                      " (in 'inlining-fail2.stan', line 29, column 37 to line 34, column 5)",
                                                      " (in 'inlining-fail2.stan', line 29, column 4 to line 34, column 5)",
                                                      " (in 'inlining-fail2.stan', line 35, column 4 to column 13)",
                                                      " (in 'inlining-fail2.stan', line 28, column 30 to line 36, column 3)",
                                                      " (in 'inlining-fail2.stan', line 49, column 4 to column 24)",
                                                      " (in 'inlining-fail2.stan', line 50, column 4 to column 30)",
                                                      " (in 'inlining-fail2.stan', line 51, column 11 to column 16)",
                                                      " (in 'inlining-fail2.stan', line 51, column 18 to column 29)",
                                                      " (in 'inlining-fail2.stan', line 51, column 4 to column 35)",
                                                      " (in 'inlining-fail2.stan', line 54, column 6 to column 32)",
                                                      " (in 'inlining-fail2.stan', line 56, column 8 to column 37)",
                                                      " (in 'inlining-fail2.stan', line 57, column 8 to column 32)",
                                                      " (in 'inlining-fail2.stan', line 59, column 8 to line 60, column 65)",
                                                      " (in 'inlining-fail2.stan', line 55, column 37 to line 61, column 7)",
                                                      " (in 'inlining-fail2.stan', line 55, column 6 to line 61, column 7)",
                                                      " (in 'inlining-fail2.stan', line 53, column 23 to line 62, column 5)",
                                                      " (in 'inlining-fail2.stan', line 53, column 4 to line 62, column 5)",
                                                      " (in 'inlining-fail2.stan', line 63, column 4 to column 15)",
                                                      " (in 'inlining-fail2.stan', line 48, column 47 to line 64, column 3)",
                                                      " (in 'inlining-fail2.stan', line 80, column 4 to column 27)",
                                                      " (in 'inlining-fail2.stan', line 81, column 4 to column 33)",
                                                      " (in 'inlining-fail2.stan', line 82, column 11 to column 22)",
                                                      " (in 'inlining-fail2.stan', line 82, column 4 to column 45)",
                                                      " (in 'inlining-fail2.stan', line 85, column 13 to column 24)",
                                                      " (in 'inlining-fail2.stan', line 85, column 6 to column 43)",
                                                      " (in 'inlining-fail2.stan', line 119, column 15 to column 28)",
                                                      " (in 'inlining-fail2.stan', line 119, column 8 to column 33)",
                                                      " (in 'inlining-fail2.stan', line 122, column 8 to line 124, column 47)",
                                                      " (in 'inlining-fail2.stan', line 127, column 10 to line 130, column 49)",
                                                      " (in 'inlining-fail2.stan', line 126, column 8 to line 130, column 49)",
                                                      " (in 'inlining-fail2.stan', line 132, column 8 to column 63)",
                                                      " (in 'inlining-fail2.stan', line 133, column 8 to column 34)",
                                                      " (in 'inlining-fail2.stan', line 118, column 13 to line 134, column 7)",
                                                      " (in 'inlining-fail2.stan', line 92, column 17 to column 25)",
                                                      " (in 'inlining-fail2.stan', line 92, column 10 to column 30)",
                                                      " (in 'inlining-fail2.stan', line 95, column 10 to line 98, column 54)",
                                                      " (in 'inlining-fail2.stan', line 101, column 12 to line 105, column 56)",
                                                      " (in 'inlining-fail2.stan', line 100, column 10 to line 105, column 56)",
                                                      " (in 'inlining-fail2.stan', line 106, column 10 to line 108, column 61)",
                                                      " (in 'inlining-fail2.stan', line 109, column 10 to column 36)",
                                                      " (in 'inlining-fail2.stan', line 91, column 15 to line 110, column 9)",
                                                      " (in 'inlining-fail2.stan', line 90, column 10 to column 44)",
                                                      " (in 'inlining-fail2.stan', line 89, column 27 to line 91, column 9)",
                                                      " (in 'inlining-fail2.stan', line 89, column 8 to line 110, column 9)",
                                                      " (in 'inlining-fail2.stan', line 113, column 10 to column 39)",
                                                      " (in 'inlining-fail2.stan', line 114, column 10 to column 39)",
                                                      " (in 'inlining-fail2.stan', line 112, column 42 to line 115, column 9)",
                                                      " (in 'inlining-fail2.stan', line 112, column 8 to line 115, column 9)",
                                                      " (in 'inlining-fail2.stan', line 117, column 8 to column 39)",
                                                      " (in 'inlining-fail2.stan', line 87, column 20 to line 118, column 7)",
                                                      " (in 'inlining-fail2.stan', line 87, column 6 to line 134, column 7)",
                                                      " (in 'inlining-fail2.stan', line 84, column 23 to line 135, column 5)",
                                                      " (in 'inlining-fail2.stan', line 84, column 4 to line 135, column 5)",
                                                      " (in 'inlining-fail2.stan', line 79, column 34 to line 136, column 3)",
                                                      " (in 'inlining-fail2.stan', line 148, column 4 to column 24)",
                                                      " (in 'inlining-fail2.stan', line 149, column 11 to column 12)",
                                                      " (in 'inlining-fail2.stan', line 149, column 4 to column 24)",
                                                      " (in 'inlining-fail2.stan', line 150, column 4 to column 31)",
                                                      " (in 'inlining-fail2.stan', line 153, column 6 to column 55)",
                                                      " (in 'inlining-fail2.stan', line 154, column 6 to column 64)",
                                                      " (in 'inlining-fail2.stan', line 152, column 19 to line 155, column 5)",
                                                      " (in 'inlining-fail2.stan', line 152, column 4 to line 155, column 5)",
                                                      " (in 'inlining-fail2.stan', line 156, column 4 to column 26)",
                                                      " (in 'inlining-fail2.stan', line 147, column 33 to line 157, column 3)"};


int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 88;
    for (int k = 1; k <= size(y_i); ++k) {
      current_statement__ = 87;
      if (y_i[(k - 1)]) {
        current_statement__ = 86;
        return k;
      } }
    current_statement__ = 89;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 95;
    for (int k_rev = 0; k_rev <= (size(y_i) - 1); ++k_rev) {
      int k;
      k = std::numeric_limits<int>::min();
      
      current_statement__ = 91;
      k = (size(y_i) - k_rev);
      current_statement__ = 93;
      if (y_i[(k - 1)]) {
        current_statement__ = 92;
        return k;
      } }
    current_statement__ = 96;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
stan::value_type_t<T1__>>, -1, -1>
prob_uncaptured(const T0__& p_arg__, const T1__& phi_arg__,
                std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>>;
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int n_ind;
    n_ind = std::numeric_limits<int>::min();
    
    current_statement__ = 98;
    n_ind = rows(p);
    int n_occasions;
    n_occasions = std::numeric_limits<int>::min();
    
    current_statement__ = 99;
    n_occasions = cols(p);
    current_statement__ = 100;
    validate_non_negative_index("chi", "n_ind", n_ind);
    current_statement__ = 101;
    validate_non_negative_index("chi", "n_occasions", n_occasions);
    Eigen::Matrix<local_scalar_t__, -1, -1> chi;
    chi = Eigen::Matrix<local_scalar_t__, -1, -1>(n_ind, n_occasions);
    stan::math::fill(chi, DUMMY_VAR__);
    
    current_statement__ = 110;
    for (int i = 1; i <= n_ind; ++i) {
      current_statement__ = 103;
      assign(chi,
        cons_list(index_uni(i),
          cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
        "assigning variable chi");
      current_statement__ = 108;
      for (int t = 1; t <= (n_occasions - 1); ++t) {
        int t_curr;
        t_curr = std::numeric_limits<int>::min();
        
        current_statement__ = 104;
        t_curr = (n_occasions - t);
        int t_next;
        t_next = std::numeric_limits<int>::min();
        
        current_statement__ = 105;
        t_next = (t_curr + 1);
        current_statement__ = 106;
        assign(chi,
          cons_list(index_uni(i),
            cons_list(index_uni(t_curr), nil_index_list())),
          ((1 -
             rvalue(phi,
               cons_list(index_uni(i),
                 cons_list(index_uni(t_curr), nil_index_list())), "phi")) +
            ((rvalue(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t_curr), nil_index_list())), "phi") *
               (1 -
                 rvalue(p,
                   cons_list(index_uni(i),
                     cons_list(index_uni(t_next), nil_index_list())), "p")))
              *
              rvalue(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t_next), nil_index_list())), "chi"))),
          "assigning variable chi");}}
    current_statement__ = 111;
    return chi;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct prob_uncaptured_functor__ {
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
stan::value_type_t<T1__>>, -1, -1>
operator()(const T0__& p, const T1__& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(p, phi, pstream__);
}
};

template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T_lp__, typename T_lp_accum__>
void
jolly_seber_lp(const std::vector<std::vector<int>>& y,
               const std::vector<int>& first, const std::vector<int>& last,
               const T3__& p_arg__, const T4__& phi_arg__,
               const T5__& gamma_arg__, const T6__& chi_arg__, T_lp__& lp__,
               T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T3__>,
          stan::value_type_t<T4__>,
          stan::value_type_t<T5__>,
          stan::value_type_t<T6__>>;
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  const auto& gamma = to_ref(gamma_arg__);
  const auto& chi = to_ref(chi_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int n_ind;
    n_ind = std::numeric_limits<int>::min();
    
    current_statement__ = 113;
    n_ind = dims(y)[(1 - 1)];
    int n_occasions;
    n_occasions = std::numeric_limits<int>::min();
    
    current_statement__ = 114;
    n_occasions = dims(y)[(2 - 1)];
    current_statement__ = 115;
    validate_non_negative_index("qgamma", "n_occasions", n_occasions);
    Eigen::Matrix<local_scalar_t__, -1, 1> qgamma;
    qgamma = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
    stan::math::fill(qgamma, DUMMY_VAR__);
    
    current_statement__ = 116;
    assign(qgamma, nil_index_list(), subtract(1.0, gamma),
      "assigning variable qgamma");
    current_statement__ = 146;
    for (int i = 1; i <= n_ind; ++i) {
      current_statement__ = 117;
      validate_non_negative_index("qp", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> qp;
      qp = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(qp, DUMMY_VAR__);
      
      current_statement__ = 118;
      assign(qp, nil_index_list(),
        subtract(1.0,
          transpose(
            rvalue(p, cons_list(index_uni(i), nil_index_list()), "p"))),
        "assigning variable qp");
      current_statement__ = 144;
      if (first[(i - 1)]) {
        current_statement__ = 137;
        if (logical_eq(first[(i - 1)], 1)) {
          current_statement__ = 135;
          lp_accum__.add(
            bernoulli_lpmf<propto__>(1,
              (gamma[(1 - 1)] *
                rvalue(p,
                  cons_list(index_uni(i),
                    cons_list(index_uni(1), nil_index_list())), "p"))));
        } else {
          current_statement__ = 127;
          validate_non_negative_index("lp", "first[i]", first[(i - 1)]);
          Eigen::Matrix<local_scalar_t__, -1, 1> lp;
          lp = Eigen::Matrix<local_scalar_t__, -1, 1>(first[(i - 1)]);
          stan::math::fill(lp, DUMMY_VAR__);
          
          current_statement__ = 129;
          assign(lp, cons_list(index_uni(1), nil_index_list()),
            (((bernoulli_lpmf<false>(1, gamma[(1 - 1)]) +
                bernoulli_lpmf<false>(1,
                  prod(
                    rvalue(qp,
                      cons_list(index_min_max(1, (first[(i - 1)] - 1)),
                        nil_index_list()), "qp")))) +
               bernoulli_lpmf<false>(1,
                 prod(
                   rvalue(phi,
                     cons_list(index_uni(i),
                       cons_list(index_min_max(1, (first[(i - 1)] - 1)),
                         nil_index_list())), "phi")))) +
              bernoulli_lpmf<false>(1,
                rvalue(p,
                  cons_list(index_uni(i),
                    cons_list(index_uni(first[(i - 1)]), nil_index_list())),
                  "p"))), "assigning variable lp");
          current_statement__ = 131;
          for (int t = 2; t <= (first[(i - 1)] - 1); ++t) {
            current_statement__ = 130;
            assign(lp, cons_list(index_uni(t), nil_index_list()),
              ((((bernoulli_lpmf<false>(1,
                    prod(
                      rvalue(qgamma,
                        cons_list(index_min_max(1, (t - 1)),
                          nil_index_list()), "qgamma"))) +
                   bernoulli_lpmf<false>(1, gamma[(t - 1)])) +
                  bernoulli_lpmf<false>(1,
                    prod(
                      rvalue(qp,
                        cons_list(index_min_max(t, (first[(i - 1)] - 1)),
                          nil_index_list()), "qp")))) +
                 bernoulli_lpmf<false>(1,
                   prod(
                     rvalue(phi,
                       cons_list(index_uni(i),
                         cons_list(index_min_max(t, (first[(i - 1)] - 1)),
                           nil_index_list())), "phi")))) +
                bernoulli_lpmf<false>(1,
                  rvalue(p,
                    cons_list(index_uni(i),
                      cons_list(index_uni(first[(i - 1)]), nil_index_list())),
                    "p"))), "assigning variable lp");}
          current_statement__ = 132;
          assign(lp, cons_list(index_uni(first[(i - 1)]), nil_index_list()),
            ((bernoulli_lpmf<false>(1,
                prod(
                  rvalue(qgamma,
                    cons_list(index_min_max(1, (first[(i - 1)] - 1)),
                      nil_index_list()), "qgamma"))) +
               bernoulli_lpmf<false>(1, gamma[(first[(i - 1)] - 1)])) +
              bernoulli_lpmf<false>(1,
                rvalue(p,
                  cons_list(index_uni(i),
                    cons_list(index_uni(first[(i - 1)]), nil_index_list())),
                  "p"))), "assigning variable lp");
          current_statement__ = 133;
          lp_accum__.add(log_sum_exp(lp));
        }
        current_statement__ = 141;
        for (int t = (first[(i - 1)] + 1); t <= last[(i - 1)]; ++t) {
          current_statement__ = 138;
          lp_accum__.add(
            bernoulli_lpmf<propto__>(1,
              rvalue(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni((t - 1)), nil_index_list())), "phi")));
          current_statement__ = 139;
          lp_accum__.add(
            bernoulli_lpmf<propto__>(y[(i - 1)][(t - 1)],
              rvalue(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), "p")));}
        current_statement__ = 142;
        lp_accum__.add(
          bernoulli_lpmf<propto__>(1,
            rvalue(chi,
              cons_list(index_uni(i),
                cons_list(index_uni(last[(i - 1)]), nil_index_list())),
              "chi")));
      } else {
        current_statement__ = 119;
        validate_non_negative_index("lp", "n_occasions + 1",
                                    (n_occasions + 1));
        Eigen::Matrix<local_scalar_t__, -1, 1> lp;
        lp = Eigen::Matrix<local_scalar_t__, -1, 1>((n_occasions + 1));
        stan::math::fill(lp, DUMMY_VAR__);
        
        current_statement__ = 121;
        assign(lp, cons_list(index_uni(1), nil_index_list()),
          ((bernoulli_lpmf<false>(1, gamma[(1 - 1)]) +
             bernoulli_lpmf<false>(0,
               rvalue(p,
                 cons_list(index_uni(i),
                   cons_list(index_uni(1), nil_index_list())), "p"))) +
            bernoulli_lpmf<false>(1,
              rvalue(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(1), nil_index_list())), "chi"))),
          "assigning variable lp");
        current_statement__ = 123;
        for (int t = 2; t <= n_occasions; ++t) {
          current_statement__ = 122;
          assign(lp, cons_list(index_uni(t), nil_index_list()),
            (((bernoulli_lpmf<false>(1,
                 prod(
                   rvalue(qgamma,
                     cons_list(index_min_max(1, (t - 1)), nil_index_list()),
                     "qgamma"))) + bernoulli_lpmf<false>(1, gamma[(t - 1)]))
               +
               bernoulli_lpmf<false>(0,
                 rvalue(p,
                   cons_list(index_uni(i),
                     cons_list(index_uni(t), nil_index_list())), "p"))) +
              bernoulli_lpmf<false>(1,
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(t), nil_index_list())), "chi"))),
            "assigning variable lp");}
        current_statement__ = 124;
        assign(lp, cons_list(index_uni((n_occasions + 1)), nil_index_list()),
          bernoulli_lpmf<false>(1, prod(qgamma)), "assigning variable lp");
        current_statement__ = 125;
        lp_accum__.add(log_sum_exp(lp));
      }}
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct jolly_seber_lp_functor__ {
template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T_lp__, typename T_lp_accum__>
void
operator()(const std::vector<std::vector<int>>& y,
           const std::vector<int>& first, const std::vector<int>& last,
           const T3__& p, const T4__& phi, const T5__& gamma,
           const T6__& chi, T_lp__& lp__, T_lp_accum__& lp_accum__,
           std::ostream* pstream__)  const 
{
return jolly_seber_lp<propto__>(y, first, last, p, phi, gamma, chi, lp__,
         lp_accum__, pstream__);
}
};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
seq_cprob(const T0__& gamma_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  const auto& gamma = to_ref(gamma_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int N;
    N = std::numeric_limits<int>::min();
    
    current_statement__ = 148;
    N = rows(gamma);
    current_statement__ = 149;
    validate_non_negative_index("log_cprob", "N", N);
    Eigen::Matrix<local_scalar_t__, -1, 1> log_cprob;
    log_cprob = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
    stan::math::fill(log_cprob, DUMMY_VAR__);
    
    local_scalar_t__ log_residual_prob;
    log_residual_prob = DUMMY_VAR__;
    
    current_statement__ = 151;
    log_residual_prob = 0;
    current_statement__ = 155;
    for (int n = 1; n <= N; ++n) {
      current_statement__ = 152;
      assign(log_cprob, cons_list(index_uni(n), nil_index_list()),
        (stan::math::log(gamma[(n - 1)]) + log_residual_prob),
        "assigning variable log_cprob");
      current_statement__ = 153;
      log_residual_prob = (log_residual_prob +
                            stan::math::log((1 - gamma[(n - 1)])));}
    current_statement__ = 156;
    return stan::math::exp(log_cprob);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct seq_cprob_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
operator()(const T0__& gamma, std::ostream* pstream__)  const 
{
return seq_cprob(gamma, pstream__);
}
};

class inlining_fail2_model final : public model_base_crtp<inlining_fail2_model> {

 private:
  int M;
  int n_occasions;
  std::vector<std::vector<int>> y;
  std::vector<int> first;
  std::vector<int> last;
  int epsilon_1dim__;
  int phi_2dim__;
 
 public:
  ~inlining_fail2_model() { }
  
  inline std::string model_name() const final { return "inlining_fail2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  inlining_fail2_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "inlining_fail2_model_namespace::inlining_fail2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 60;
      context__.validate_dims("data initialization","M","int",
          context__.to_vec());
      M = std::numeric_limits<int>::min();
      
      current_statement__ = 60;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 60;
      current_statement__ = 60;
      check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 61;
      context__.validate_dims("data initialization","n_occasions","int",
          context__.to_vec());
      n_occasions = std::numeric_limits<int>::min();
      
      current_statement__ = 61;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 61;
      current_statement__ = 61;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 0);
      current_statement__ = 62;
      validate_non_negative_index("y", "M", M);
      current_statement__ = 63;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 64;
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(M, n_occasions));
      y = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 64;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 64;
        pos__ = 1;
        current_statement__ = 64;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 64;
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            current_statement__ = 64;
            assign(y,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y_flat__[(pos__ - 1)], "assigning variable y");
            current_statement__ = 64;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 64;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 64;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 64;
          current_statement__ = 64;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 64;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 64;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 64;
          current_statement__ = 64;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 65;
      validate_non_negative_index("first", "M", M);
      current_statement__ = 66;
      first = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 67;
      validate_non_negative_index("last", "M", M);
      current_statement__ = 68;
      last = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 70;
      for (int i = 1; i <= M; ++i) {
        current_statement__ = 69;
        assign(first, cons_list(index_uni(i), nil_index_list()),
          first_capture(y[(i - 1)], pstream__), "assigning variable first");}
      current_statement__ = 72;
      for (int i = 1; i <= M; ++i) {
        current_statement__ = 71;
        assign(last, cons_list(index_uni(i), nil_index_list()),
          last_capture(y[(i - 1)], pstream__), "assigning variable last");}
      current_statement__ = 66;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 66;
        current_statement__ = 66;
        check_greater_or_equal(function__, "first[sym1__]",
                               first[(sym1__ - 1)], 0);}
      current_statement__ = 66;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 66;
        current_statement__ = 66;
        check_less_or_equal(function__, "first[sym1__]", first[(sym1__ - 1)],
                            n_occasions);}
      current_statement__ = 68;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 68;
        current_statement__ = 68;
        check_greater_or_equal(function__, "last[sym1__]",
                               last[(sym1__ - 1)], 0);}
      current_statement__ = 68;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 68;
        current_statement__ = 68;
        check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                            n_occasions);}
      current_statement__ = 73;
      validate_non_negative_index("gamma", "n_occasions", n_occasions);
      current_statement__ = 74;
      epsilon_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 74;
      epsilon_1dim__ = (n_occasions - 1);
      current_statement__ = 74;
      validate_non_negative_index("epsilon", "n_occasions - 1",
                                  epsilon_1dim__);
      current_statement__ = 75;
      validate_non_negative_index("phi", "M", M);
      current_statement__ = 76;
      phi_2dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 76;
      phi_2dim__ = (n_occasions - 1);
      current_statement__ = 76;
      validate_non_negative_index("phi", "n_occasions - 1", phi_2dim__);
      current_statement__ = 77;
      validate_non_negative_index("p", "M", M);
      current_statement__ = 78;
      validate_non_negative_index("p", "n_occasions", n_occasions);
      current_statement__ = 79;
      validate_non_negative_index("chi", "M", M);
      current_statement__ = 80;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      current_statement__ = 81;
      validate_non_negative_index("b", "n_occasions", n_occasions);
      current_statement__ = 82;
      validate_non_negative_index("N", "n_occasions", n_occasions);
      current_statement__ = 83;
      validate_non_negative_index("B", "n_occasions", n_occasions);
      current_statement__ = 84;
      validate_non_negative_index("z", "M", M);
      current_statement__ = 85;
      validate_non_negative_index("z", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += n_occasions;
      num_params_r__ += epsilon_1dim__;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "inlining_fail2_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ mean_phi;
      mean_phi = DUMMY_VAR__;
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1, lp__);
      } else {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      }
      local_scalar_t__ mean_p;
      mean_p = DUMMY_VAR__;
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1, lp__);
      } else {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> gamma;
      gamma = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      stan::math::fill(gamma, DUMMY_VAR__);
      
      current_statement__ = 3;
      gamma = in__.vector(n_occasions);
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        current_statement__ = 3;
        if (jacobian__) {
          current_statement__ = 3;
          assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(gamma[(sym1__ - 1)], 0, 1, lp__),
            "assigning variable gamma");
        } else {
          current_statement__ = 3;
          assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(gamma[(sym1__ - 1)], 0, 1),
            "assigning variable gamma");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon;
      epsilon = Eigen::Matrix<local_scalar_t__, -1, 1>(epsilon_1dim__);
      stan::math::fill(epsilon, DUMMY_VAR__);
      
      current_statement__ = 4;
      epsilon = in__.vector(epsilon_1dim__);
      local_scalar_t__ sigma;
      sigma = DUMMY_VAR__;
      
      current_statement__ = 5;
      sigma = in__.scalar();
      current_statement__ = 5;
      if (jacobian__) {
        current_statement__ = 5;
        sigma = stan::math::lub_constrain(sigma, 0, 5, lp__);
      } else {
        current_statement__ = 5;
        sigma = stan::math::lub_constrain(sigma, 0, 5);
      }
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, phi_2dim__);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      stan::math::fill(p, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      current_statement__ = 11;
      for (int t = 1; t <= (n_occasions - 1); ++t) {
        current_statement__ = 10;
        for (int i = 1; i <= M; ++i) {
          current_statement__ = 9;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())),
            inv_logit((logit(mean_phi) + epsilon[(t - 1)])),
            "assigning variable phi");}}
      current_statement__ = 12;
      assign(p, nil_index_list(), rep_matrix(mean_p, M, n_occasions),
        "assigning variable p");
      current_statement__ = 13;
      assign(chi, nil_index_list(), prob_uncaptured(p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= phi_2dim__; ++sym2__) {
          current_statement__ = 6;
          current_statement__ = 6;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "phi"), 0);}}
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= phi_2dim__; ++sym2__) {
          current_statement__ = 6;
          current_statement__ = 6;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "phi"), 1);}}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 7;
          current_statement__ = 7;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "p"), 0);}}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 7;
          current_statement__ = 7;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "p"), 1);}}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 8;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 8;
          current_statement__ = 8;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(chi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "chi"), 0);}}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 8;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 8;
          current_statement__ = 8;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(chi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "chi"), 1);}}
      {
        current_statement__ = 58;
        lp_accum__.add(normal_lpdf<propto__>(epsilon, 0, sigma));
        current_statement__ = 59;
        jolly_seber_lp<false>(y, first, last, p, phi, gamma,
          chi, lp__, lp_accum__, pstream__);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "inlining_fail2_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double mean_phi;
      mean_phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      double mean_p;
      mean_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      Eigen::Matrix<double, -1, 1> gamma;
      gamma = Eigen::Matrix<double, -1, 1>(n_occasions);
      stan::math::fill(gamma, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      gamma = in__.vector(n_occasions);
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        current_statement__ = 3;
        assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(gamma[(sym1__ - 1)], 0, 1),
          "assigning variable gamma");}
      Eigen::Matrix<double, -1, 1> epsilon;
      epsilon = Eigen::Matrix<double, -1, 1>(epsilon_1dim__);
      stan::math::fill(epsilon, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      epsilon = in__.vector(epsilon_1dim__);
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      sigma = in__.scalar();
      current_statement__ = 5;
      sigma = stan::math::lub_constrain(sigma, 0, 5);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, phi_2dim__);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(M, n_occasions);
      stan::math::fill(p, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      vars__.emplace_back(mean_phi);
      vars__.emplace_back(mean_p);
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        vars__.emplace_back(gamma[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= epsilon_1dim__; ++sym1__) {
        vars__.emplace_back(epsilon[(sym1__ - 1)]);}
      vars__.emplace_back(sigma);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 11;
      for (int t = 1; t <= (n_occasions - 1); ++t) {
        current_statement__ = 10;
        for (int i = 1; i <= M; ++i) {
          current_statement__ = 9;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())),
            inv_logit((logit(mean_phi) + epsilon[(t - 1)])),
            "assigning variable phi");}}
      current_statement__ = 12;
      assign(p, nil_index_list(), rep_matrix(mean_p, M, n_occasions),
        "assigning variable p");
      current_statement__ = 13;
      assign(chi, nil_index_list(), prob_uncaptured(p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= phi_2dim__; ++sym2__) {
          current_statement__ = 6;
          current_statement__ = 6;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "phi"), 0);}}
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 6;
        for (int sym2__ = 1; sym2__ <= phi_2dim__; ++sym2__) {
          current_statement__ = 6;
          current_statement__ = 6;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "phi"), 1);}}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 7;
          current_statement__ = 7;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "p"), 0);}}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 7;
          current_statement__ = 7;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "p"), 1);}}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 8;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 8;
          current_statement__ = 8;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(chi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "chi"), 0);}}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 8;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 8;
          current_statement__ = 8;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(chi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "chi"), 1);}}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= phi_2dim__; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            vars__.emplace_back(
              rvalue(phi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "phi"));}}
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            vars__.emplace_back(
              rvalue(p,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "p"));}}
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            vars__.emplace_back(
              rvalue(chi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "chi"));}}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double sigma2;
      sigma2 = std::numeric_limits<double>::quiet_NaN();
      
      double psi;
      psi = std::numeric_limits<double>::quiet_NaN();
      
      Eigen::Matrix<double, -1, 1> b;
      b = Eigen::Matrix<double, -1, 1>(n_occasions);
      stan::math::fill(b, std::numeric_limits<double>::quiet_NaN());
      
      int Nsuper;
      Nsuper = std::numeric_limits<int>::min();
      
      std::vector<int> N;
      N = std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      
      std::vector<int> B;
      B = std::vector<int>(n_occasions, std::numeric_limits<int>::min());
      
      std::vector<std::vector<int>> z;
      z = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      current_statement__ = 30;
      for (int i = 1; i <= M; ++i) {
        int q;
        q = std::numeric_limits<int>::min();
        
        current_statement__ = 21;
        q = 1;
        double mu2;
        mu2 = std::numeric_limits<double>::quiet_NaN();
        
        current_statement__ = 23;
        assign(z,
          cons_list(index_uni(i), cons_list(index_uni(1), nil_index_list())),
          bernoulli_rng(gamma[(1 - 1)], base_rng__), "assigning variable z");
        current_statement__ = 28;
        for (int t = 2; t <= n_occasions; ++t) {
          current_statement__ = 24;
          q = (q * (1 - z[(i - 1)][((t - 1) - 1)]));
          current_statement__ = 25;
          mu2 = ((rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni((t - 1)), nil_index_list())),
                    "phi") * z[(i - 1)][((t - 1) - 1)]) +
                  (gamma[(t - 1)] * q));
          current_statement__ = 26;
          assign(z,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())),
            bernoulli_rng(mu2, base_rng__), "assigning variable z");}}
      {
        current_statement__ = 31;
        validate_non_negative_index("cprob", "n_occasions", n_occasions);
        Eigen::Matrix<double, -1, 1> cprob;
        cprob = Eigen::Matrix<double, -1, 1>(n_occasions);
        stan::math::fill(cprob, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 32;
        assign(cprob, nil_index_list(), seq_cprob(gamma, pstream__),
          "assigning variable cprob");
        current_statement__ = 33;
        validate_non_negative_index("recruit", "M", M);
        current_statement__ = 34;
        validate_non_negative_index("recruit", "n_occasions", n_occasions);
        std::vector<std::vector<int>> recruit;
        recruit = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
        
        current_statement__ = 35;
        assign(recruit, nil_index_list(), rep_array(0, M, n_occasions),
          "assigning variable recruit");
        current_statement__ = 36;
        validate_non_negative_index("Nind", "M", M);
        std::vector<int> Nind;
        Nind = std::vector<int>(M, std::numeric_limits<int>::min());
        
        current_statement__ = 38;
        validate_non_negative_index("Nalive", "M", M);
        std::vector<int> Nalive;
        Nalive = std::vector<int>(M, std::numeric_limits<int>::min());
        
        current_statement__ = 40;
        sigma2 = square(sigma);
        current_statement__ = 41;
        psi = sum(cprob);
        current_statement__ = 42;
        assign(b, nil_index_list(), divide(cprob, psi),
          "assigning variable b");
        current_statement__ = 47;
        for (int i = 1; i <= M; ++i) {
          int f;
          f = std::numeric_limits<int>::min();
          
          current_statement__ = 43;
          f = first_capture(
                rvalue(z,
                  cons_list(index_uni(i),
                    cons_list(index_omni(), nil_index_list())), "z"), pstream__);
          current_statement__ = 45;
          if (logical_gt(f, 0)) {
            current_statement__ = 44;
            assign(recruit,
              cons_list(index_uni(i),
                cons_list(index_uni(f), nil_index_list())), 1,
              "assigning variable recruit");
          } }
        current_statement__ = 51;
        for (int t = 1; t <= n_occasions; ++t) {
          current_statement__ = 48;
          assign(N, cons_list(index_uni(t), nil_index_list()),
            sum(
              rvalue(z,
                cons_list(index_omni(),
                  cons_list(index_uni(t), nil_index_list())), "z")),
            "assigning variable N");
          current_statement__ = 49;
          assign(B, cons_list(index_uni(t), nil_index_list()),
            sum(
              rvalue(recruit,
                cons_list(index_omni(),
                  cons_list(index_uni(t), nil_index_list())), "recruit")),
            "assigning variable B");}
        current_statement__ = 55;
        for (int i = 1; i <= M; ++i) {
          current_statement__ = 52;
          assign(Nind, cons_list(index_uni(i), nil_index_list()),
            sum(z[(i - 1)]), "assigning variable Nind");
          current_statement__ = 53;
          assign(Nalive, cons_list(index_uni(i), nil_index_list()),
            (1 - logical_negation(Nind[(i - 1)])),
            "assigning variable Nalive");}
        current_statement__ = 56;
        Nsuper = sum(Nalive);
      }
      vars__.emplace_back(sigma2);
      vars__.emplace_back(psi);
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        vars__.emplace_back(b[(sym1__ - 1)]);}
      vars__.emplace_back(Nsuper);
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        vars__.emplace_back(N[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        vars__.emplace_back(B[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
          vars__.emplace_back(z[(sym2__ - 1)][(sym1__ - 1)]);}}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double mean_phi;
      mean_phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_phi = context__.vals_r("mean_phi")[(1 - 1)];
      double mean_phi_free__;
      mean_phi_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_phi_free__ = stan::math::lub_free(mean_phi, 0, 1);
      double mean_p;
      mean_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      double mean_p_free__;
      mean_p_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      mean_p_free__ = stan::math::lub_free(mean_p, 0, 1);
      Eigen::Matrix<double, -1, 1> gamma;
      gamma = Eigen::Matrix<double, -1, 1>(n_occasions);
      stan::math::fill(gamma, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> gamma_flat__;
        current_statement__ = 3;
        assign(gamma_flat__, nil_index_list(), context__.vals_r("gamma"),
          "assigning variable gamma_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 3;
          assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
            gamma_flat__[(pos__ - 1)], "assigning variable gamma");
          current_statement__ = 3;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> gamma_free__;
      gamma_free__ = Eigen::Matrix<double, -1, 1>(n_occasions);
      stan::math::fill(gamma_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        current_statement__ = 3;
        assign(gamma_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(gamma[(sym1__ - 1)], 0, 1),
          "assigning variable gamma_free__");}
      Eigen::Matrix<double, -1, 1> epsilon;
      epsilon = Eigen::Matrix<double, -1, 1>(epsilon_1dim__);
      stan::math::fill(epsilon, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> epsilon_flat__;
        current_statement__ = 4;
        assign(epsilon_flat__, nil_index_list(), context__.vals_r("epsilon"),
          "assigning variable epsilon_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= epsilon_1dim__; ++sym1__) {
          current_statement__ = 4;
          assign(epsilon, cons_list(index_uni(sym1__), nil_index_list()),
            epsilon_flat__[(pos__ - 1)], "assigning variable epsilon");
          current_statement__ = 4;
          pos__ = (pos__ + 1);}
      }
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      double sigma_free__;
      sigma_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      sigma_free__ = stan::math::lub_free(sigma, 0, 5);
      vars__.emplace_back(mean_phi_free__);
      vars__.emplace_back(mean_p_free__);
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        vars__.emplace_back(gamma_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= epsilon_1dim__; ++sym1__) {
        vars__.emplace_back(epsilon[(sym1__ - 1)]);}
      vars__.emplace_back(sigma_free__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("mean_phi");
    names__.emplace_back("mean_p");
    names__.emplace_back("gamma");
    names__.emplace_back("epsilon");
    names__.emplace_back("sigma");
    names__.emplace_back("phi");
    names__.emplace_back("p");
    names__.emplace_back("chi");
    names__.emplace_back("sigma2");
    names__.emplace_back("psi");
    names__.emplace_back("b");
    names__.emplace_back("Nsuper");
    names__.emplace_back("N");
    names__.emplace_back("B");
    names__.emplace_back("z");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(epsilon_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(phi_2dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_occasions)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(n_occasions)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "gamma" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= epsilon_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= phi_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "psi");
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
        }}
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "N" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "B" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "gamma" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= epsilon_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "epsilon" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= phi_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "sigma2");
      param_names__.emplace_back(std::string() + "psi");
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
        }}
      param_names__.emplace_back(std::string() + "Nsuper");
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "N" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "B" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" << epsilon_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << phi_2dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" << epsilon_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << phi_2dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = inlining_fail2_model_namespace::inlining_fail2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return inlining_fail2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp lcm-experiment.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_experiment_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'lcm-experiment.stan', line 2, column 2 to column 8)",
                                                      " (in 'lcm-experiment.stan', line 5, column 2 to column 13)",
                                                      " (in 'lcm-experiment.stan', line 6, column 2 to column 9)",
                                                      " (in 'lcm-experiment.stan', line 8, column 4 to column 27)",
                                                      " (in 'lcm-experiment.stan', line 9, column 4 to column 35)",
                                                      " (in 'lcm-experiment.stan', line 7, column 2 to line 10, column 3)",
                                                      " (in 'lcm-experiment.stan', line 11, column 2 to column 38)"};



class lcm_experiment_model final : public model_base_crtp<lcm_experiment_model> {

 private:
  int j;
  double z;
  double x;
  double i;
 
 public:
  ~lcm_experiment_model() { }
  
  inline std::string model_name() const final { return "lcm_experiment_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  lcm_experiment_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "lcm_experiment_model_namespace::lcm_experiment_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 1;
      context__.validate_dims("data initialization","j","int",
          context__.to_vec());
      j = std::numeric_limits<int>::min();
      
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      current_statement__ = 2;
      z = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      z = 1;
      current_statement__ = 3;
      x = std::numeric_limits<double>::quiet_NaN();
      
      {
        current_statement__ = 4;
        x = normal_rng(123, 1, base_rng__);
        current_statement__ = 5;
        z = normal_rng(((stan::math::sqrt(j) * 2) + 1), 1, base_rng__);
      }
      current_statement__ = 7;
      i = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      i = normal_rng(((stan::math::sqrt(j) * 2) + 1), 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "lcm_experiment_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "lcm_experiment_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = lcm_experiment_model_namespace::lcm_experiment_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lcm_experiment_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp lcm-experiment2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_experiment2_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'lcm-experiment2.stan', line 2, column 2 to column 9)",
                                                      " (in 'lcm-experiment2.stan', line 5, column 2 to column 18)",
                                                      " (in 'lcm-experiment2.stan', line 7, column 4 to column 11)",
                                                      " (in 'lcm-experiment2.stan', line 6, column 17 to line 8, column 3)",
                                                      " (in 'lcm-experiment2.stan', line 6, column 2 to line 8, column 3)",
                                                      " (in 'lcm-experiment2.stan', line 10, column 4 to column 11)",
                                                      " (in 'lcm-experiment2.stan', line 9, column 2 to line 10, column 11)",
                                                      " (in 'lcm-experiment2.stan', line 11, column 2 to column 14)"};



class lcm_experiment2_model final : public model_base_crtp<lcm_experiment2_model> {

 private:
  
 
 public:
  ~lcm_experiment2_model() { }
  
  inline std::string model_name() const final { return "lcm_experiment2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  lcm_experiment2_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "lcm_experiment2_model_namespace::lcm_experiment2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "lcm_experiment2_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ x;
      x = DUMMY_VAR__;
      
      current_statement__ = 1;
      x = in__.scalar();
      {
        local_scalar_t__ y;
        y = DUMMY_VAR__;
        
        current_statement__ = 2;
        y = stan::math::log(x);
        current_statement__ = 5;
        for (int j = 1; j <= 1; ++j) { current_statement__ = 3;
                                       y = (y + 1);}
        current_statement__ = 7;
        if (logical_gt(1, 0)) {
          current_statement__ = 6;
          y = (y + 1);
        } 
        current_statement__ = 8;
        lp_accum__.add(y);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "lcm_experiment2_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double x;
      x = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      x = in__.scalar();
      vars__.emplace_back(x);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double x;
      x = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      x = context__.vals_r("x")[(1 - 1)];
      vars__.emplace_back(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("x");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "x");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = lcm_experiment2_model_namespace::lcm_experiment2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lcm_experiment2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp lcm-fails.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_fails_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'lcm-fails.stan', line 6, column 2 to column 16)",
                                                      " (in 'lcm-fails.stan', line 9, column 2 to column 22)",
                                                      " (in 'lcm-fails.stan', line 2, column 2 to column 17)",
                                                      " (in 'lcm-fails.stan', line 3, column 9 to column 10)",
                                                      " (in 'lcm-fails.stan', line 3, column 2 to column 12)",
                                                      " (in 'lcm-fails.stan', line 6, column 13 to column 14)"};



class lcm_fails_model final : public model_base_crtp<lcm_fails_model> {

 private:
  int J;
  std::vector<double> y;
 
 public:
  ~lcm_fails_model() { }
  
  inline std::string model_name() const final { return "lcm_fails_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  lcm_fails_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "lcm_fails_model_namespace::lcm_fails_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 3;
      context__.validate_dims("data initialization","J","int",
          context__.to_vec());
      J = std::numeric_limits<int>::min();
      
      current_statement__ = 3;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 3;
      current_statement__ = 3;
      check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 4;
      validate_non_negative_index("y", "J", J);
      current_statement__ = 5;
      context__.validate_dims("data initialization","y","double",
          context__.to_vec(J));
      y = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      assign(y, nil_index_list(), context__.vals_r("y"),
        "assigning variable y");
      current_statement__ = 6;
      validate_non_negative_index("theta", "J", J);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += J;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "lcm_fails_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      std::vector<local_scalar_t__> theta;
      theta = std::vector<local_scalar_t__>(J, DUMMY_VAR__);
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        current_statement__ = 1;
        assign(theta, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable theta");}
      {
        current_statement__ = 2;
        lp_accum__.add(normal_lpdf<propto__>(y, theta, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "lcm_fails_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      std::vector<double> theta;
      theta = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        current_statement__ = 1;
        assign(theta, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable theta");}
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        vars__.emplace_back(theta[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      std::vector<double> theta;
      theta = std::vector<double>(J, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      assign(theta, nil_index_list(), context__.vals_r("theta"),
        "assigning variable theta");
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        vars__.emplace_back(theta[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("theta");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(J)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << J << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << J << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = lcm_fails_model_namespace::lcm_fails_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lcm_fails_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp lcm-fails2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_fails2_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'lcm-fails2.stan', line 69, column 2 to column 33)",
                                                      " (in 'lcm-fails2.stan', line 70, column 2 to column 31)",
                                                      " (in 'lcm-fails2.stan', line 74, column 2 to column 51)",
                                                      " (in 'lcm-fails2.stan', line 75, column 2 to column 49)",
                                                      " (in 'lcm-fails2.stan', line 76, column 2 to column 49)",
                                                      " (in 'lcm-fails2.stan', line 81, column 6 to column 20)",
                                                      " (in 'lcm-fails2.stan', line 82, column 6 to column 18)",
                                                      " (in 'lcm-fails2.stan', line 80, column 32 to line 83, column 5)",
                                                      " (in 'lcm-fails2.stan', line 80, column 4 to line 83, column 5)",
                                                      " (in 'lcm-fails2.stan', line 85, column 6 to column 27)",
                                                      " (in 'lcm-fails2.stan', line 86, column 6 to column 23)",
                                                      " (in 'lcm-fails2.stan', line 84, column 38 to line 87, column 5)",
                                                      " (in 'lcm-fails2.stan', line 84, column 4 to line 87, column 5)",
                                                      " (in 'lcm-fails2.stan', line 79, column 20 to line 88, column 3)",
                                                      " (in 'lcm-fails2.stan', line 79, column 2 to line 88, column 3)",
                                                      " (in 'lcm-fails2.stan', line 90, column 2 to column 51)",
                                                      " (in 'lcm-fails2.stan', line 103, column 8 to column 37)",
                                                      " (in 'lcm-fails2.stan', line 104, column 8 to column 41)",
                                                      " (in 'lcm-fails2.stan', line 102, column 40 to line 105, column 7)",
                                                      " (in 'lcm-fails2.stan', line 102, column 6 to line 105, column 7)",
                                                      " (in 'lcm-fails2.stan', line 106, column 6 to column 37)",
                                                      " (in 'lcm-fails2.stan', line 101, column 22 to line 107, column 5)",
                                                      " (in 'lcm-fails2.stan', line 101, column 4 to line 107, column 5)",
                                                      " (in 'lcm-fails2.stan', line 100, column 20 to line 108, column 3)",
                                                      " (in 'lcm-fails2.stan', line 100, column 2 to line 108, column 3)",
                                                      " (in 'lcm-fails2.stan', line 50, column 2 to column 20)",
                                                      " (in 'lcm-fails2.stan', line 51, column 2 to column 27)",
                                                      " (in 'lcm-fails2.stan', line 52, column 25 to column 29)",
                                                      " (in 'lcm-fails2.stan', line 52, column 31 to column 42)",
                                                      " (in 'lcm-fails2.stan', line 52, column 2 to column 44)",
                                                      " (in 'lcm-fails2.stan', line 56, column 2 to column 38)",
                                                      " (in 'lcm-fails2.stan', line 58, column 39 to column 43)",
                                                      " (in 'lcm-fails2.stan', line 58, column 2 to column 45)",
                                                      " (in 'lcm-fails2.stan', line 59, column 38 to column 42)",
                                                      " (in 'lcm-fails2.stan', line 59, column 2 to column 44)",
                                                      " (in 'lcm-fails2.stan', line 63, column 4 to column 35)",
                                                      " (in 'lcm-fails2.stan', line 62, column 2 to line 63, column 35)",
                                                      " (in 'lcm-fails2.stan', line 65, column 4 to column 33)",
                                                      " (in 'lcm-fails2.stan', line 64, column 2 to line 65, column 33)",
                                                      " (in 'lcm-fails2.stan', line 74, column 26 to column 30)",
                                                      " (in 'lcm-fails2.stan', line 74, column 32 to column 45)",
                                                      " (in 'lcm-fails2.stan', line 75, column 26 to column 30)",
                                                      " (in 'lcm-fails2.stan', line 75, column 32 to column 45)",
                                                      " (in 'lcm-fails2.stan', line 76, column 26 to column 30)",
                                                      " (in 'lcm-fails2.stan', line 76, column 32 to column 43)",
                                                      " (in 'lcm-fails2.stan', line 8, column 8 to column 17)",
                                                      " (in 'lcm-fails2.stan', line 7, column 6 to line 8, column 17)",
                                                      " (in 'lcm-fails2.stan', line 6, column 4 to line 8, column 17)",
                                                      " (in 'lcm-fails2.stan', line 9, column 4 to column 13)",
                                                      " (in 'lcm-fails2.stan', line 5, column 31 to line 10, column 3)",
                                                      " (in 'lcm-fails2.stan', line 15, column 6 to column 32)",
                                                      " (in 'lcm-fails2.stan', line 19, column 8 to column 17)",
                                                      " (in 'lcm-fails2.stan', line 18, column 6 to line 19, column 17)",
                                                      " (in 'lcm-fails2.stan', line 13, column 37 to line 20, column 5)",
                                                      " (in 'lcm-fails2.stan', line 13, column 4 to line 20, column 5)",
                                                      " (in 'lcm-fails2.stan', line 21, column 4 to column 13)",
                                                      " (in 'lcm-fails2.stan', line 12, column 30 to line 22, column 3)",
                                                      " (in 'lcm-fails2.stan', line 26, column 11 to column 15)",
                                                      " (in 'lcm-fails2.stan', line 26, column 17 to column 28)",
                                                      " (in 'lcm-fails2.stan', line 26, column 4 to column 34)",
                                                      " (in 'lcm-fails2.stan', line 29, column 6 to column 32)",
                                                      " (in 'lcm-fails2.stan', line 32, column 8 to column 37)",
                                                      " (in 'lcm-fails2.stan', line 33, column 8 to column 32)",
                                                      " (in 'lcm-fails2.stan', line 41, column 8 to line 42, column 83)",
                                                      " (in 'lcm-fails2.stan', line 30, column 37 to line 43, column 7)",
                                                      " (in 'lcm-fails2.stan', line 30, column 6 to line 43, column 7)",
                                                      " (in 'lcm-fails2.stan', line 28, column 22 to line 44, column 5)",
                                                      " (in 'lcm-fails2.stan', line 28, column 4 to line 44, column 5)",
                                                      " (in 'lcm-fails2.stan', line 45, column 4 to column 15)",
                                                      " (in 'lcm-fails2.stan', line 25, column 47 to line 46, column 3)"};


int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 48;
    for (int k = 1; k <= size(y_i); ++k) {
      current_statement__ = 47;
      if (y_i[(k - 1)]) {
        current_statement__ = 46;
        return k;
      } }
    current_statement__ = 49;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 55;
    for (int k_rev = 0; k_rev <= (size(y_i) - 1); ++k_rev) {
      int k;
      k = std::numeric_limits<int>::min();
      
      current_statement__ = 51;
      k = (size(y_i) - k_rev);
      current_statement__ = 53;
      if (y_i[(k - 1)]) {
        current_statement__ = 52;
        return k;
      } }
    current_statement__ = 56;
    return 0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions, const T2__& p_arg__,
                const T3__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  const auto& p = to_ref(p_arg__);
  const auto& phi = to_ref(phi_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 58;
    validate_non_negative_index("chi", "nind", nind);
    current_statement__ = 59;
    validate_non_negative_index("chi", "n_occasions", n_occasions);
    Eigen::Matrix<local_scalar_t__, -1, -1> chi;
    chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
    stan::math::fill(chi, DUMMY_VAR__);
    
    current_statement__ = 68;
    for (int i = 1; i <= nind; ++i) {
      current_statement__ = 61;
      assign(chi,
        cons_list(index_uni(i),
          cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
        "assigning variable chi");
      current_statement__ = 66;
      for (int t = 1; t <= (n_occasions - 1); ++t) {
        int t_curr;
        t_curr = std::numeric_limits<int>::min();
        
        current_statement__ = 62;
        t_curr = (n_occasions - t);
        int t_next;
        t_next = std::numeric_limits<int>::min();
        
        current_statement__ = 63;
        t_next = (t_curr + 1);
        current_statement__ = 64;
        assign(chi,
          cons_list(index_uni(i),
            cons_list(index_uni(t_curr), nil_index_list())),
          ((1 -
             rvalue(phi,
               cons_list(index_uni(i),
                 cons_list(index_uni(t_curr), nil_index_list())), "phi")) +
            ((rvalue(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t_curr), nil_index_list())), "phi") *
               (1 -
                 rvalue(p,
                   cons_list(index_uni(i),
                     cons_list(index_uni((t_next - 1)), nil_index_list())),
                   "p"))) *
              rvalue(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t_next), nil_index_list())), "chi"))),
          "assigning variable chi");}}
    current_statement__ = 69;
    return chi;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct prob_uncaptured_functor__ {
template <typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, -1>
operator()(const int& nind, const int& n_occasions, const T2__& p,
           const T3__& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}
};

class lcm_fails2_model final : public model_base_crtp<lcm_fails2_model> {

 private:
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last;
 
 public:
  ~lcm_fails2_model() { }
  
  inline std::string model_name() const final { return "lcm_fails2_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  lcm_fails2_model(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "lcm_fails2_model_namespace::lcm_fails2_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 26;
      context__.validate_dims("data initialization","nind","int",
          context__.to_vec());
      nind = std::numeric_limits<int>::min();
      
      current_statement__ = 26;
      nind = context__.vals_i("nind")[(1 - 1)];
      current_statement__ = 26;
      current_statement__ = 26;
      check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 27;
      context__.validate_dims("data initialization","n_occasions","int",
          context__.to_vec());
      n_occasions = std::numeric_limits<int>::min();
      
      current_statement__ = 27;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 27;
      current_statement__ = 27;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 2);
      current_statement__ = 28;
      validate_non_negative_index("y", "nind", nind);
      current_statement__ = 29;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      current_statement__ = 30;
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(nind, n_occasions));
      y = std::vector<std::vector<int>>(nind, std::vector<int>(n_occasions, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 30;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 30;
        pos__ = 1;
        current_statement__ = 30;
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 30;
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            current_statement__ = 30;
            assign(y,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y_flat__[(pos__ - 1)], "assigning variable y");
            current_statement__ = 30;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 30;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 30;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 30;
          current_statement__ = 30;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 30;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 30;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 30;
          current_statement__ = 30;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 31;
      n_occ_minus_1 = std::numeric_limits<int>::min();
      
      current_statement__ = 31;
      n_occ_minus_1 = (n_occasions - 1);
      current_statement__ = 32;
      validate_non_negative_index("first", "nind", nind);
      current_statement__ = 33;
      first = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 34;
      validate_non_negative_index("last", "nind", nind);
      current_statement__ = 35;
      last = std::vector<int>(nind, std::numeric_limits<int>::min());
      
      current_statement__ = 37;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 36;
        assign(first, cons_list(index_uni(i), nil_index_list()),
          first_capture(y[(i - 1)], pstream__), "assigning variable first");}
      current_statement__ = 39;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 38;
        assign(last, cons_list(index_uni(i), nil_index_list()),
          last_capture(y[(i - 1)], pstream__), "assigning variable last");}
      current_statement__ = 33;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 33;
        current_statement__ = 33;
        check_greater_or_equal(function__, "first[sym1__]",
                               first[(sym1__ - 1)], 0);}
      current_statement__ = 33;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 33;
        current_statement__ = 33;
        check_less_or_equal(function__, "first[sym1__]", first[(sym1__ - 1)],
                            n_occasions);}
      current_statement__ = 35;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 35;
        current_statement__ = 35;
        check_greater_or_equal(function__, "last[sym1__]",
                               last[(sym1__ - 1)], 0);}
      current_statement__ = 35;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 35;
        current_statement__ = 35;
        check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                            n_occasions);}
      current_statement__ = 40;
      validate_non_negative_index("phi", "nind", nind);
      current_statement__ = 41;
      validate_non_negative_index("phi", "n_occ_minus_1", n_occ_minus_1);
      current_statement__ = 42;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 43;
      validate_non_negative_index("p", "n_occ_minus_1", n_occ_minus_1);
      current_statement__ = 44;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 45;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "lcm_fails2_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ mean_phi;
      mean_phi = DUMMY_VAR__;
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1, lp__);
      } else {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      }
      local_scalar_t__ mean_p;
      mean_p = DUMMY_VAR__;
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1, lp__);
      } else {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      }
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(phi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(p, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, DUMMY_VAR__);
      
      current_statement__ = 15;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 9;
        for (int t = 1; t <= (first[(i - 1)] - 1); ++t) {
          current_statement__ = 6;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable p");}
        current_statement__ = 13;
        for (int t = first[(i - 1)]; t <= n_occ_minus_1; ++t) {
          current_statement__ = 10;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), mean_phi,
            "assigning variable phi");
          current_statement__ = 11;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), mean_p,
            "assigning variable p");}}
      current_statement__ = 16;
      assign(chi, nil_index_list(),
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 3;
          current_statement__ = 3;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "phi"), 0);}}
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 3;
          current_statement__ = 3;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "phi"), 1);}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 4;
          current_statement__ = 4;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "p"), 0);}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 4;
          current_statement__ = 4;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "p"), 1);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(chi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "chi"), 0);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(chi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "chi"), 1);}}
      {
        current_statement__ = 25;
        for (int i = 1; i <= nind; ++i) {
          current_statement__ = 23;
          if (logical_gt(first[(i - 1)], 0)) {
            current_statement__ = 20;
            for (int t = (first[(i - 1)] + 1); t <= last[(i - 1)]; ++t) {
              current_statement__ = 17;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(1,
                  rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni((t - 1)), nil_index_list())),
                    "phi")));
              current_statement__ = 18;
              lp_accum__.add(
                bernoulli_lpmf<propto__>(y[(i - 1)][(t - 1)],
                  rvalue(p,
                    cons_list(index_uni(i),
                      cons_list(index_uni((t - 1)), nil_index_list())), "p")));
            }
            current_statement__ = 21;
            lp_accum__.add(
              bernoulli_lpmf<propto__>(1,
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(last[(i - 1)]), nil_index_list())),
                  "chi")));
          } }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "lcm_fails2_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double mean_phi;
      mean_phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      double mean_p;
      mean_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      Eigen::Matrix<double, -1, -1> phi;
      phi = Eigen::Matrix<double, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(phi, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(nind, n_occ_minus_1);
      stan::math::fill(p, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> chi;
      chi = Eigen::Matrix<double, -1, -1>(nind, n_occasions);
      stan::math::fill(chi, std::numeric_limits<double>::quiet_NaN());
      
      vars__.emplace_back(mean_phi);
      vars__.emplace_back(mean_p);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 15;
      for (int i = 1; i <= nind; ++i) {
        current_statement__ = 9;
        for (int t = 1; t <= (first[(i - 1)] - 1); ++t) {
          current_statement__ = 6;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), 0,
            "assigning variable p");}
        current_statement__ = 13;
        for (int t = first[(i - 1)]; t <= n_occ_minus_1; ++t) {
          current_statement__ = 10;
          assign(phi,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), mean_phi,
            "assigning variable phi");
          current_statement__ = 11;
          assign(p,
            cons_list(index_uni(i),
              cons_list(index_uni(t), nil_index_list())), mean_p,
            "assigning variable p");}}
      current_statement__ = 16;
      assign(chi, nil_index_list(),
        prob_uncaptured(nind, n_occasions, p, phi, pstream__),
        "assigning variable chi");
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 3;
          current_statement__ = 3;
          check_greater_or_equal(function__, "phi[sym1__, sym2__]",
                                 rvalue(phi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "phi"), 0);}}
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 3;
          current_statement__ = 3;
          check_less_or_equal(function__, "phi[sym1__, sym2__]",
                              rvalue(phi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "phi"), 1);}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 4;
          current_statement__ = 4;
          check_greater_or_equal(function__, "p[sym1__, sym2__]",
                                 rvalue(p,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "p"), 0);}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= n_occ_minus_1; ++sym2__) {
          current_statement__ = 4;
          current_statement__ = 4;
          check_less_or_equal(function__, "p[sym1__, sym2__]",
                              rvalue(p,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "p"), 1);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_greater_or_equal(function__, "chi[sym1__, sym2__]",
                                 rvalue(chi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "chi"), 0);}}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nind; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= n_occasions; ++sym2__) {
          current_statement__ = 5;
          current_statement__ = 5;
          check_less_or_equal(function__, "chi[sym1__, sym2__]",
                              rvalue(chi,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "chi"), 1);}}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            vars__.emplace_back(
              rvalue(phi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "phi"));}}
        for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            vars__.emplace_back(
              rvalue(p,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "p"));}}
        for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            vars__.emplace_back(
              rvalue(chi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "chi"));}}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double mean_phi;
      mean_phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_phi = context__.vals_r("mean_phi")[(1 - 1)];
      double mean_phi_free__;
      mean_phi_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mean_phi_free__ = stan::math::lub_free(mean_phi, 0, 1);
      double mean_p;
      mean_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      double mean_p_free__;
      mean_p_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      mean_p_free__ = stan::math::lub_free(mean_p, 0, 1);
      vars__.emplace_back(mean_phi_free__);
      vars__.emplace_back(mean_p_free__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("mean_phi");
    names__.emplace_back("mean_p");
    names__.emplace_back("phi");
    names__.emplace_back("p");
    names__.emplace_back("chi");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind),
                                             static_cast<size_t>(n_occ_minus_1)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind),
                                             static_cast<size_t>(n_occ_minus_1)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nind),
                                             static_cast<size_t>(n_occasions)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mean_phi");
    param_names__.emplace_back(std::string() + "mean_p");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "phi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occ_minus_1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_occasions; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nind; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "chi" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = lcm_fails2_model_namespace::lcm_fails2_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lcm_fails2_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp lupdf-inlining.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lupdf_inlining_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'lupdf-inlining.stan', line 16, column 4 to column 12)",
                                                      " (in 'lupdf-inlining.stan', line 19, column 4 to column 32)",
                                                      " (in 'lupdf-inlining.stan', line 26, column 4 to column 30)",
                                                      " (in 'lupdf-inlining.stan', line 27, column 4 to column 31)",
                                                      " (in 'lupdf-inlining.stan', line 22, column 4 to column 29)",
                                                      " (in 'lupdf-inlining.stan', line 23, column 4 to column 31)",
                                                      " (in 'lupdf-inlining.stan', line 13, column 4 to column 10)",
                                                      " (in 'lupdf-inlining.stan', line 3, column 8 to column 36)",
                                                      " (in 'lupdf-inlining.stan', line 2, column 35 to line 4, column 5)",
                                                      " (in 'lupdf-inlining.stan', line 6, column 8 to column 35)",
                                                      " (in 'lupdf-inlining.stan', line 5, column 34 to line 7, column 5)",
                                                      " (in 'lupdf-inlining.stan', line 9, column 8 to column 32)",
                                                      " (in 'lupdf-inlining.stan', line 8, column 26 to line 10, column 5)"};


template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
foo_lpdf(const T0__& x, const T1__& mu, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 8;
    return normal_lpdf<propto__>(x, mu, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct foo_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
operator()(const T0__& x, const T1__& mu, std::ostream* pstream__)  const 
{
return foo_lpdf<propto__>(x, mu, pstream__);
}
};

template <bool propto__, typename T1__>
stan::promote_args_t<T1__>
bar_lpmf(const int& n, const T1__& mu, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__>;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 10;
    return poisson_lpmf<propto__>(n, mu);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct bar_lpmf_functor__ {
template <bool propto__, typename T1__>
stan::promote_args_t<T1__>
operator()(const int& n, const T1__& mu, std::ostream* pstream__)  const 
{
return bar_lpmf<propto__>(n, mu, pstream__);
}
};

template <bool propto__, typename T0__>
stan::promote_args_t<T0__>
baz_lpdf(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 12;
    return foo_lpdf<propto__>(x, 0.5, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct baz_lpdf_functor__ {
template <bool propto__, typename T0__>
stan::promote_args_t<T0__>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return baz_lpdf<propto__>(x, pstream__);
}
};

class lupdf_inlining_model final : public model_base_crtp<lupdf_inlining_model> {

 private:
  int n;
 
 public:
  ~lupdf_inlining_model() { }
  
  inline std::string model_name() const final { return "lupdf_inlining_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  lupdf_inlining_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "lupdf_inlining_model_namespace::lupdf_inlining_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 7;
      context__.validate_dims("data initialization","n","int",
          context__.to_vec());
      n = std::numeric_limits<int>::min();
      
      current_statement__ = 7;
      n = context__.vals_i("n")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "lupdf_inlining_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ mu;
      mu = DUMMY_VAR__;
      
      current_statement__ = 1;
      mu = in__.scalar();
      local_scalar_t__ tp;
      tp = DUMMY_VAR__;
      
      current_statement__ = 2;
      tp = foo_lpdf<false>(mu, 1.0, pstream__);
      {
        current_statement__ = 5;
        lp_accum__.add(baz_lpdf<propto__>(mu, pstream__));
        current_statement__ = 6;
        lp_accum__.add(bar_lpmf<propto__>(n, mu, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "lupdf_inlining_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double mu;
      mu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mu = in__.scalar();
      double tp;
      tp = std::numeric_limits<double>::quiet_NaN();
      
      vars__.emplace_back(mu);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 2;
      tp = foo_lpdf<false>(mu, 1.0, pstream__);
      if (emit_transformed_parameters__) {
        vars__.emplace_back(tp);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double lbaz;
      lbaz = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      lbaz = baz_lpdf<false>(mu, pstream__);
      double lbar;
      lbar = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      lbar = bar_lpmf<false>(n, mu, pstream__);
      vars__.emplace_back(lbaz);
      vars__.emplace_back(lbar);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double mu;
      mu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      mu = context__.vals_r("mu")[(1 - 1)];
      vars__.emplace_back(mu);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("mu");
    names__.emplace_back("tp");
    names__.emplace_back("lbaz");
    names__.emplace_back("lbar");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "lbaz");
      param_names__.emplace_back(std::string() + "lbar");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "mu");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "tp");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "lbaz");
      param_names__.emplace_back(std::string() + "lbar");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tp\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"lbaz\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"lbar\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tp\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"lbaz\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"lbar\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = lupdf_inlining_model_namespace::lupdf_inlining_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lupdf_inlining_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp off-dce.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace off_dce_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'off-dce.stan', line 23, column 2 to column 17)",
                                                      " (in 'off-dce.stan', line 24, column 2 to column 16)",
                                                      " (in 'off-dce.stan', line 25, column 2 to column 15)",
                                                      " (in 'off-dce.stan', line 26, column 2 to column 14)",
                                                      " (in 'off-dce.stan', line 30, column 2 to column 22)",
                                                      " (in 'off-dce.stan', line 31, column 2 to column 23)",
                                                      " (in 'off-dce.stan', line 33, column 2 to column 39)",
                                                      " (in 'off-dce.stan', line 34, column 2 to column 48)",
                                                      " (in 'off-dce.stan', line 58, column 2 to column 13)",
                                                      " (in 'off-dce.stan', line 59, column 2 to column 18)",
                                                      " (in 'off-dce.stan', line 60, column 2 to column 11)",
                                                      " (in 'off-dce.stan', line 70, column 6 to column 21)",
                                                      " (in 'off-dce.stan', line 71, column 6 to column 15)",
                                                      " (in 'off-dce.stan', line 69, column 11 to line 72, column 5)",
                                                      " (in 'off-dce.stan', line 64, column 6 to column 41)",
                                                      " (in 'off-dce.stan', line 65, column 13 to column 14)",
                                                      " (in 'off-dce.stan', line 65, column 6 to column 44)",
                                                      " (in 'off-dce.stan', line 66, column 6 to column 26)",
                                                      " (in 'off-dce.stan', line 67, column 6 to column 55)",
                                                      " (in 'off-dce.stan', line 68, column 6 to column 39)",
                                                      " (in 'off-dce.stan', line 63, column 23 to line 69, column 5)",
                                                      " (in 'off-dce.stan', line 63, column 4 to line 72, column 5)",
                                                      " (in 'off-dce.stan', line 62, column 17 to line 73, column 3)",
                                                      " (in 'off-dce.stan', line 62, column 2 to line 73, column 3)",
                                                      " (in 'off-dce.stan', line 74, column 2 to column 18)",
                                                      " (in 'off-dce.stan', line 49, column 6 to line 52, column 68)",
                                                      " (in 'off-dce.stan', line 47, column 11 to line 53, column 5)",
                                                      " (in 'off-dce.stan', line 45, column 6 to column 40)",
                                                      " (in 'off-dce.stan', line 46, column 6 to column 41)",
                                                      " (in 'off-dce.stan', line 44, column 18 to line 47, column 5)",
                                                      " (in 'off-dce.stan', line 44, column 4 to line 53, column 5)",
                                                      " (in 'off-dce.stan', line 43, column 17 to line 54, column 3)",
                                                      " (in 'off-dce.stan', line 43, column 2 to line 54, column 3)",
                                                      " (in 'off-dce.stan', line 4, column 2 to column 17)",
                                                      " (in 'off-dce.stan', line 5, column 2 to column 17)",
                                                      " (in 'off-dce.stan', line 6, column 25 to column 26)",
                                                      " (in 'off-dce.stan', line 6, column 28 to column 29)",
                                                      " (in 'off-dce.stan', line 6, column 2 to column 31)",
                                                      " (in 'off-dce.stan', line 7, column 9 to column 10)",
                                                      " (in 'off-dce.stan', line 7, column 2 to column 14)",
                                                      " (in 'off-dce.stan', line 11, column 29 to column 30)",
                                                      " (in 'off-dce.stan', line 11, column 2 to column 32)",
                                                      " (in 'off-dce.stan', line 12, column 2 to column 31)",
                                                      " (in 'off-dce.stan', line 14, column 2 to column 14)",
                                                      " (in 'off-dce.stan', line 16, column 4 to column 25)",
                                                      " (in 'off-dce.stan', line 18, column 6 to column 28)",
                                                      " (in 'off-dce.stan', line 17, column 4 to line 18, column 28)",
                                                      " (in 'off-dce.stan', line 15, column 17 to line 19, column 3)",
                                                      " (in 'off-dce.stan', line 15, column 2 to line 19, column 3)",
                                                      " (in 'off-dce.stan', line 30, column 9 to column 10)",
                                                      " (in 'off-dce.stan', line 31, column 9 to column 10)",
                                                      " (in 'off-dce.stan', line 31, column 12 to column 13)",
                                                      " (in 'off-dce.stan', line 59, column 15 to column 16)",
                                                      " (in 'off-dce.stan', line 60, column 8 to column 9)"};



class off_dce_model final : public model_base_crtp<off_dce_model> {

 private:
  int R;
  int T;
  std::vector<std::vector<int>> y;
  Eigen::Matrix<double, -1, 1> X;
  std::vector<int> sum_y;
  int occ_obs;
 
 public:
  ~off_dce_model() { }
  
  inline std::string model_name() const final { return "off_dce_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  off_dce_model(stan::io::var_context& context__,
                unsigned int random_seed__ = 0,
                std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "off_dce_model_namespace::off_dce_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 34;
      context__.validate_dims("data initialization","R","int",
          context__.to_vec());
      R = std::numeric_limits<int>::min();
      
      current_statement__ = 34;
      R = context__.vals_i("R")[(1 - 1)];
      current_statement__ = 34;
      current_statement__ = 34;
      check_greater_or_equal(function__, "R", R, 1);
      current_statement__ = 35;
      context__.validate_dims("data initialization","T","int",
          context__.to_vec());
      T = std::numeric_limits<int>::min();
      
      current_statement__ = 35;
      T = context__.vals_i("T")[(1 - 1)];
      current_statement__ = 35;
      current_statement__ = 35;
      check_greater_or_equal(function__, "T", T, 1);
      current_statement__ = 36;
      validate_non_negative_index("y", "R", R);
      current_statement__ = 37;
      validate_non_negative_index("y", "T", T);
      current_statement__ = 38;
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(R, T));
      y = std::vector<std::vector<int>>(R, std::vector<int>(T, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 38;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 38;
        pos__ = 1;
        current_statement__ = 38;
        for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
          current_statement__ = 38;
          for (int sym2__ = 1; sym2__ <= R; ++sym2__) {
            current_statement__ = 38;
            assign(y,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y_flat__[(pos__ - 1)], "assigning variable y");
            current_statement__ = 38;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 38;
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        current_statement__ = 38;
        for (int sym2__ = 1; sym2__ <= T; ++sym2__) {
          current_statement__ = 38;
          current_statement__ = 38;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 38;
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        current_statement__ = 38;
        for (int sym2__ = 1; sym2__ <= T; ++sym2__) {
          current_statement__ = 38;
          current_statement__ = 38;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 39;
      validate_non_negative_index("X", "R", R);
      current_statement__ = 40;
      context__.validate_dims("data initialization","X","double",
          context__.to_vec(R));
      X = Eigen::Matrix<double, -1, 1>(R);
      stan::math::fill(X, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> X_flat__;
        current_statement__ = 40;
        assign(X_flat__, nil_index_list(), context__.vals_r("X"),
          "assigning variable X_flat__");
        current_statement__ = 40;
        pos__ = 1;
        current_statement__ = 40;
        for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
          current_statement__ = 40;
          assign(X, cons_list(index_uni(sym1__), nil_index_list()),
            X_flat__[(pos__ - 1)], "assigning variable X");
          current_statement__ = 40;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 41;
      validate_non_negative_index("sum_y", "R", R);
      current_statement__ = 42;
      sum_y = std::vector<int>(R, std::numeric_limits<int>::min());
      
      current_statement__ = 43;
      occ_obs = std::numeric_limits<int>::min();
      
      current_statement__ = 44;
      occ_obs = 0;
      current_statement__ = 49;
      for (int i = 1; i <= R; ++i) {
        current_statement__ = 45;
        assign(sum_y, cons_list(index_uni(i), nil_index_list()),
          sum(y[(i - 1)]), "assigning variable sum_y");
        current_statement__ = 47;
        if (sum_y[(i - 1)]) {
          current_statement__ = 46;
          occ_obs = (occ_obs + 1);
        } }
      current_statement__ = 42;
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        current_statement__ = 42;
        current_statement__ = 42;
        check_greater_or_equal(function__, "sum_y[sym1__]",
                               sum_y[(sym1__ - 1)], 0);}
      current_statement__ = 42;
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        current_statement__ = 42;
        current_statement__ = 42;
        check_less_or_equal(function__, "sum_y[sym1__]", sum_y[(sym1__ - 1)],
                            T);}
      current_statement__ = 43;
      current_statement__ = 43;
      check_greater_or_equal(function__, "occ_obs", occ_obs, 0);
      current_statement__ = 43;
      current_statement__ = 43;
      check_less_or_equal(function__, "occ_obs", occ_obs, R);
      current_statement__ = 50;
      validate_non_negative_index("logit_psi", "R", R);
      current_statement__ = 51;
      validate_non_negative_index("logit_p", "R", R);
      current_statement__ = 52;
      validate_non_negative_index("logit_p", "T", T);
      current_statement__ = 53;
      validate_non_negative_index("psi_con", "R", R);
      current_statement__ = 54;
      validate_non_negative_index("z", "R", R);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "off_dce_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ alpha_occ;
      alpha_occ = DUMMY_VAR__;
      
      current_statement__ = 1;
      alpha_occ = in__.scalar();
      local_scalar_t__ beta_occ;
      beta_occ = DUMMY_VAR__;
      
      current_statement__ = 2;
      beta_occ = in__.scalar();
      local_scalar_t__ alpha_p;
      alpha_p = DUMMY_VAR__;
      
      current_statement__ = 3;
      alpha_p = in__.scalar();
      local_scalar_t__ beta_p;
      beta_p = DUMMY_VAR__;
      
      current_statement__ = 4;
      beta_p = in__.scalar();
      Eigen::Matrix<local_scalar_t__, -1, 1> logit_psi;
      logit_psi = Eigen::Matrix<local_scalar_t__, -1, 1>(R);
      stan::math::fill(logit_psi, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> logit_p;
      logit_p = Eigen::Matrix<local_scalar_t__, -1, -1>(R, T);
      stan::math::fill(logit_p, DUMMY_VAR__);
      
      current_statement__ = 7;
      assign(logit_psi, nil_index_list(),
        add(alpha_occ, multiply(beta_occ, X)), "assigning variable logit_psi");
      current_statement__ = 8;
      assign(logit_p, nil_index_list(),
        rep_matrix(add(alpha_p, multiply(beta_p, X)), T),
        "assigning variable logit_p");
      {
        current_statement__ = 33;
        for (int i = 1; i <= R; ++i) {
          current_statement__ = 31;
          if (sum_y[(i - 1)]) {
            current_statement__ = 28;
            lp_accum__.add(
              bernoulli_logit_lpmf<propto__>(1, logit_psi[(i - 1)]));
            current_statement__ = 29;
            lp_accum__.add(
              bernoulli_logit_lpmf<propto__>(y[(i - 1)],
                rvalue(logit_p, cons_list(index_uni(i), nil_index_list()),
                  "logit_p")));
          } else {
            current_statement__ = 26;
            lp_accum__.add(
              log_sum_exp(
                (bernoulli_logit_lpmf<false>(1, logit_psi[(i - 1)]) +
                  bernoulli_logit_lpmf<false>(0,
                    rvalue(logit_p,
                      cons_list(index_uni(i), nil_index_list()), "logit_p"))),
                bernoulli_logit_lpmf<false>(0, logit_psi[(i - 1)])));
          }}
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "off_dce_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double alpha_occ;
      alpha_occ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      alpha_occ = in__.scalar();
      double beta_occ;
      beta_occ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      beta_occ = in__.scalar();
      double alpha_p;
      alpha_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      alpha_p = in__.scalar();
      double beta_p;
      beta_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      beta_p = in__.scalar();
      Eigen::Matrix<double, -1, 1> logit_psi;
      logit_psi = Eigen::Matrix<double, -1, 1>(R);
      stan::math::fill(logit_psi, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> logit_p;
      logit_p = Eigen::Matrix<double, -1, -1>(R, T);
      stan::math::fill(logit_p, std::numeric_limits<double>::quiet_NaN());
      
      vars__.emplace_back(alpha_occ);
      vars__.emplace_back(beta_occ);
      vars__.emplace_back(alpha_p);
      vars__.emplace_back(beta_p);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 7;
      assign(logit_psi, nil_index_list(),
        add(alpha_occ, multiply(beta_occ, X)), "assigning variable logit_psi");
      current_statement__ = 8;
      assign(logit_p, nil_index_list(),
        rep_matrix(add(alpha_p, multiply(beta_p, X)), T),
        "assigning variable logit_p");
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
          vars__.emplace_back(logit_psi[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= R; ++sym2__) {
            vars__.emplace_back(
              rvalue(logit_p,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "logit_p"));
          }}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      int occ_fs;
      occ_fs = std::numeric_limits<int>::min();
      
      std::vector<double> psi_con;
      psi_con = std::vector<double>(R, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<int> z;
      z = std::vector<int>(R, std::numeric_limits<int>::min());
      
      current_statement__ = 24;
      for (int i = 1; i <= R; ++i) {
        current_statement__ = 22;
        if (logical_eq(sum_y[(i - 1)], 0)) {
          double psi;
          psi = std::numeric_limits<double>::quiet_NaN();
          
          current_statement__ = 15;
          psi = inv_logit(logit_psi[(i - 1)]);
          current_statement__ = 16;
          validate_non_negative_index("q", "T", T);
          Eigen::Matrix<double, -1, 1> q;
          q = Eigen::Matrix<double, -1, 1>(T);
          stan::math::fill(q, std::numeric_limits<double>::quiet_NaN());
          
          current_statement__ = 17;
          assign(q, nil_index_list(),
            transpose(
              inv_logit(
                minus(
                  rvalue(logit_p, cons_list(index_uni(i), nil_index_list()),
                    "logit_p")))), "assigning variable q");
          double qT;
          qT = std::numeric_limits<double>::quiet_NaN();
          
          current_statement__ = 18;
          qT = prod(
                 rvalue(q, cons_list(index_omni(), nil_index_list()), "q"));
          current_statement__ = 19;
          assign(psi_con, cons_list(index_uni(i), nil_index_list()),
            ((psi * qT) / ((psi * qT) + (1 - psi))),
            "assigning variable psi_con");
          current_statement__ = 20;
          assign(z, cons_list(index_uni(i), nil_index_list()),
            bernoulli_rng(psi_con[(i - 1)], base_rng__),
            "assigning variable z");
        } else {
          current_statement__ = 12;
          assign(psi_con, cons_list(index_uni(i), nil_index_list()), 1,
            "assigning variable psi_con");
          current_statement__ = 13;
          assign(z, cons_list(index_uni(i), nil_index_list()), 1,
            "assigning variable z");
        }}
      current_statement__ = 25;
      occ_fs = sum(z);
      vars__.emplace_back(occ_fs);
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        vars__.emplace_back(psi_con[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        vars__.emplace_back(z[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double alpha_occ;
      alpha_occ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      alpha_occ = context__.vals_r("alpha_occ")[(1 - 1)];
      double beta_occ;
      beta_occ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      beta_occ = context__.vals_r("beta_occ")[(1 - 1)];
      double alpha_p;
      alpha_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      alpha_p = context__.vals_r("alpha_p")[(1 - 1)];
      double beta_p;
      beta_p = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      beta_p = context__.vals_r("beta_p")[(1 - 1)];
      vars__.emplace_back(alpha_occ);
      vars__.emplace_back(beta_occ);
      vars__.emplace_back(alpha_p);
      vars__.emplace_back(beta_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("alpha_occ");
    names__.emplace_back("beta_occ");
    names__.emplace_back("alpha_p");
    names__.emplace_back("beta_p");
    names__.emplace_back("logit_psi");
    names__.emplace_back("logit_p");
    names__.emplace_back("occ_fs");
    names__.emplace_back("psi_con");
    names__.emplace_back("z");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(R)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(R),
                                             static_cast<size_t>(T)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(R)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(R)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha_occ");
    param_names__.emplace_back(std::string() + "beta_occ");
    param_names__.emplace_back(std::string() + "alpha_p");
    param_names__.emplace_back(std::string() + "beta_p");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "logit_psi" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= R; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "logit_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "occ_fs");
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "psi_con" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha_occ");
    param_names__.emplace_back(std::string() + "beta_occ");
    param_names__.emplace_back(std::string() + "alpha_p");
    param_names__.emplace_back(std::string() + "beta_p");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "logit_psi" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= R; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "logit_p" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "occ_fs");
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "psi_con" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"alpha_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"logit_psi\",\"type\":{\"name\":\"vector\",\"length\":" << R << "},\"block\":\"transformed_parameters\"},{\"name\":\"logit_p\",\"type\":{\"name\":\"matrix\",\"rows\":" << R << ",\"cols\":" << T << "},\"block\":\"transformed_parameters\"},{\"name\":\"occ_fs\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"psi_con\",\"type\":{\"name\":\"array\",\"length\":" << R << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << R << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"alpha_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"logit_psi\",\"type\":{\"name\":\"vector\",\"length\":" << R << "},\"block\":\"transformed_parameters\"},{\"name\":\"logit_p\",\"type\":{\"name\":\"matrix\",\"rows\":" << R << ",\"cols\":" << T << "},\"block\":\"transformed_parameters\"},{\"name\":\"occ_fs\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"psi_con\",\"type\":{\"name\":\"array\",\"length\":" << R << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << R << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = off_dce_model_namespace::off_dce_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return off_dce_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp off-small.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace off_small_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'off-small.stan', line 10, column 2 to column 12)",
                                                      " (in 'off-small.stan', line 11, column 2 to column 17)",
                                                      " (in 'off-small.stan', line 12, column 2 to column 17)",
                                                      " (in 'off-small.stan', line 13, column 2 to column 13)",
                                                      " (in 'off-small.stan', line 14, column 2 to column 13)",
                                                      " (in 'off-small.stan', line 15, column 2 to column 35)",
                                                      " (in 'off-small.stan', line 16, column 2 to column 35)",
                                                      " (in 'off-small.stan', line 17, column 2 to column 34)",
                                                      " (in 'off-small.stan', line 20, column 2 to column 15)",
                                                      " (in 'off-small.stan', line 21, column 2 to column 15)",
                                                      " (in 'off-small.stan', line 22, column 2 to column 18)",
                                                      " (in 'off-small.stan', line 24, column 2 to column 36)",
                                                      " (in 'off-small.stan', line 25, column 2 to column 37)",
                                                      " (in 'off-small.stan', line 28, column 4 to line 29, column 42)",
                                                      " (in 'off-small.stan', line 27, column 2 to line 29, column 42)",
                                                      " (in 'off-small.stan', line 32, column 2 to column 23)",
                                                      " (in 'off-small.stan', line 33, column 2 to column 23)",
                                                      " (in 'off-small.stan', line 34, column 2 to column 23)",
                                                      " (in 'off-small.stan', line 35, column 2 to column 23)",
                                                      " (in 'off-small.stan', line 37, column 2 to column 23)",
                                                      " (in 'off-small.stan', line 39, column 2 to column 29)",
                                                      " (in 'off-small.stan', line 2, column 2 to column 17)",
                                                      " (in 'off-small.stan', line 3, column 2 to column 17)",
                                                      " (in 'off-small.stan', line 4, column 30 to column 31)",
                                                      " (in 'off-small.stan', line 4, column 2 to column 33)",
                                                      " (in 'off-small.stan', line 5, column 9 to column 10)",
                                                      " (in 'off-small.stan', line 5, column 2 to column 17)",
                                                      " (in 'off-small.stan', line 6, column 9 to column 10)",
                                                      " (in 'off-small.stan', line 6, column 2 to column 22)",
                                                      " (in 'off-small.stan', line 7, column 9 to column 10)",
                                                      " (in 'off-small.stan', line 7, column 2 to column 14)",
                                                      " (in 'off-small.stan', line 11, column 9 to column 10)",
                                                      " (in 'off-small.stan', line 12, column 9 to column 10)",
                                                      " (in 'off-small.stan', line 20, column 9 to column 10)",
                                                      " (in 'off-small.stan', line 21, column 9 to column 10)",
                                                      " (in 'off-small.stan', line 22, column 9 to column 10)"};



class off_small_model final : public model_base_crtp<off_small_model> {

 private:
  int J;
  int N;
  std::vector<int> person;
  Eigen::Matrix<double, -1, 1> time;
  Eigen::Matrix<double, -1, 1> treatment;
  Eigen::Matrix<double, -1, 1> y;
 
 public:
  ~off_small_model() { }
  
  inline std::string model_name() const final { return "off_small_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  off_small_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "off_small_model_namespace::off_small_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 22;
      context__.validate_dims("data initialization","J","int",
          context__.to_vec());
      J = std::numeric_limits<int>::min();
      
      current_statement__ = 22;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 22;
      current_statement__ = 22;
      check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 23;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 23;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 23;
      current_statement__ = 23;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 24;
      validate_non_negative_index("person", "N", N);
      current_statement__ = 25;
      context__.validate_dims("data initialization","person","int",
          context__.to_vec(N));
      person = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 25;
      assign(person, nil_index_list(), context__.vals_i("person"),
        "assigning variable person");
      current_statement__ = 25;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 25;
        current_statement__ = 25;
        check_greater_or_equal(function__, "person[sym1__]",
                               person[(sym1__ - 1)], 1);}
      current_statement__ = 25;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 25;
        current_statement__ = 25;
        check_less_or_equal(function__, "person[sym1__]",
                            person[(sym1__ - 1)], J);}
      current_statement__ = 26;
      validate_non_negative_index("time", "N", N);
      current_statement__ = 27;
      context__.validate_dims("data initialization","time","double",
          context__.to_vec(N));
      time = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(time, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> time_flat__;
        current_statement__ = 27;
        assign(time_flat__, nil_index_list(), context__.vals_r("time"),
          "assigning variable time_flat__");
        current_statement__ = 27;
        pos__ = 1;
        current_statement__ = 27;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 27;
          assign(time, cons_list(index_uni(sym1__), nil_index_list()),
            time_flat__[(pos__ - 1)], "assigning variable time");
          current_statement__ = 27;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 28;
      validate_non_negative_index("treatment", "N", N);
      current_statement__ = 29;
      context__.validate_dims("data initialization","treatment","double",
          context__.to_vec(N));
      treatment = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(treatment, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> treatment_flat__;
        current_statement__ = 29;
        assign(treatment_flat__, nil_index_list(),
          context__.vals_r("treatment"),
          "assigning variable treatment_flat__");
        current_statement__ = 29;
        pos__ = 1;
        current_statement__ = 29;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 29;
          assign(treatment, cons_list(index_uni(sym1__), nil_index_list()),
            treatment_flat__[(pos__ - 1)], "assigning variable treatment");
          current_statement__ = 29;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 30;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 31;
      context__.validate_dims("data initialization","y","double",
          context__.to_vec(N));
      y = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(y, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> y_flat__;
        current_statement__ = 31;
        assign(y_flat__, nil_index_list(), context__.vals_r("y"),
          "assigning variable y_flat__");
        current_statement__ = 31;
        pos__ = 1;
        current_statement__ = 31;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 31;
          assign(y, cons_list(index_uni(sym1__), nil_index_list()),
            y_flat__[(pos__ - 1)], "assigning variable y");
          current_statement__ = 31;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 32;
      validate_non_negative_index("eta1", "J", J);
      current_statement__ = 33;
      validate_non_negative_index("eta2", "J", J);
      current_statement__ = 34;
      validate_non_negative_index("a1", "J", J);
      current_statement__ = 35;
      validate_non_negative_index("a2", "J", J);
      current_statement__ = 36;
      validate_non_negative_index("y_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += J;
      num_params_r__ += J;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "off_small_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ beta;
      beta = DUMMY_VAR__;
      
      current_statement__ = 1;
      beta = in__.scalar();
      Eigen::Matrix<local_scalar_t__, -1, 1> eta1;
      eta1 = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      stan::math::fill(eta1, DUMMY_VAR__);
      
      current_statement__ = 2;
      eta1 = in__.vector(J);
      Eigen::Matrix<local_scalar_t__, -1, 1> eta2;
      eta2 = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      stan::math::fill(eta2, DUMMY_VAR__);
      
      current_statement__ = 3;
      eta2 = in__.vector(J);
      local_scalar_t__ mu_a1;
      mu_a1 = DUMMY_VAR__;
      
      current_statement__ = 4;
      mu_a1 = in__.scalar();
      local_scalar_t__ mu_a2;
      mu_a2 = DUMMY_VAR__;
      
      current_statement__ = 5;
      mu_a2 = in__.scalar();
      local_scalar_t__ sigma_a1;
      sigma_a1 = DUMMY_VAR__;
      
      current_statement__ = 6;
      sigma_a1 = in__.scalar();
      current_statement__ = 6;
      if (jacobian__) {
        current_statement__ = 6;
        sigma_a1 = stan::math::lub_constrain(sigma_a1, 0, 100, lp__);
      } else {
        current_statement__ = 6;
        sigma_a1 = stan::math::lub_constrain(sigma_a1, 0, 100);
      }
      local_scalar_t__ sigma_a2;
      sigma_a2 = DUMMY_VAR__;
      
      current_statement__ = 7;
      sigma_a2 = in__.scalar();
      current_statement__ = 7;
      if (jacobian__) {
        current_statement__ = 7;
        sigma_a2 = stan::math::lub_constrain(sigma_a2, 0, 100, lp__);
      } else {
        current_statement__ = 7;
        sigma_a2 = stan::math::lub_constrain(sigma_a2, 0, 100);
      }
      local_scalar_t__ sigma_y;
      sigma_y = DUMMY_VAR__;
      
      current_statement__ = 8;
      sigma_y = in__.scalar();
      current_statement__ = 8;
      if (jacobian__) {
        current_statement__ = 8;
        sigma_y = stan::math::lub_constrain(sigma_y, 0, 100, lp__);
      } else {
        current_statement__ = 8;
        sigma_y = stan::math::lub_constrain(sigma_y, 0, 100);
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> a1;
      a1 = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      stan::math::fill(a1, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> a2;
      a2 = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      stan::math::fill(a2, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y_hat, DUMMY_VAR__);
      
      current_statement__ = 12;
      assign(a1, nil_index_list(),
        add((10 * mu_a1), multiply(sigma_a1, eta1)), "assigning variable a1");
      current_statement__ = 13;
      assign(a2, nil_index_list(),
        add((0.1 * mu_a2), multiply(sigma_a2, eta2)), "assigning variable a2");
      current_statement__ = 15;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 14;
        assign(y_hat, cons_list(index_uni(i), nil_index_list()),
          ((((beta * time[(i - 1)]) * treatment[(i - 1)]) +
             a1[(person[(i - 1)] - 1)]) +
            (a2[(person[(i - 1)] - 1)] * time[(i - 1)])),
          "assigning variable y_hat");}
      {
        current_statement__ = 16;
        lp_accum__.add(normal_lpdf<propto__>(mu_a1, 0, 1));
        current_statement__ = 17;
        lp_accum__.add(normal_lpdf<propto__>(eta1, 0, 1));
        current_statement__ = 18;
        lp_accum__.add(normal_lpdf<propto__>(mu_a2, 0, 1));
        current_statement__ = 19;
        lp_accum__.add(normal_lpdf<propto__>(eta2, 0, 1));
        current_statement__ = 20;
        lp_accum__.add(normal_lpdf<propto__>(beta, 0, 1));
        current_statement__ = 21;
        lp_accum__.add(normal_lpdf<propto__>(y, y_hat, sigma_y));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "off_small_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double beta;
      beta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      beta = in__.scalar();
      Eigen::Matrix<double, -1, 1> eta1;
      eta1 = Eigen::Matrix<double, -1, 1>(J);
      stan::math::fill(eta1, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      eta1 = in__.vector(J);
      Eigen::Matrix<double, -1, 1> eta2;
      eta2 = Eigen::Matrix<double, -1, 1>(J);
      stan::math::fill(eta2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      eta2 = in__.vector(J);
      double mu_a1;
      mu_a1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      mu_a1 = in__.scalar();
      double mu_a2;
      mu_a2 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      mu_a2 = in__.scalar();
      double sigma_a1;
      sigma_a1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      sigma_a1 = in__.scalar();
      current_statement__ = 6;
      sigma_a1 = stan::math::lub_constrain(sigma_a1, 0, 100);
      double sigma_a2;
      sigma_a2 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      sigma_a2 = in__.scalar();
      current_statement__ = 7;
      sigma_a2 = stan::math::lub_constrain(sigma_a2, 0, 100);
      double sigma_y;
      sigma_y = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 8;
      sigma_y = in__.scalar();
      current_statement__ = 8;
      sigma_y = stan::math::lub_constrain(sigma_y, 0, 100);
      Eigen::Matrix<double, -1, 1> a1;
      a1 = Eigen::Matrix<double, -1, 1>(J);
      stan::math::fill(a1, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> a2;
      a2 = Eigen::Matrix<double, -1, 1>(J);
      stan::math::fill(a2, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y_hat, DUMMY_VAR__);
      
      vars__.emplace_back(beta);
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        vars__.emplace_back(eta1[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        vars__.emplace_back(eta2[(sym1__ - 1)]);}
      vars__.emplace_back(mu_a1);
      vars__.emplace_back(mu_a2);
      vars__.emplace_back(sigma_a1);
      vars__.emplace_back(sigma_a2);
      vars__.emplace_back(sigma_y);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 12;
      assign(a1, nil_index_list(),
        add((10 * mu_a1), multiply(sigma_a1, eta1)), "assigning variable a1");
      current_statement__ = 13;
      assign(a2, nil_index_list(),
        add((0.1 * mu_a2), multiply(sigma_a2, eta2)), "assigning variable a2");
      current_statement__ = 15;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 14;
        assign(y_hat, cons_list(index_uni(i), nil_index_list()),
          ((((beta * time[(i - 1)]) * treatment[(i - 1)]) +
             a1[(person[(i - 1)] - 1)]) +
            (a2[(person[(i - 1)] - 1)] * time[(i - 1)])),
          "assigning variable y_hat");}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
          vars__.emplace_back(a1[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
          vars__.emplace_back(a2[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          vars__.emplace_back(y_hat[(sym1__ - 1)]);}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double beta;
      beta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      beta = context__.vals_r("beta")[(1 - 1)];
      Eigen::Matrix<double, -1, 1> eta1;
      eta1 = Eigen::Matrix<double, -1, 1>(J);
      stan::math::fill(eta1, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> eta1_flat__;
        current_statement__ = 2;
        assign(eta1_flat__, nil_index_list(), context__.vals_r("eta1"),
          "assigning variable eta1_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
          current_statement__ = 2;
          assign(eta1, cons_list(index_uni(sym1__), nil_index_list()),
            eta1_flat__[(pos__ - 1)], "assigning variable eta1");
          current_statement__ = 2;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> eta2;
      eta2 = Eigen::Matrix<double, -1, 1>(J);
      stan::math::fill(eta2, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> eta2_flat__;
        current_statement__ = 3;
        assign(eta2_flat__, nil_index_list(), context__.vals_r("eta2"),
          "assigning variable eta2_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
          current_statement__ = 3;
          assign(eta2, cons_list(index_uni(sym1__), nil_index_list()),
            eta2_flat__[(pos__ - 1)], "assigning variable eta2");
          current_statement__ = 3;
          pos__ = (pos__ + 1);}
      }
      double mu_a1;
      mu_a1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      mu_a1 = context__.vals_r("mu_a1")[(1 - 1)];
      double mu_a2;
      mu_a2 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      mu_a2 = context__.vals_r("mu_a2")[(1 - 1)];
      double sigma_a1;
      sigma_a1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      sigma_a1 = context__.vals_r("sigma_a1")[(1 - 1)];
      double sigma_a1_free__;
      sigma_a1_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      sigma_a1_free__ = stan::math::lub_free(sigma_a1, 0, 100);
      double sigma_a2;
      sigma_a2 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      sigma_a2 = context__.vals_r("sigma_a2")[(1 - 1)];
      double sigma_a2_free__;
      sigma_a2_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      sigma_a2_free__ = stan::math::lub_free(sigma_a2, 0, 100);
      double sigma_y;
      sigma_y = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 8;
      sigma_y = context__.vals_r("sigma_y")[(1 - 1)];
      double sigma_y_free__;
      sigma_y_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 8;
      sigma_y_free__ = stan::math::lub_free(sigma_y, 0, 100);
      vars__.emplace_back(beta);
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        vars__.emplace_back(eta1[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        vars__.emplace_back(eta2[(sym1__ - 1)]);}
      vars__.emplace_back(mu_a1);
      vars__.emplace_back(mu_a2);
      vars__.emplace_back(sigma_a1_free__);
      vars__.emplace_back(sigma_a2_free__);
      vars__.emplace_back(sigma_y_free__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("beta");
    names__.emplace_back("eta1");
    names__.emplace_back("eta2");
    names__.emplace_back("mu_a1");
    names__.emplace_back("mu_a2");
    names__.emplace_back("sigma_a1");
    names__.emplace_back("sigma_a2");
    names__.emplace_back("sigma_y");
    names__.emplace_back("a1");
    names__.emplace_back("a2");
    names__.emplace_back("y_hat");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(J)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(J)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(J)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(J)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "eta1" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "eta2" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "mu_a1");
    param_names__.emplace_back(std::string() + "mu_a2");
    param_names__.emplace_back(std::string() + "sigma_a1");
    param_names__.emplace_back(std::string() + "sigma_a2");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "a1" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "a2" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "beta");
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "eta1" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "eta2" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "mu_a1");
    param_names__.emplace_back(std::string() + "mu_a2");
    param_names__.emplace_back(std::string() + "sigma_a1");
    param_names__.emplace_back(std::string() + "sigma_a2");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "a1" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= J; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "a2" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eta1\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"parameters\"},{\"name\":\"eta2\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"parameters\"},{\"name\":\"mu_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"transformed_parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eta1\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"parameters\"},{\"name\":\"eta2\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"parameters\"},{\"name\":\"mu_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"transformed_parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = off_small_model_namespace::off_small_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return off_small_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp optimizations.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace optimizations_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'optimizations.stan', line 20, column 4 to column 15)",
                                                      " (in 'optimizations.stan', line 21, column 4 to column 13)",
                                                      " (in 'optimizations.stan', line 22, column 4 to column 26)",
                                                      " (in 'optimizations.stan', line 23, column 4 to column 23)",
                                                      " (in 'optimizations.stan', line 24, column 4 to column 24)",
                                                      " (in 'optimizations.stan', line 27, column 4 to column 11)",
                                                      " (in 'optimizations.stan', line 28, column 4 to column 19)",
                                                      " (in 'optimizations.stan', line 29, column 4 to column 19)",
                                                      " (in 'optimizations.stan', line 30, column 17 to column 28)",
                                                      " (in 'optimizations.stan', line 30, column 4 to column 28)",
                                                      " (in 'optimizations.stan', line 32, column 6 to column 24)",
                                                      " (in 'optimizations.stan', line 33, column 6 to column 22)",
                                                      " (in 'optimizations.stan', line 31, column 33 to line 34, column 5)",
                                                      " (in 'optimizations.stan', line 31, column 4 to line 34, column 5)",
                                                      " (in 'optimizations.stan', line 36, column 8 to column 21)",
                                                      " (in 'optimizations.stan', line 35, column 21 to line 37, column 5)",
                                                      " (in 'optimizations.stan', line 35, column 4 to line 37, column 5)",
                                                      " (in 'optimizations.stan', line 41, column 16 to column 29)",
                                                      " (in 'optimizations.stan', line 40, column 12 to line 41, column 29)",
                                                      " (in 'optimizations.stan', line 39, column 8 to line 41, column 29)",
                                                      " (in 'optimizations.stan', line 38, column 4 to line 41, column 29)",
                                                      " (in 'optimizations.stan', line 44, column 10 to column 16)",
                                                      " (in 'optimizations.stan', line 43, column 8 to line 44, column 16)",
                                                      " (in 'optimizations.stan', line 45, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 42, column 21 to line 46, column 5)",
                                                      " (in 'optimizations.stan', line 42, column 4 to line 46, column 5)",
                                                      " (in 'optimizations.stan', line 49, column 10 to column 19)",
                                                      " (in 'optimizations.stan', line 48, column 8 to line 49, column 19)",
                                                      " (in 'optimizations.stan', line 50, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 47, column 21 to line 51, column 5)",
                                                      " (in 'optimizations.stan', line 47, column 4 to line 51, column 5)",
                                                      " (in 'optimizations.stan', line 54, column 10 to column 19)",
                                                      " (in 'optimizations.stan', line 53, column 8 to line 54, column 19)",
                                                      " (in 'optimizations.stan', line 55, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 52, column 21 to line 56, column 5)",
                                                      " (in 'optimizations.stan', line 52, column 4 to line 56, column 5)",
                                                      " (in 'optimizations.stan', line 57, column 4 to column 10)",
                                                      " (in 'optimizations.stan', line 58, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 60, column 6 to column 12)",
                                                      " (in 'optimizations.stan', line 59, column 4 to line 60, column 12)",
                                                      " (in 'optimizations.stan', line 61, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 62, column 4 to column 11)",
                                                      " (in 'optimizations.stan', line 63, column 4 to column 12)",
                                                      " (in 'optimizations.stan', line 64, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 65, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 66, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 68, column 6 to column 19)",
                                                      " (in 'optimizations.stan', line 67, column 4 to line 68, column 19)",
                                                      " (in 'optimizations.stan', line 69, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 70, column 4 to column 11)",
                                                      " (in 'optimizations.stan', line 71, column 4 to column 10)",
                                                      " (in 'optimizations.stan', line 72, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 74, column 6 to column 12)",
                                                      " (in 'optimizations.stan', line 73, column 4 to line 74, column 12)",
                                                      " (in 'optimizations.stan', line 75, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 77, column 6 to column 9)",
                                                      " (in 'optimizations.stan', line 76, column 4 to line 77, column 9)",
                                                      " (in 'optimizations.stan', line 78, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 80, column 8 to column 19)",
                                                      " (in 'optimizations.stan', line 81, column 8 to column 15)",
                                                      " (in 'optimizations.stan', line 82, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 79, column 4 to line 83, column 5)",
                                                      " (in 'optimizations.stan', line 85, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 86, column 8 to column 16)",
                                                      " (in 'optimizations.stan', line 87, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 84, column 4 to line 88, column 5)",
                                                      " (in 'optimizations.stan', line 89, column 11 to column 25)",
                                                      " (in 'optimizations.stan', line 89, column 4 to column 25)",
                                                      " (in 'optimizations.stan', line 90, column 11 to column 23)",
                                                      " (in 'optimizations.stan', line 90, column 4 to column 23)",
                                                      " (in 'optimizations.stan', line 91, column 25 to column 28)",
                                                      " (in 'optimizations.stan', line 91, column 16 to column 19)",
                                                      " (in 'optimizations.stan', line 91, column 4 to column 28)",
                                                      " (in 'optimizations.stan', line 92, column 23 to column 24)",
                                                      " (in 'optimizations.stan', line 92, column 16 to column 17)",
                                                      " (in 'optimizations.stan', line 92, column 4 to column 24)",
                                                      " (in 'optimizations.stan', line 93, column 16 to column 19)",
                                                      " (in 'optimizations.stan', line 93, column 4 to column 19)",
                                                      " (in 'optimizations.stan', line 94, column 16 to column 17)",
                                                      " (in 'optimizations.stan', line 94, column 4 to column 17)",
                                                      " (in 'optimizations.stan', line 95, column 26 to column 27)",
                                                      " (in 'optimizations.stan', line 95, column 19 to column 20)",
                                                      " (in 'optimizations.stan', line 95, column 4 to column 27)",
                                                      " (in 'optimizations.stan', line 96, column 16 to column 30)",
                                                      " (in 'optimizations.stan', line 96, column 14 to column 32)",
                                                      " (in 'optimizations.stan', line 96, column 4 to column 32)",
                                                      " (in 'optimizations.stan', line 97, column 20 to column 26)",
                                                      " (in 'optimizations.stan', line 97, column 4 to column 26)",
                                                      " (in 'optimizations.stan', line 98, column 22 to column 28)",
                                                      " (in 'optimizations.stan', line 98, column 4 to column 28)",
                                                      " (in 'optimizations.stan', line 100, column 6 to column 15)",
                                                      " (in 'optimizations.stan', line 99, column 4 to line 100, column 15)",
                                                      " (in 'optimizations.stan', line 102, column 6 to column 12)",
                                                      " (in 'optimizations.stan', line 101, column 4 to line 102, column 12)",
                                                      " (in 'optimizations.stan', line 104, column 6 to column 7)",
                                                      " (in 'optimizations.stan', line 103, column 4 to line 104, column 7)",
                                                      " (in 'optimizations.stan', line 106, column 6 to column 15)",
                                                      " (in 'optimizations.stan', line 105, column 4 to line 106, column 15)",
                                                      " (in 'optimizations.stan', line 108, column 6 to column 12)",
                                                      " (in 'optimizations.stan', line 107, column 4 to line 108, column 12)",
                                                      " (in 'optimizations.stan', line 110, column 6 to column 7)",
                                                      " (in 'optimizations.stan', line 109, column 4 to line 110, column 7)",
                                                      " (in 'optimizations.stan', line 112, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 113, column 8 to column 9)",
                                                      " (in 'optimizations.stan', line 114, column 8 to column 9)",
                                                      " (in 'optimizations.stan', line 115, column 8 to column 21)",
                                                      " (in 'optimizations.stan', line 111, column 4 to line 116, column 5)",
                                                      " (in 'optimizations.stan', line 119, column 12 to column 24)",
                                                      " (in 'optimizations.stan', line 120, column 12 to column 13)",
                                                      " (in 'optimizations.stan', line 118, column 8 to line 121, column 9)",
                                                      " (in 'optimizations.stan', line 122, column 8 to column 9)",
                                                      " (in 'optimizations.stan', line 124, column 12 to column 13)",
                                                      " (in 'optimizations.stan', line 123, column 8 to line 125, column 9)",
                                                      " (in 'optimizations.stan', line 126, column 8 to column 10)",
                                                      " (in 'optimizations.stan', line 117, column 4 to line 127, column 5)",
                                                      " (in 'optimizations.stan', line 128, column 4 to column 14)",
                                                      " (in 'optimizations.stan', line 132, column 6 to column 21)",
                                                      " (in 'optimizations.stan', line 130, column 6 to column 19)",
                                                      " (in 'optimizations.stan', line 129, column 4 to line 132, column 21)",
                                                      " (in 'optimizations.stan', line 133, column 4 to column 17)",
                                                      " (in 'optimizations.stan', line 134, column 4 to column 15)",
                                                      " (in 'optimizations.stan', line 136, column 8 to column 22)",
                                                      " (in 'optimizations.stan', line 137, column 8 to column 23)",
                                                      " (in 'optimizations.stan', line 138, column 8 to column 24)",
                                                      " (in 'optimizations.stan', line 135, column 21 to line 139, column 5)",
                                                      " (in 'optimizations.stan', line 135, column 4 to line 139, column 5)",
                                                      " (in 'optimizations.stan', line 140, column 4 to column 25)",
                                                      " (in 'optimizations.stan', line 142, column 6 to column 27)",
                                                      " (in 'optimizations.stan', line 141, column 4 to line 142, column 27)",
                                                      " (in 'optimizations.stan', line 143, column 4 to column 26)",
                                                      " (in 'optimizations.stan', line 144, column 4 to column 22)",
                                                      " (in 'optimizations.stan', line 146, column 6 to column 28)",
                                                      " (in 'optimizations.stan', line 145, column 4 to line 146, column 28)",
                                                      " (in 'optimizations.stan', line 147, column 4 to column 23)",
                                                      " (in 'optimizations.stan', line 4, column 10 to column 17)",
                                                      " (in 'optimizations.stan', line 3, column 8 to line 4, column 17)",
                                                      " (in 'optimizations.stan', line 5, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 2, column 33 to line 6, column 5)",
                                                      " (in 'optimizations.stan', line 10, column 12 to column 26)",
                                                      " (in 'optimizations.stan', line 9, column 8 to line 10, column 26)",
                                                      " (in 'optimizations.stan', line 11, column 8 to column 21)",
                                                      " (in 'optimizations.stan', line 8, column 20 to line 12, column 5)",
                                                      " (in 'optimizations.stan', line 15, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 16, column 8 to column 18)",
                                                      " (in 'optimizations.stan', line 14, column 18 to line 17, column 5)"};


template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
nrfun_lp(const T0__& x, const int& y, T_lp__& lp__, T_lp_accum__& lp_accum__,
         std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 136;
    if (logical_gt(x, 342)) {
      current_statement__ = 135;
      return ;
    } 
    current_statement__ = 137;
    lp_accum__.add(y);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct nrfun_lp_functor__ {
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
operator()(const T0__& x, const int& y, T_lp__& lp__,
           T_lp_accum__& lp_accum__, std::ostream* pstream__)  const 
{
return nrfun_lp<propto__>(x, y, lp__, lp_accum__, pstream__);
}
};

int
rfun(const int& y, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 140;
    if (logical_gt(y, 2)) {
      current_statement__ = 139;
      return (y + 24);
    } 
    current_statement__ = 141;
    return (y + 2);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct rfun_functor__ {
int
operator()(const int& y, std::ostream* pstream__)  const 
{
return rfun(y, pstream__);
}
};

template <bool propto__, typename T_lp__, typename T_lp_accum__>
int
rfun_lp(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 143;
    lp_accum__.add(2);
    current_statement__ = 144;
    return 24;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct rfun_lp_functor__ {
template <bool propto__, typename T_lp__, typename T_lp_accum__>
int
operator()(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__)  const 
{
return rfun_lp<propto__>(lp__, lp_accum__, pstream__);
}
};

class optimizations_model final : public model_base_crtp<optimizations_model> {

 private:
  
 
 public:
  ~optimizations_model() { }
  
  inline std::string model_name() const final { return "optimizations_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  optimizations_model(stan::io::var_context& context__,
                      unsigned int random_seed__ = 0,
                      std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "optimizations_model_namespace::optimizations_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 3 * 2;
      num_params_r__ += 2;
      num_params_r__ += (2 + ((2 * (2 - 1)) / 2));
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "optimizations_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ theta;
      theta = DUMMY_VAR__;
      
      current_statement__ = 1;
      theta = in__.scalar();
      local_scalar_t__ phi;
      phi = DUMMY_VAR__;
      
      current_statement__ = 2;
      phi = in__.scalar();
      Eigen::Matrix<local_scalar_t__, -1, -1> x_matrix;
      x_matrix = Eigen::Matrix<local_scalar_t__, -1, -1>(3, 2);
      stan::math::fill(x_matrix, DUMMY_VAR__);
      
      current_statement__ = 3;
      x_matrix = in__.matrix(3, 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> x_vector;
      x_vector = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(x_vector, DUMMY_VAR__);
      
      current_statement__ = 4;
      x_vector = in__.vector(2);
      Eigen::Matrix<local_scalar_t__, -1, -1> x_cov;
      x_cov = Eigen::Matrix<local_scalar_t__, -1, -1>(2, 2);
      stan::math::fill(x_cov, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> x_cov_in__;
      x_cov_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>((2 +
                                                            ((2 * (2 - 1)) /
                                                              2)));
      stan::math::fill(x_cov_in__, DUMMY_VAR__);
      
      current_statement__ = 5;
      x_cov_in__ = in__.vector((2 + ((2 * (2 - 1)) / 2)));
      current_statement__ = 5;
      if (jacobian__) {
        current_statement__ = 5;
        assign(x_cov, nil_index_list(),
          stan::math::cov_matrix_constrain(x_cov_in__, 2, lp__),
          "assigning variable x_cov");
      } else {
        current_statement__ = 5;
        assign(x_cov, nil_index_list(),
          stan::math::cov_matrix_constrain(x_cov_in__, 2),
          "assigning variable x_cov");
      }
      {
        double x;
        x = std::numeric_limits<double>::quiet_NaN();
        
        current_statement__ = 7;
        nrfun_lp<false>(4, 3, lp__, lp_accum__, pstream__);
        current_statement__ = 8;
        if (pstream__) {
          stan_print(pstream__, rfun(3, pstream__));
          stan_print(pstream__, "\n");
        }
        current_statement__ = 10;
        if (rfun(4, pstream__)) {
          current_statement__ = 9;
          if (pstream__) {
            stan_print(pstream__, "a");
            stan_print(pstream__, "\n");
          }
        } 
        current_statement__ = 14;
        for (int i = rfun(7, pstream__); i <= rfun(5, pstream__); ++i) {
          current_statement__ = 11;
          lp_accum__.add(rfun(8, pstream__));
          current_statement__ = 12;
          nrfun_lp<false>(34, 3, lp__, lp_accum__, pstream__);}
        current_statement__ = 17;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 15;
          lp_accum__.add(53);}
        current_statement__ = 21;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 20;
          for (int j = i; j <= (i + 2); ++j) {
            current_statement__ = 19;
            for (int k = j; k <= (j * 2); ++k) {
              current_statement__ = 18;
              lp_accum__.add(53);}}}
        current_statement__ = 26;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 23;
          if (logical_gt(i, 4)) {
            break;
          } 
          current_statement__ = 24;
          lp_accum__.add(2);}
        current_statement__ = 31;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 28;
          if (logical_gt(i, 4)) {
            continue;
          } 
          current_statement__ = 29;
          lp_accum__.add(2);}
        current_statement__ = 36;
        for (int i = 1; i <= 5; ++i) {
          current_statement__ = 33;
          if (logical_gt(i, 4)) {
            continue;
          } 
          current_statement__ = 34;
          lp_accum__.add(2);}
        current_statement__ = 37;
        x = 3;
        current_statement__ = 38;
        lp_accum__.add(x);
        current_statement__ = 40;
        if (logical_gt(theta, 2)) {
          current_statement__ = 39;
          x = 2;
        } 
        current_statement__ = 41;
        lp_accum__.add(x);
        current_statement__ = 42;
        x = 24;
        current_statement__ = 43;
        x = 247;
        current_statement__ = 44;
        lp_accum__.add(x);
        current_statement__ = 45;
        x = (24 * 24);
        current_statement__ = 46;
        lp_accum__.add(x);
        current_statement__ = 48;
        if (logical_gt(theta, 46)) {
          current_statement__ = 47;
          x = (24 * 245);
        } 
        current_statement__ = 49;
        lp_accum__.add(x);
        double z;
        z = std::numeric_limits<double>::quiet_NaN();
        
        current_statement__ = 51;
        z = x;
        current_statement__ = 52;
        lp_accum__.add(z);
        current_statement__ = 54;
        if (logical_gt(theta, 46)) {
          current_statement__ = 53;
          z = x;
        } 
        current_statement__ = 55;
        lp_accum__.add(z);
        current_statement__ = 57;
        for (int i = 14; i <= 35; ++i) { }
        current_statement__ = 58;
        lp_accum__.add(2);
        {
          double y;
          y = std::numeric_limits<double>::quiet_NaN();
          
          current_statement__ = 59;
          y = 2;
          current_statement__ = 60;
          y = 24;
          current_statement__ = 61;
          lp_accum__.add(y);
        }
        {
          double y;
          y = std::numeric_limits<double>::quiet_NaN();
          
          current_statement__ = 63;
          y = 22;
          current_statement__ = 64;
          y = 245;
          current_statement__ = 65;
          lp_accum__.add(y);
        }
        current_statement__ = 68;
        if (0) {
          current_statement__ = 67;
          lp_accum__.add(235);
        } 
        current_statement__ = 70;
        if (1) {
          current_statement__ = 69;
          lp_accum__.add(2);
        } 
        current_statement__ = 73;
        if ((24 * 2)) {
          
        } else {
          
        }
        current_statement__ = 76;
        if ((24 * 2)) {
          ;
        } else {
          ;
        }
        current_statement__ = 78;
        if ((24 * 2)) {
          
        } 
        current_statement__ = 80;
        if ((20 * 2)) {
          ;
        } 
        current_statement__ = 83;
        if (rfun_lp<false>(lp__, lp_accum__, pstream__)) {
          ;
        } else {
          ;
        }
        current_statement__ = 86;
        while (0) {
          current_statement__ = 84;
          lp_accum__.add(325);
        }
        current_statement__ = 88;
        while ((24 * 24)) {
          break;
        }
        current_statement__ = 90;
        while (rfun_lp<false>(lp__, lp_accum__, pstream__)) {
          break;
        }
        current_statement__ = 92;
        for (int i = 31; i <= 225; ++i) { continue;}
        current_statement__ = 94;
        for (int i = 31; i <= 225; ++i) { break;}
        current_statement__ = 96;
        for (int i = 31; i <= 225; ++i) { ;}
        current_statement__ = 98;
        for (int i = rfun_lp<false>(lp__, lp_accum__, pstream__); i <= 225;
             ++i) { continue;}
        current_statement__ = 100;
        for (int i = rfun_lp<false>(lp__, lp_accum__, pstream__); i <= 225;
             ++i) { break;}
        current_statement__ = 102;
        for (int i = rfun_lp<false>(lp__, lp_accum__, pstream__); i <= 225;
             ++i) { ;}
        {
          current_statement__ = 103;
          lp_accum__.add(1);
          ;
          ;
          current_statement__ = 106;
          lp_accum__.add(24);
        }
        {
          {
            current_statement__ = 108;
            lp_accum__.add(1);
            ;
          }
          ;
          {
            ;
          }
          {
            
          }
        }
        double temp;
        temp = std::numeric_limits<double>::quiet_NaN();
        
        current_statement__ = 119;
        if (logical_gt(2, 3)) {
          current_statement__ = 118;
          temp = (2 * 2);
        } else {
          current_statement__ = 117;
          if (pstream__) {
            stan_print(pstream__, "hello");
            stan_print(pstream__, "\n");
          }
        }
        current_statement__ = 120;
        temp = (2 * 2);
        double temp2;
        temp2 = std::numeric_limits<double>::quiet_NaN();
        
        current_statement__ = 126;
        for (int i = 2; i <= 3; ++i) {
          current_statement__ = 122;
          temp2 = (2 * 3);
          current_statement__ = 123;
          lp_accum__.add(temp);
          current_statement__ = 124;
          lp_accum__.add(temp2);}
        double dataonlyvar;
        dataonlyvar = std::numeric_limits<double>::quiet_NaN();
        
        current_statement__ = 127;
        dataonlyvar = 3;
        current_statement__ = 129;
        if (logical_gt(3, 4)) {
          current_statement__ = 128;
          dataonlyvar = (3 * 53);
        } 
        current_statement__ = 130;
        lp_accum__.add(dataonlyvar);
        local_scalar_t__ paramvar;
        paramvar = DUMMY_VAR__;
        
        current_statement__ = 131;
        paramvar = 3;
        current_statement__ = 133;
        if (logical_gt(42, 1)) {
          current_statement__ = 132;
          paramvar = (theta * 34);
        } 
        current_statement__ = 134;
        lp_accum__.add(paramvar);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "optimizations_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double theta;
      theta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      theta = in__.scalar();
      double phi;
      phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      phi = in__.scalar();
      Eigen::Matrix<double, -1, -1> x_matrix;
      x_matrix = Eigen::Matrix<double, -1, -1>(3, 2);
      stan::math::fill(x_matrix, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      x_matrix = in__.matrix(3, 2);
      Eigen::Matrix<double, -1, 1> x_vector;
      x_vector = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(x_vector, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      x_vector = in__.vector(2);
      Eigen::Matrix<double, -1, -1> x_cov;
      x_cov = Eigen::Matrix<double, -1, -1>(2, 2);
      stan::math::fill(x_cov, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> x_cov_in__;
      x_cov_in__ = Eigen::Matrix<double, -1, 1>((2 + ((2 * (2 - 1)) / 2)));
      stan::math::fill(x_cov_in__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      x_cov_in__ = in__.vector((2 + ((2 * (2 - 1)) / 2)));
      current_statement__ = 5;
      assign(x_cov, nil_index_list(),
        stan::math::cov_matrix_constrain(x_cov_in__, 2),
        "assigning variable x_cov");
      vars__.emplace_back(theta);
      vars__.emplace_back(phi);
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          vars__.emplace_back(
            rvalue(x_matrix,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "x_matrix"));
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.emplace_back(x_vector[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          vars__.emplace_back(
            rvalue(x_cov,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "x_cov"));}}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double theta;
      theta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      theta = context__.vals_r("theta")[(1 - 1)];
      double phi;
      phi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      phi = context__.vals_r("phi")[(1 - 1)];
      Eigen::Matrix<double, -1, -1> x_matrix;
      x_matrix = Eigen::Matrix<double, -1, -1>(3, 2);
      stan::math::fill(x_matrix, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> x_matrix_flat__;
        current_statement__ = 3;
        assign(x_matrix_flat__, nil_index_list(),
          context__.vals_r("x_matrix"), "assigning variable x_matrix_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 3;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 3;
            assign(x_matrix,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_matrix_flat__[(pos__ - 1)], "assigning variable x_matrix");
            current_statement__ = 3;
            pos__ = (pos__ + 1);}}
      }
      Eigen::Matrix<double, -1, 1> x_vector;
      x_vector = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(x_vector, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> x_vector_flat__;
        current_statement__ = 4;
        assign(x_vector_flat__, nil_index_list(),
          context__.vals_r("x_vector"), "assigning variable x_vector_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 4;
          assign(x_vector, cons_list(index_uni(sym1__), nil_index_list()),
            x_vector_flat__[(pos__ - 1)], "assigning variable x_vector");
          current_statement__ = 4;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, -1> x_cov;
      x_cov = Eigen::Matrix<double, -1, -1>(2, 2);
      stan::math::fill(x_cov, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> x_cov_flat__;
        current_statement__ = 5;
        assign(x_cov_flat__, nil_index_list(), context__.vals_r("x_cov"),
          "assigning variable x_cov_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 5;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 5;
            assign(x_cov,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_cov_flat__[(pos__ - 1)], "assigning variable x_cov");
            current_statement__ = 5;
            pos__ = (pos__ + 1);}}
      }
      Eigen::Matrix<double, -1, 1> x_cov_free__;
      x_cov_free__ = Eigen::Matrix<double, -1, 1>((2 + ((2 * (2 - 1)) / 2)));
      stan::math::fill(x_cov_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      assign(x_cov_free__, nil_index_list(),
        stan::math::cov_matrix_free(x_cov), "assigning variable x_cov_free__");
      vars__.emplace_back(theta);
      vars__.emplace_back(phi);
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          vars__.emplace_back(
            rvalue(x_matrix,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "x_matrix"));
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.emplace_back(x_vector[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= (2 + ((2 * (2 - 1)) / 2)); ++sym1__) {
        vars__.emplace_back(x_cov_free__[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("theta");
    names__.emplace_back("phi");
    names__.emplace_back("x_matrix");
    names__.emplace_back("x_vector");
    names__.emplace_back("x_cov");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(3),
                                             static_cast<size_t>(2)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(2)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(2),
                                             static_cast<size_t>(2)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "theta");
    param_names__.emplace_back(std::string() + "phi");
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "x_matrix" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x_vector" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "x_cov" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "theta");
    param_names__.emplace_back(std::string() + "phi");
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "x_matrix" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x_vector" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= (2 + ((2 * (2 - 1)) / 2)); ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x_cov" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_matrix\",\"type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"x_vector\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"x_cov\",\"type\":{\"name\":\"matrix\",\"rows\":" << 2 << ",\"cols\":" << 2 << "},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_matrix\",\"type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"x_vector\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"x_cov\",\"type\":{\"name\":\"vector\",\"length\":" << (2 + ((2 * (2 - 1)) / 2)) << "},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = optimizations_model_namespace::optimizations_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return optimizations_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp partial-eval.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace partial_eval_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'partial-eval.stan', line 10, column 2 to column 19)",
                                                      " (in 'partial-eval.stan', line 11, column 2 to column 17)",
                                                      " (in 'partial-eval.stan', line 12, column 2 to column 12)",
                                                      " (in 'partial-eval.stan', line 13, column 2 to column 34)",
                                                      " (in 'partial-eval.stan', line 14, column 2 to column 34)",
                                                      " (in 'partial-eval.stan', line 17, column 2 to column 18)",
                                                      " (in 'partial-eval.stan', line 20, column 4 to line 21, column 42)",
                                                      " (in 'partial-eval.stan', line 19, column 2 to line 21, column 42)",
                                                      " (in 'partial-eval.stan', line 24, column 2 to column 22)",
                                                      " (in 'partial-eval.stan', line 25, column 2 to column 34)",
                                                      " (in 'partial-eval.stan', line 26, column 2 to column 24)",
                                                      " (in 'partial-eval.stan', line 27, column 2 to column 29)",
                                                      " (in 'partial-eval.stan', line 2, column 2 to column 17)",
                                                      " (in 'partial-eval.stan', line 3, column 2 to column 22)",
                                                      " (in 'partial-eval.stan', line 4, column 33 to column 34)",
                                                      " (in 'partial-eval.stan', line 4, column 2 to column 36)",
                                                      " (in 'partial-eval.stan', line 5, column 9 to column 10)",
                                                      " (in 'partial-eval.stan', line 5, column 2 to column 21)",
                                                      " (in 'partial-eval.stan', line 6, column 26 to column 27)",
                                                      " (in 'partial-eval.stan', line 6, column 2 to column 39)",
                                                      " (in 'partial-eval.stan', line 7, column 9 to column 10)",
                                                      " (in 'partial-eval.stan', line 7, column 2 to column 14)",
                                                      " (in 'partial-eval.stan', line 10, column 9 to column 15)",
                                                      " (in 'partial-eval.stan', line 17, column 9 to column 10)"};



class partial_eval_model final : public model_base_crtp<partial_eval_model> {

 private:
  int N;
  int n_pair;
  std::vector<int> pair;
  Eigen::Matrix<double, -1, 1> pre_test;
  Eigen::Matrix<double, -1, 1> treatment;
  Eigen::Matrix<double, -1, 1> y;
 
 public:
  ~partial_eval_model() { }
  
  inline std::string model_name() const final { return "partial_eval_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  partial_eval_model(stan::io::var_context& context__,
                     unsigned int random_seed__ = 0,
                     std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "partial_eval_model_namespace::partial_eval_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 13;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      N = std::numeric_limits<int>::min();
      
      current_statement__ = 13;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 13;
      current_statement__ = 13;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 14;
      context__.validate_dims("data initialization","n_pair","int",
          context__.to_vec());
      n_pair = std::numeric_limits<int>::min();
      
      current_statement__ = 14;
      n_pair = context__.vals_i("n_pair")[(1 - 1)];
      current_statement__ = 14;
      current_statement__ = 14;
      check_greater_or_equal(function__, "n_pair", n_pair, 0);
      current_statement__ = 15;
      validate_non_negative_index("pair", "N", N);
      current_statement__ = 16;
      context__.validate_dims("data initialization","pair","int",
          context__.to_vec(N));
      pair = std::vector<int>(N, std::numeric_limits<int>::min());
      
      current_statement__ = 16;
      assign(pair, nil_index_list(), context__.vals_i("pair"),
        "assigning variable pair");
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 16;
        current_statement__ = 16;
        check_greater_or_equal(function__, "pair[sym1__]",
                               pair[(sym1__ - 1)], 1);}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 16;
        current_statement__ = 16;
        check_less_or_equal(function__, "pair[sym1__]", pair[(sym1__ - 1)],
                            n_pair);}
      current_statement__ = 17;
      validate_non_negative_index("pre_test", "N", N);
      current_statement__ = 18;
      context__.validate_dims("data initialization","pre_test","double",
          context__.to_vec(N));
      pre_test = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(pre_test, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> pre_test_flat__;
        current_statement__ = 18;
        assign(pre_test_flat__, nil_index_list(),
          context__.vals_r("pre_test"), "assigning variable pre_test_flat__");
        current_statement__ = 18;
        pos__ = 1;
        current_statement__ = 18;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 18;
          assign(pre_test, cons_list(index_uni(sym1__), nil_index_list()),
            pre_test_flat__[(pos__ - 1)], "assigning variable pre_test");
          current_statement__ = 18;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 19;
      validate_non_negative_index("treatment", "N", N);
      current_statement__ = 20;
      context__.validate_dims("data initialization","treatment","double",
          context__.to_vec(N));
      treatment = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(treatment, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> treatment_flat__;
        current_statement__ = 20;
        assign(treatment_flat__, nil_index_list(),
          context__.vals_r("treatment"),
          "assigning variable treatment_flat__");
        current_statement__ = 20;
        pos__ = 1;
        current_statement__ = 20;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 20;
          assign(treatment, cons_list(index_uni(sym1__), nil_index_list()),
            treatment_flat__[(pos__ - 1)], "assigning variable treatment");
          current_statement__ = 20;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 20;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 20;
        current_statement__ = 20;
        check_greater_or_equal(function__, "treatment[sym1__]",
                               treatment[(sym1__ - 1)], 0);}
      current_statement__ = 20;
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 20;
        current_statement__ = 20;
        check_less_or_equal(function__, "treatment[sym1__]",
                            treatment[(sym1__ - 1)], 1);}
      current_statement__ = 21;
      validate_non_negative_index("y", "N", N);
      current_statement__ = 22;
      context__.validate_dims("data initialization","y","double",
          context__.to_vec(N));
      y = Eigen::Matrix<double, -1, 1>(N);
      stan::math::fill(y, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> y_flat__;
        current_statement__ = 22;
        assign(y_flat__, nil_index_list(), context__.vals_r("y"),
          "assigning variable y_flat__");
        current_statement__ = 22;
        pos__ = 1;
        current_statement__ = 22;
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 22;
          assign(y, cons_list(index_uni(sym1__), nil_index_list()),
            y_flat__[(pos__ - 1)], "assigning variable y");
          current_statement__ = 22;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 23;
      validate_non_negative_index("a", "n_pair", n_pair);
      current_statement__ = 24;
      validate_non_negative_index("y_hat", "N", N);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += n_pair;
      num_params_r__ += 2;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "partial_eval_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> a;
      a = Eigen::Matrix<local_scalar_t__, -1, 1>(n_pair);
      stan::math::fill(a, DUMMY_VAR__);
      
      current_statement__ = 1;
      a = in__.vector(n_pair);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      stan::math::fill(beta, DUMMY_VAR__);
      
      current_statement__ = 2;
      beta = in__.vector(2);
      local_scalar_t__ mu_a;
      mu_a = DUMMY_VAR__;
      
      current_statement__ = 3;
      mu_a = in__.scalar();
      local_scalar_t__ sigma_a;
      sigma_a = DUMMY_VAR__;
      
      current_statement__ = 4;
      sigma_a = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        sigma_a = stan::math::lub_constrain(sigma_a, 0, 100, lp__);
      } else {
        current_statement__ = 4;
        sigma_a = stan::math::lub_constrain(sigma_a, 0, 100);
      }
      local_scalar_t__ sigma_y;
      sigma_y = DUMMY_VAR__;
      
      current_statement__ = 5;
      sigma_y = in__.scalar();
      current_statement__ = 5;
      if (jacobian__) {
        current_statement__ = 5;
        sigma_y = stan::math::lub_constrain(sigma_y, 0, 100, lp__);
      } else {
        current_statement__ = 5;
        sigma_y = stan::math::lub_constrain(sigma_y, 0, 100);
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y_hat, DUMMY_VAR__);
      
      current_statement__ = 8;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 7;
        assign(y_hat, cons_list(index_uni(i), nil_index_list()),
          ((a[(pair[(i - 1)] - 1)] + (beta[(1 - 1)] * treatment[(i - 1)])) +
            (beta[(2 - 1)] * pre_test[(i - 1)])), "assigning variable y_hat");
      }
      {
        current_statement__ = 9;
        lp_accum__.add(normal_lpdf<propto__>(mu_a, 0, 1));
        current_statement__ = 10;
        lp_accum__.add(normal_lpdf<propto__>(a, (100 * mu_a), sigma_a));
        current_statement__ = 11;
        lp_accum__.add(normal_lpdf<propto__>(beta, 0, 100));
        current_statement__ = 12;
        lp_accum__.add(normal_lpdf<propto__>(y, y_hat, sigma_y));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "partial_eval_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      Eigen::Matrix<double, -1, 1> a;
      a = Eigen::Matrix<double, -1, 1>(n_pair);
      stan::math::fill(a, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      a = in__.vector(n_pair);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      beta = in__.vector(2);
      double mu_a;
      mu_a = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      mu_a = in__.scalar();
      double sigma_a;
      sigma_a = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      sigma_a = in__.scalar();
      current_statement__ = 4;
      sigma_a = stan::math::lub_constrain(sigma_a, 0, 100);
      double sigma_y;
      sigma_y = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      sigma_y = in__.scalar();
      current_statement__ = 5;
      sigma_y = stan::math::lub_constrain(sigma_y, 0, 100);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      stan::math::fill(y_hat, DUMMY_VAR__);
      
      for (int sym1__ = 1; sym1__ <= n_pair; ++sym1__) {
        vars__.emplace_back(a[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.emplace_back(beta[(sym1__ - 1)]);}
      vars__.emplace_back(mu_a);
      vars__.emplace_back(sigma_a);
      vars__.emplace_back(sigma_y);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 8;
      for (int i = 1; i <= N; ++i) {
        current_statement__ = 7;
        assign(y_hat, cons_list(index_uni(i), nil_index_list()),
          ((a[(pair[(i - 1)] - 1)] + (beta[(1 - 1)] * treatment[(i - 1)])) +
            (beta[(2 - 1)] * pre_test[(i - 1)])), "assigning variable y_hat");
      }
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
          vars__.emplace_back(y_hat[(sym1__ - 1)]);}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      Eigen::Matrix<double, -1, 1> a;
      a = Eigen::Matrix<double, -1, 1>(n_pair);
      stan::math::fill(a, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> a_flat__;
        current_statement__ = 1;
        assign(a_flat__, nil_index_list(), context__.vals_r("a"),
          "assigning variable a_flat__");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= n_pair; ++sym1__) {
          current_statement__ = 1;
          assign(a, cons_list(index_uni(sym1__), nil_index_list()),
            a_flat__[(pos__ - 1)], "assigning variable a");
          current_statement__ = 1;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 2;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            beta_flat__[(pos__ - 1)], "assigning variable beta");
          current_statement__ = 2;
          pos__ = (pos__ + 1);}
      }
      double mu_a;
      mu_a = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      mu_a = context__.vals_r("mu_a")[(1 - 1)];
      double sigma_a;
      sigma_a = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      sigma_a = context__.vals_r("sigma_a")[(1 - 1)];
      double sigma_a_free__;
      sigma_a_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      sigma_a_free__ = stan::math::lub_free(sigma_a, 0, 100);
      double sigma_y;
      sigma_y = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      sigma_y = context__.vals_r("sigma_y")[(1 - 1)];
      double sigma_y_free__;
      sigma_y_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      sigma_y_free__ = stan::math::lub_free(sigma_y, 0, 100);
      for (int sym1__ = 1; sym1__ <= n_pair; ++sym1__) {
        vars__.emplace_back(a[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        vars__.emplace_back(beta[(sym1__ - 1)]);}
      vars__.emplace_back(mu_a);
      vars__.emplace_back(sigma_a_free__);
      vars__.emplace_back(sigma_y_free__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("a");
    names__.emplace_back("beta");
    names__.emplace_back("mu_a");
    names__.emplace_back("sigma_a");
    names__.emplace_back("sigma_y");
    names__.emplace_back("y_hat");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_pair)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(2)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= n_pair; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "a" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "mu_a");
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= n_pair; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "a" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "mu_a");
    param_names__.emplace_back(std::string() + "sigma_a");
    param_names__.emplace_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= N; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y_hat" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" << n_pair << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"mu_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" << n_pair << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"mu_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = partial_eval_model_namespace::partial_eval_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return partial_eval_model_namespace::profiles__;
}

#endif



  $ ../../../../../install/default/bin/stanc --O --print-cpp stalled1-failure.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace stalled1_failure_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'stalled1-failure.stan', line 30, column 4 to column 16)",
                                                      " (in 'stalled1-failure.stan', line 31, column 4 to column 16)",
                                                      " (in 'stalled1-failure.stan', line 32, column 4 to column 16)",
                                                      " (in 'stalled1-failure.stan', line 33, column 4 to column 17)",
                                                      " (in 'stalled1-failure.stan', line 34, column 4 to column 22)",
                                                      " (in 'stalled1-failure.stan', line 35, column 4 to column 19)",
                                                      " (in 'stalled1-failure.stan', line 39, column 4 to column 15)",
                                                      " (in 'stalled1-failure.stan', line 40, column 4 to column 27)",
                                                      " (in 'stalled1-failure.stan', line 44, column 3 to column 31)",
                                                      " (in 'stalled1-failure.stan', line 45, column 3 to column 31)",
                                                      " (in 'stalled1-failure.stan', line 46, column 3 to column 31)",
                                                      " (in 'stalled1-failure.stan', line 47, column 3 to column 32)",
                                                      " (in 'stalled1-failure.stan', line 48, column 3 to column 31)",
                                                      " (in 'stalled1-failure.stan', line 50, column 6 to column 32)",
                                                      " (in 'stalled1-failure.stan', line 51, column 6 to column 103)",
                                                      " (in 'stalled1-failure.stan', line 49, column 18 to line 52, column 4)",
                                                      " (in 'stalled1-failure.stan', line 49, column 3 to line 52, column 4)",
                                                      " (in 'stalled1-failure.stan', line 15, column 4 to column 19)",
                                                      " (in 'stalled1-failure.stan', line 16, column 19 to column 20)",
                                                      " (in 'stalled1-failure.stan', line 16, column 4 to column 22)",
                                                      " (in 'stalled1-failure.stan', line 17, column 19 to column 20)",
                                                      " (in 'stalled1-failure.stan', line 17, column 4 to column 22)",
                                                      " (in 'stalled1-failure.stan', line 18, column 11 to column 12)",
                                                      " (in 'stalled1-failure.stan', line 18, column 4 to column 17)",
                                                      " (in 'stalled1-failure.stan', line 19, column 11 to column 12)",
                                                      " (in 'stalled1-failure.stan', line 19, column 4 to column 17)",
                                                      " (in 'stalled1-failure.stan', line 23, column 4 to column 10)",
                                                      " (in 'stalled1-failure.stan', line 24, column 11 to column 12)",
                                                      " (in 'stalled1-failure.stan', line 24, column 4 to column 19)",
                                                      " (in 'stalled1-failure.stan', line 25, column 4 to column 11)",
                                                      " (in 'stalled1-failure.stan', line 26, column 4 to column 21)",
                                                      " (in 'stalled1-failure.stan', line 35, column 16 to column 17)",
                                                      " (in 'stalled1-failure.stan', line 35, column 11 to column 12)"};



class stalled1_failure_model final : public model_base_crtp<stalled1_failure_model> {

 private:
  int I;
  std::vector<int> n;
  std::vector<int> N;
  Eigen::Matrix<double, -1, 1> x1;
  Eigen::Matrix<double, -1, 1> x2;
  int K;
  Eigen::Matrix<double, -1, 1> x1x2;
 
 public:
  ~stalled1_failure_model() { }
  
  inline std::string model_name() const final { return "stalled1_failure_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  stalled1_failure_model(stan::io::var_context& context__,
                         unsigned int random_seed__ = 0,
                         std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "stalled1_failure_model_namespace::stalled1_failure_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 18;
      context__.validate_dims("data initialization","I","int",
          context__.to_vec());
      I = std::numeric_limits<int>::min();
      
      current_statement__ = 18;
      I = context__.vals_i("I")[(1 - 1)];
      current_statement__ = 18;
      current_statement__ = 18;
      check_greater_or_equal(function__, "I", I, 0);
      current_statement__ = 19;
      validate_non_negative_index("n", "I", I);
      current_statement__ = 20;
      context__.validate_dims("data initialization","n","int",
          context__.to_vec(I));
      n = std::vector<int>(I, std::numeric_limits<int>::min());
      
      current_statement__ = 20;
      assign(n, nil_index_list(), context__.vals_i("n"),
        "assigning variable n");
      current_statement__ = 20;
      for (int sym1__ = 1; sym1__ <= I; ++sym1__) {
        current_statement__ = 20;
        current_statement__ = 20;
        check_greater_or_equal(function__, "n[sym1__]", n[(sym1__ - 1)], 0);}
      current_statement__ = 21;
      validate_non_negative_index("N", "I", I);
      current_statement__ = 22;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec(I));
      N = std::vector<int>(I, std::numeric_limits<int>::min());
      
      current_statement__ = 22;
      assign(N, nil_index_list(), context__.vals_i("N"),
        "assigning variable N");
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= I; ++sym1__) {
        current_statement__ = 22;
        current_statement__ = 22;
        check_greater_or_equal(function__, "N[sym1__]", N[(sym1__ - 1)], 0);}
      current_statement__ = 23;
      validate_non_negative_index("x1", "I", I);
      current_statement__ = 24;
      context__.validate_dims("data initialization","x1","double",
          context__.to_vec(I));
      x1 = Eigen::Matrix<double, -1, 1>(I);
      stan::math::fill(x1, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> x1_flat__;
        current_statement__ = 24;
        assign(x1_flat__, nil_index_list(), context__.vals_r("x1"),
          "assigning variable x1_flat__");
        current_statement__ = 24;
        pos__ = 1;
        current_statement__ = 24;
        for (int sym1__ = 1; sym1__ <= I; ++sym1__) {
          current_statement__ = 24;
          assign(x1, cons_list(index_uni(sym1__), nil_index_list()),
            x1_flat__[(pos__ - 1)], "assigning variable x1");
          current_statement__ = 24;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 25;
      validate_non_negative_index("x2", "I", I);
      current_statement__ = 26;
      context__.validate_dims("data initialization","x2","double",
          context__.to_vec(I));
      x2 = Eigen::Matrix<double, -1, 1>(I);
      stan::math::fill(x2, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> x2_flat__;
        current_statement__ = 26;
        assign(x2_flat__, nil_index_list(), context__.vals_r("x2"),
          "assigning variable x2_flat__");
        current_statement__ = 26;
        pos__ = 1;
        current_statement__ = 26;
        for (int sym1__ = 1; sym1__ <= I; ++sym1__) {
          current_statement__ = 26;
          assign(x2, cons_list(index_uni(sym1__), nil_index_list()),
            x2_flat__[(pos__ - 1)], "assigning variable x2");
          current_statement__ = 26;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 27;
      K = std::numeric_limits<int>::min();
      
      current_statement__ = 28;
      validate_non_negative_index("x1x2", "I", I);
      current_statement__ = 29;
      x1x2 = Eigen::Matrix<double, -1, 1>(I);
      stan::math::fill(x1x2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 30;
      K = 8;
      current_statement__ = 31;
      assign(x1x2, nil_index_list(), elt_multiply(x1, x2),
        "assigning variable x1x2");
      current_statement__ = 32;
      validate_non_negative_index("b", "I", I);
      current_statement__ = 33;
      validate_non_negative_index("b", "K", K);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += I * K;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "stalled1_failure_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ alpha0;
      alpha0 = DUMMY_VAR__;
      
      current_statement__ = 1;
      alpha0 = in__.scalar();
      local_scalar_t__ alpha1;
      alpha1 = DUMMY_VAR__;
      
      current_statement__ = 2;
      alpha1 = in__.scalar();
      local_scalar_t__ alpha2;
      alpha2 = DUMMY_VAR__;
      
      current_statement__ = 3;
      alpha2 = in__.scalar();
      local_scalar_t__ alpha12;
      alpha12 = DUMMY_VAR__;
      
      current_statement__ = 4;
      alpha12 = in__.scalar();
      local_scalar_t__ tau;
      tau = DUMMY_VAR__;
      
      current_statement__ = 5;
      tau = in__.scalar();
      current_statement__ = 5;
      if (jacobian__) {
        current_statement__ = 5;
        tau = stan::math::lb_constrain(tau, 0, lp__);
      } else {
        current_statement__ = 5;
        tau = stan::math::lb_constrain(tau, 0);
      }
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> b;
      b = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(I, Eigen::Matrix<local_scalar_t__, -1, 1>(K));
      stan::math::fill(b, DUMMY_VAR__);
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= I; ++sym1__) {
        current_statement__ = 6;
        assign(b, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(K), "assigning variable b");}
      local_scalar_t__ sigma;
      sigma = DUMMY_VAR__;
      
      current_statement__ = 8;
      sigma = (1 / stan::math::sqrt(tau));
      {
        current_statement__ = 9;
        lp_accum__.add(normal_lpdf<propto__>(alpha0, 0.0, 1.0E3));
        current_statement__ = 10;
        lp_accum__.add(normal_lpdf<propto__>(alpha1, 0.0, 1.0E3));
        current_statement__ = 11;
        lp_accum__.add(normal_lpdf<propto__>(alpha2, 0.0, 1.0E3));
        current_statement__ = 12;
        lp_accum__.add(normal_lpdf<propto__>(alpha12, 0.0, 1.0E3));
        current_statement__ = 13;
        lp_accum__.add(gamma_lpdf<propto__>(tau, 1.0E-3, 1.0E-3));
        current_statement__ = 17;
        for (int i = 1; i <= I; ++i) {
          current_statement__ = 14;
          lp_accum__.add(normal_lpdf<propto__>(b[(i - 1)], 0.0, sigma));
          current_statement__ = 15;
          lp_accum__.add(
            binomial_logit_lpmf<propto__>(n[(i - 1)], N[(i - 1)],
              add(
                (((alpha0 + (alpha1 * x1[(i - 1)])) + (alpha2 * x2[(i - 1)]))
                  + (alpha12 * x1x2[(i - 1)])), b[(i - 1)])));}
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "stalled1_failure_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double alpha0;
      alpha0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      alpha0 = in__.scalar();
      double alpha1;
      alpha1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      alpha1 = in__.scalar();
      double alpha2;
      alpha2 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      alpha2 = in__.scalar();
      double alpha12;
      alpha12 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      alpha12 = in__.scalar();
      double tau;
      tau = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      tau = in__.scalar();
      current_statement__ = 5;
      tau = stan::math::lb_constrain(tau, 0);
      std::vector<Eigen::Matrix<double, -1, 1>> b;
      b = std::vector<Eigen::Matrix<double, -1, 1>>(I, Eigen::Matrix<double, -1, 1>(K));
      stan::math::fill(b, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= I; ++sym1__) {
        current_statement__ = 6;
        assign(b, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(K), "assigning variable b");}
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      vars__.emplace_back(alpha0);
      vars__.emplace_back(alpha1);
      vars__.emplace_back(alpha2);
      vars__.emplace_back(alpha12);
      vars__.emplace_back(tau);
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
          vars__.emplace_back(b[(sym2__ - 1)][(sym1__ - 1)]);}}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 8;
      sigma = (1 / stan::math::sqrt(tau));
      if (emit_transformed_parameters__) {
        vars__.emplace_back(sigma);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double alpha0;
      alpha0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      alpha0 = context__.vals_r("alpha0")[(1 - 1)];
      double alpha1;
      alpha1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      alpha1 = context__.vals_r("alpha1")[(1 - 1)];
      double alpha2;
      alpha2 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      alpha2 = context__.vals_r("alpha2")[(1 - 1)];
      double alpha12;
      alpha12 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      alpha12 = context__.vals_r("alpha12")[(1 - 1)];
      double tau;
      tau = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      tau = context__.vals_r("tau")[(1 - 1)];
      double tau_free__;
      tau_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      tau_free__ = stan::math::lb_free(tau, 0);
      std::vector<Eigen::Matrix<double, -1, 1>> b;
      b = std::vector<Eigen::Matrix<double, -1, 1>>(I, Eigen::Matrix<double, -1, 1>(K));
      stan::math::fill(b, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<double> b_flat__;
        current_statement__ = 6;
        assign(b_flat__, nil_index_list(), context__.vals_r("b"),
          "assigning variable b_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 6;
          for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
            current_statement__ = 6;
            assign(b,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              b_flat__[(pos__ - 1)], "assigning variable b");
            current_statement__ = 6;
            pos__ = (pos__ + 1);}}
      }
      vars__.emplace_back(alpha0);
      vars__.emplace_back(alpha1);
      vars__.emplace_back(alpha2);
      vars__.emplace_back(alpha12);
      vars__.emplace_back(tau_free__);
      for (int sym1__ = 1; sym1__ <= I; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          vars__.emplace_back(b[(sym1__ - 1)][(sym2__ - 1)]);}}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("alpha0");
    names__.emplace_back("alpha1");
    names__.emplace_back("alpha2");
    names__.emplace_back("alpha12");
    names__.emplace_back("tau");
    names__.emplace_back("b");
    names__.emplace_back("sigma");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(I),
                                             static_cast<size_t>(K)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha0");
    param_names__.emplace_back(std::string() + "alpha1");
    param_names__.emplace_back(std::string() + "alpha2");
    param_names__.emplace_back(std::string() + "alpha12");
    param_names__.emplace_back(std::string() + "tau");
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "alpha0");
    param_names__.emplace_back(std::string() + "alpha1");
    param_names__.emplace_back(std::string() + "alpha2");
    param_names__.emplace_back(std::string() + "alpha12");
    param_names__.emplace_back(std::string() + "tau");
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= I; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "sigma");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"alpha0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha12\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"array\",\"length\":" << I << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"alpha0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha12\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"array\",\"length\":" << I << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = stalled1_failure_model_namespace::stalled1_failure_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return stalled1_failure_model_namespace::profiles__;
}

#endif




Warning: deprecated language construct used in 'stalled1-failure.stan', line 1, column 0:
   -------------------------------------------------
     1:  # Using Data Cloning to Calculate MLEs for the Seeds Model in vol1 
         ^
     2:  # http://www.openbugs.net/Examples/DataCloning.html
     3:  
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 2, column 0:
   -------------------------------------------------
     1:  # Using Data Cloning to Calculate MLEs for the Seeds Model in vol1 
     2:  # http://www.openbugs.net/Examples/DataCloning.html
         ^
     3:  
     4:  # The basic idea is that we raise the likelihood in the 
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 4, column 0:
   -------------------------------------------------
     2:  # http://www.openbugs.net/Examples/DataCloning.html
     3:  
     4:  # The basic idea is that we raise the likelihood in the 
         ^
     5:  # posterior to the power of K so that the posterior
     6:  # estimates would concentrate on the MLE estimates. 
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 5, column 0:
   -------------------------------------------------
     3:  
     4:  # The basic idea is that we raise the likelihood in the 
     5:  # posterior to the power of K so that the posterior
         ^
     6:  # estimates would concentrate on the MLE estimates. 
     7:  # Reference: 
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 6, column 0:
   -------------------------------------------------
     4:  # The basic idea is that we raise the likelihood in the 
     5:  # posterior to the power of K so that the posterior
     6:  # estimates would concentrate on the MLE estimates. 
         ^
     7:  # Reference: 
     8:  #   Ecology Letters
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 7, column 0:
   -------------------------------------------------
     5:  # posterior to the power of K so that the posterior
     6:  # estimates would concentrate on the MLE estimates. 
     7:  # Reference: 
         ^
     8:  #   Ecology Letters
     9:  #   Subhash R. Lele Brian Dennis Frithjof Lutscher
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 8, column 0:
   -------------------------------------------------
     6:  # estimates would concentrate on the MLE estimates. 
     7:  # Reference: 
     8:  #   Ecology Letters
         ^
     9:  #   Subhash R. Lele Brian Dennis Frithjof Lutscher
    10:  #   DOI: 10.1111/j.1461-0248.2007.01047.x
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 9, column 0:
   -------------------------------------------------
     7:  # Reference: 
     8:  #   Ecology Letters
     9:  #   Subhash R. Lele Brian Dennis Frithjof Lutscher
         ^
    10:  #   DOI: 10.1111/j.1461-0248.2007.01047.x
    11:  #   http://onlinelibrary.wiley.com/doi/10.1111/j.1461-0248.2007.01047.x/abstract
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 10, column 0:
   -------------------------------------------------
     8:  #   Ecology Letters
     9:  #   Subhash R. Lele Brian Dennis Frithjof Lutscher
    10:  #   DOI: 10.1111/j.1461-0248.2007.01047.x
         ^
    11:  #   http://onlinelibrary.wiley.com/doi/10.1111/j.1461-0248.2007.01047.x/abstract
    12:  
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 11, column 0:
   -------------------------------------------------
     9:  #   Subhash R. Lele Brian Dennis Frithjof Lutscher
    10:  #   DOI: 10.1111/j.1461-0248.2007.01047.x
    11:  #   http://onlinelibrary.wiley.com/doi/10.1111/j.1461-0248.2007.01047.x/abstract
         ^
    12:  
    13:  
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 25, column 7:
   -------------------------------------------------
    23:      int K; 
    24:      vector[I] x1x2;
    25:      K <- 8; // {1, 2, 4, 8, 16, 32, 64, 128, 256}
                ^
    26:      x1x2 <- x1 .* x2;
    27:  } 
   -------------------------------------------------

assignment operator <- is deprecated in the Stan language; use = instead.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 26, column 10:
   -------------------------------------------------
    24:      vector[I] x1x2;
    25:      K <- 8; // {1, 2, 4, 8, 16, 32, 64, 128, 256}
    26:      x1x2 <- x1 .* x2;
                   ^
    27:  } 
    28:  
   -------------------------------------------------

assignment operator <- is deprecated in the Stan language; use = instead.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 40, column 11:
   -------------------------------------------------
    38:  transformed parameters {
    39:      real sigma; 
    40:      sigma <- 1 / sqrt(tau); 
                    ^
    41:  } 
    42:  
   -------------------------------------------------

assignment operator <- is deprecated in the Stan language; use = instead.

  $ ../../../../../install/default/bin/stanc --O --print-cpp unroll-limit.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace unroll_limit_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'unroll-limit.stan', line 2, column 2 to column 8)",
                                                      " (in 'unroll-limit.stan', line 4, column 4 to column 15)",
                                                      " (in 'unroll-limit.stan', line 3, column 19 to line 5, column 3)",
                                                      " (in 'unroll-limit.stan', line 3, column 2 to line 5, column 3)",
                                                      " (in 'unroll-limit.stan', line 7, column 4 to column 15)",
                                                      " (in 'unroll-limit.stan', line 6, column 18 to line 8, column 3)",
                                                      " (in 'unroll-limit.stan', line 6, column 2 to line 8, column 3)",
                                                      " (in 'unroll-limit.stan', line 10, column 4 to column 15)",
                                                      " (in 'unroll-limit.stan', line 9, column 19 to line 11, column 3)",
                                                      " (in 'unroll-limit.stan', line 9, column 2 to line 11, column 3)",
                                                      " (in 'unroll-limit.stan', line 13, column 4 to column 15)",
                                                      " (in 'unroll-limit.stan', line 12, column 20 to line 14, column 3)",
                                                      " (in 'unroll-limit.stan', line 12, column 2 to line 14, column 3)",
                                                      " (in 'unroll-limit.stan', line 16, column 4 to column 15)",
                                                      " (in 'unroll-limit.stan', line 15, column 20 to line 17, column 3)",
                                                      " (in 'unroll-limit.stan', line 15, column 2 to line 17, column 3)"};



class unroll_limit_model final : public model_base_crtp<unroll_limit_model> {

 private:
  
 
 public:
  ~unroll_limit_model() { }
  
  inline std::string model_name() const final { return "unroll_limit_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = %%NAME%%3 %%VERSION%%", "stancflags = --O --print-cpp"};
  }
  
  
  unroll_limit_model(stan::io::var_context& context__,
                     unsigned int random_seed__ = 0,
                     std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "unroll_limit_model_namespace::unroll_limit_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "unroll_limit_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "unroll_limit_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      int x;
      x = std::numeric_limits<int>::min();
      
      current_statement__ = 4;
      for (int i = 1; i <= 100; ++i) {
        current_statement__ = 2;
        x = (x + (1 + i));}
      current_statement__ = 7;
      for (int i = 1; i <= 20; ++i) {
        current_statement__ = 5;
        x = (x + (2 + i));}
      current_statement__ = 10;
      for (int i = 50; i <= 70; ++i) {
        current_statement__ = 8;
        x = (x + (3 + i));}
      current_statement__ = 13;
      for (int i = -10; i <= 10; ++i) {
        current_statement__ = 11;
        x = (x + (4 + i));}
      current_statement__ = 16;
      for (int i = -10; i <= 40; ++i) {
        current_statement__ = 14;
        x = (x + (5 + i));}
      vars__.emplace_back(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("x");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "x");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "x");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"x\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"x\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        

};
}
using stan_model = unroll_limit_model_namespace::unroll_limit_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return unroll_limit_model_namespace::profiles__;
}

#endif



